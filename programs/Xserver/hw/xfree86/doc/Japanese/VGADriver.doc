  XFree86 へ (S)VGA ドライバを追加する方法
  Copyright (c) 1993, 1994 David E. Wexelblat
  <dwex@XFree86.org>
  1.3 号 - 1994 年 5 月 29 日
  X Japanese Documentation Project <http://xjman.dsl.gr.jp/>
  1999 年 2 月 6 日
  ____________________________________________________________

  目次

  1. 序文
  2. 始めに
  3. ディレクトリ構造
  4. 生成情報の設定
  5. バンク切り替え機能
  6. ドライバ自身について
     6.1 複数のチップセットとオプション
     6.2 データ構造
     6.3 Ident() 関数
     6.4 ClockSelect() 関数
     6.5 Probe() 関数
     6.6 EnterLeave() 関数
     6.7 Restore() 関数
     6.8 Save() 関数
     6.9 Init() 関数
     6.10 Adjust() 関数
     6.11 ValidMode() 関数
     6.12 SaveScreen() 関数
     6.13 GetMode() 関数
     6.14 FbInit() 関数

  7. 新サーバの生成
  8. デバッグ
  9. アドバイス
  10. 高度な話題
  11. 参考文献
  12. ベンダー連絡先情報

  ______________________________________________________________________

  1.  序文

  XFree86 に新しい SVGA チップセットのサポートを追加することはハードウェ
  アに密着したプログラミングについて学習したい人にとって手ごたえのある作
  業です。このような作業には危険が一杯です。特に、マシンがハングアップし
  てしまうようなことは日常茶飯事です。それでも最終的に、サーバが立ち上
  がってうまく動いてくれた時は、底知れぬ満足感にひたれます。

  SVGA チップセット対応のドライバを追加することはサーバの基本機能を変更
  するものではありません。ただ、256 色同時発色のカラーサーバかモノクロサ
  ーバが出来るだけです。新しいハードウェア（例えばアクセラレータチップ）
  を追加することは重要な仕事で、文書化出来るような定型的作業には程遠いも
  のです。

  それにもかかわらず、ここで行うドライバを書くようなプログラミングは良い
  入門となります。多くのアクセラレータチップセットは SVGA の上位互換であ
  るため、それらに対するサポートを追加するための最初の段階としても意味の
  ある作業です。該当するチップに対応した SVGA のドライバを書くことによっ
  て、新しい機能を追加するときに安定した開発環境で作業できます (実
  際、XFree86 2.0 のために S3, Cirrus および WD のアクセラレータ対応サー
  バーを開発した際には、先にこれらのチップセットに対応した SVGA ドライバ
  が作成され、XFree86 内部の開発者たちによって使用されました。)

  [訳注: 最近では個別のアクセラレータ対応サーバーを開発することよりむし
  ろアクセラレータ対応の SVGA ドライバを開発することのほうが多いようで
  す。3.3.3 で追加された Cyrix や NeoMagic の他 S3V, Trident, C&T などの
  SVGA ドライバはアクセラレータに対応しています。一方 3Dlabs や I128 の
  ように最近でも個別のアクセラレータ対応サーバーとして開発された例もあり
  ます。また、以下の説明は XFree86 3.x までのコードをベースとしています
  が、現在 XFree86 で開発中の 4.0 ではサーバーの構造に大きな変更が加えら
  れており、以下の説明がそのまま合てはまらなくなっています。これから新し
  いドライバーを書こうという場合には、できるだけ XFree86 に参加して最初
  から 4.0 用に作成したほうが良いでしょう。それでも、以下の説明を理解し
  ておくことは無駄ではありません。用語や基本的な仕組などについては参考に
  なるものと思います。]

  さあ、始めましょう。この文書に加えて、スタブドライバを提供しています。
  これは新しいドライバを開発する際に完全な骨組みとして使えるように提供す
  るものです。この文書が大きいからといって作業が過度に難しいと思わないで
  ください。この文書をできる限り完全なものに近づけるために、多くの努力が
  注がれました。ですから理論的には、この文書を作業手順書として使い、最後
  までその手順に従って実行していけば、ちゃんと動作するドライバーができあ
  がるはずです。なお作業を開始する前に、この文書を最初から最後までじっく
  り読み通しておくことをお勧めします。

  2.  始めに

  新しいドライバを作る最初の段階はそのチップセットに関する資料を集めるこ
  とです。今までにわたしが集めたベンダーの連絡先情報一覧をこの文書に入れ
  ています (完璧とは言えないものですので、この一覧に無いもので知っている
  ものがありましたら著者まで送ってください)。チップセットのデータブック
  を取り寄せる必要があります。ベンダーの担当者には、レジスタを直接操作し
  てプログラミングしたいのだとくれぐれも念を押す様にしてください。 (そう
  すれば電気的スペックシートを受け取らずに済みます)

  なにかサンプルプログラムか開発者用のキット等を入手できるかどうか問い合
  わせてください。一般的に言って、SVGA レベルの開発作業において最も必要
  となる資料は、レジスタの一覧やその説明を記載しているデータブックである
  ことをわたしは学びました。

  VGA レジスタを直接操作するようなプログラミングに慣れていない場合は
  Richard Ferraro の必読書を入手して (是非読んで！) 下さい (この文章の最
  後に添付した「参考文献」を見てください)。サーバで何が起っているかを理
  解する最良の方法はモノクロの ``generic'' サーバの動作を調べ、Ferraro
  の本に書かれている情報と比較することです (本に少し間違いがあることに注
  意してください)。generic サーバーで使われる VGA レジスタを扱う関数は
  ``vgaHW.c'' ファイルの中に含まれています。

  generic なサーバで何が起っているか理解したら、一つまたは複数の既存の
  SVGA サーバについて調べてください。サポートしている SVGA チップのデー
  タブックを入手してプログラムを追いながら文書を調査してください。
  generic な VGA から何が仕様を超えていて何が仕様に収まっているか良く理
  解したら、新しいチップについてデータブックからどんな情報を得ればよいか
  分かるでしょう。この情報を得られれば、新しいドライバに取りかかる準備が
  できたことになります。

  3.  ディレクトリ構造

  ここではソースのディレクトリ構造の概要を説明します。ドライバの作成に関
  連するディレクトリ／ファイルだけを示しています。リンクキットの構造は以
  降で示します。

     xc/config/cf/

        site.def
           ローカルな構成のカスタマイズ
        xf86site.def
           XFree86 のローカルな構成のカスタマイズ

           [訳注: 最近は xf86site.def を直接編集するより host.def という
           ファイルに内容をコピーして、それを編集する方法が推奨されてい
           るようです。]

     xc/programs/Xserver/hw/xfree86/
        サーバのソース

        common/
           全サーバに共通なファイル (XF86Config のパラメータ解析/パーサ,
           I/O デバイスハンドラ等)

           xf86.h
              `ScrnInfoRec' データ構造を含む

           xf86_Option.h
              オプションフラグを含む

           compiler.h
              インラインアセンブラマクロとユーティリティ関数を含む

        os-support/
           OS サポート層

           assyntax.h
              マクロ化したアセンブラニモニックを含む

           xf86_OSlib.h
              OS がサポートする include, define と プロトタイプ

        LinkKit/

           site.def.LK
              リンクキットの site.def 用のテンプレート

        vga256/
           256 色 VGA サーバのディレクトリ

           vga/
              generic な VGA を取り扱うプログラム

              vga.h
                 `vgaVideoChipRec' と `vgaHWRec' データ構造を含む

              vgaHW.c
                 generic な VGA レジスタを取り扱う関数 vgaHWInit(),
                 vgaHWSave() と vgaHWRestore()を含む

           drivers/
              SVGA ドライバのサブディレクトリを含む各々、ドライバ用
              Imakefile, .c ファイルとバンク切り替え関数用の .s ファイル
              を含む

        vga2/
           モノクロの vga サーバのディレクトリ。vga256 にリンクするファ
           イルと条件コンパイルで使用する差分

           drivers/
              SVGA ドライバのサブディレクトリ。`generic' な VGA ドライバ
              もここに配置する

        vga16/
           16 色 vga サーバのディレクトリ。vga256 にリンクする殆どのファ
           イルと条件コンパイルで使用する差分

           drivers/
              SVGA ドライバのサブディレクトリ

        VGADriverDoc/
           この文書とスタブドライバ

  リンクキットは通常 /usr/X11R6/lib/Server に導入します。リンクキットに
  はサーバを再リンクするために必要なものがすべて含まれています。サーバの
  ソースを導入しなくても、新しいドライバを作成し、新しいサーバを生成する
  ことが可能です。

     Server/

        site.def
           ローカルな構成のカスタマイズ

        include/
           上記 `common' ディレクトリ下にある全ての include ファイル

        drivers/
           すべての SVGA ドライバ

           vga2/
              SVGA ドライバのサブディレクトリ

           vga16/
              SVGA ドライバのサブディレクトリ

           vga256/
              SVGA ドライバのサブディレクトリ

        VGADriverDoc/
           この文書とスタブドライバのディレクトリ参考のために `vgaHW.c'
           もここにコピーされます (リンクキットの一部としては生成しませ
           ん)

  4.  生成情報の設定

  この節では新しいドライバの設定に必要な周辺の構成変更と生成手順について
  説明します。この手順はソースから生成するかリンクキットから生成するかに
  かかわらず同様で、ただファイルの配置が異なっているだけのことです。以下
  に必要な構成変更について説明します:

  1. ドライバのためのサブディレクトリ名とデータ構造を決定して下さい。現
     在のドライバー体系では、単一のドライバ内に関連する複数のチップセッ
     トのためのドライバを実装することが可能であるため (実際にはそうする
     ことが奨励されています) 通常チップセットのバージョンよりベンダー名
     を使用するほうが良いでしょう。たしかに古い XFree86 のドライバはこの
     規定に従っていませんが、そのことはこれから開発するドライバーが規定
     に従わなくて良いという理由にはなりません。それらの古いコードのほと
     んどは、ドライバのインターフェースが現在のように柔軟かつ拡張可能に
     なる前に開発されたものです。

     この文書では SuperDuper Chips というベンダーのチップを例に取り挙げ
     ます。以降、ドライバの名称に `sdc' を用います。

  2. サポート対象をカラーサーバ、モノクロサーバ、または両方、のどれにす
     るか決めてください。この文書では、カラーとモノクロ両方のサーバをサ
     ポートするものと仮定しています。カラーサーバだけをサポートする場
     合、モノクロサーバを実現するための段階は無視してかまいません。モノ
     クロサーバだけをサポートする場合は、カラーサーバのために記述されて
     いる段階をモノクロサーバのために実行し、モノクロサーバのための段階
     は無視してください。既存のドライバはほとんどがカラーのみか、または
     両方のサーバをサポートしています。``generic'' ドライバは (現時点で)
     モノクロサーバのみをサポートする唯一のドライバーです。

  3. ドライバのディレクトリを作成してください:

  o  ソースから作業する場合は、次のディレクトリを作成してください:

        xc/programs/Xserver/hw/xfree86/vga256/drivers/sdc
        xc/programs/Xserver/hw/xfree86/vga16/drivers/sdc
        xc/programs/Xserver/hw/xfree86/vga2/drivers/sdc

  o  リンクキットから作業する場合は次のディレクトリを作成してください:

        /usr/X11R6/lib/Server/drivers/vga256/sdc
        /usr/X11R6/lib/Server/drivers/vga16/sdc
        /usr/X11R6/lib/Server/drivers/vga2/sdc

  4. ドライバを生成する為の Imakefile パラメタを設定しましょう:

  o  ソースから作業するなら:

     a. xc/config/cf/xfree86.cf を編集して `sdc' を `XF86Vga256Drivers',
        `XF86Vga16Drivers' と `XF86Vga2Drivers' の定義の一覧に追加してく
        ださい。一覧の `generic' の直前 (例えば最後から二番目) に `sdc'
        を追加し、他のドライバの探査によって誤って `sdc' チップセットが
        検知されないかどうか確認するようにしてください。

     b. xc/config/cf/xf86site.def を編集してこのファイルにも同じ項目を追
        加してください (これは標準値を示す単なるコメントです)。

     c. xc/programs/Xserver/hw/xfree86/LinkKit/ にある site.def.LK ファ
        イルを編集してこのファイルに同じ項目を追加してください。これはリ
        ンクキットの中に含まれる `site.def' ファイルの雛型です。

  o  リンクキットから作業をするなら、/usr/X11R6/lib/Server/site.def を編
     集して`sdc' を `XF86Vga256Drivers', `XF86Vga16Drivers' と
     `XF86Vga2Drivers' の定義に最初に書いた様に追加してください。

  5. さて新しいディレクトリに雛型のファイルをコピーしましょう:

  o  ソースから作業するなら、`stub' ファイルを次のようにコピーしてくださ
     い (ディレクトリは xc/programs/Xserver の下です):

     Imakefile.stub =>
        hw/xfree86/vga256/drivers/sdc/Imakefile

     stub_driver.c =>
        hw/xfree86/vga256/drivers/sdc/sdc_driver.c

     stub_bank.s =>
        hw/xfree86/vga256/drivers/sdc/sdc_bank.s

     Imakefile.stub =>
        hw/xfree86/vga16/drivers/sdc/Imakefile (そしてこの Imakefile を
        編集し、コメントに従って変更してください)

     Imakefile.stub =>
        hw/xfree86/vga2/drivers/sdc/Imakefile (そしてこの Imakefile を編
        集し、コメントに従って変更してください)

  o  リンクキットから作業するなら、`stub' ファイルを次のようにコピーして
     ください:

     Imakefile.stub =>
        /usr/X11R6/lib/Server/drivers/vga256/sdc/Imakefile

     stub_driver.c =>
        /usr/X11R6/lib/Server/drivers/vga256/sdc/sdc_driver.c

     stub_bank.s =>
        /usr/X11R6/lib/Server/drivers/vga256/sdc/sdc_bank.s

     Imakefile.stub =>
        /usr/X11R6/lib/Server/drivers/vga16/sdc/Imakefile (そしてこの
        Imakefile を編集し、コメントに従って変更してください)

     Imakefile.stub =>
        /usr/X11R6/lib/Server/drivers/vga2/sdc/Imakefile (そしてこの
        Imakefile を編集し、コメントに従って変更してください)

  6. たった今コピーした各々のファイルを編集して `stub' を `sdc' に、
     `STUB' を `SDC' にすべて置き換えてください。

     必要な準備作業は以上です。これで実際のドライバを作成する作業ができ
     ます。

  5.  バンク切り替え機能

  普通の VGA メモリマップは 0xA0000 から始まる 64k です。64k より大きな
  メモリにアクセスするための機構として、SuperVGA チップセットは ``バンク
  切り替え機能 (bank switching)'' - 高位のアドレスビットにより画像操作を
  行うメモリバンクを選択する機能を実装しています。バンクのサイズと数は
  チップセットによりさまざまであり、詳細はそれぞれのチップセットに関する
  資料に記載されています。チップセットの持つバンクレジスタの数は 0, 1, 2
  のいずれかです。バンクレジスタなしの場合はたぶん generic な VGA *だけ*
  なので、ここでは関係ありません。

  新しいチップセット (例えば Trident 8900CL や Cirrus 製チップなど) はビ
  デオメモリをリニアに割り当てる事が可能であることに注意してください。こ
  の仕組を使うことによってサーバの性能を向上できますが、現在ではまたこの
  機能のサポートはありません。従って、新しいチップセットについてもこの機
  能を活用できる方法はまだありません。

  [訳注: 例えば C&T や Trident などのアクセラレータに対応している SVGA
  ドライバーは PCI バス上のチップについてリニアアドレスの使用が標準と
  なっています。もし興味があるなら、既存のコードを調べてみると良いでしょ
  う。]

  ほとんどの SVGA チップセットは二つのバンクレジスタを持っています。デー
  タを画面のある領域から他の領域に単純な 'mov' 命令で移動できるため最も
  望ましい構造です (もしバンク構造に ``望ましい'' と呼べるものが存在する
  なら、ですが)。二重化バンキング (dual-banking) には二つの方式があり、
  一方は二つのバンク操作により読み込み専用バンクと書き込み専用バンクを定
  義するもので、もう一方は二つの書き込み／読み込み兼用窓を持つ方式です。
  最初の方式は SVGA メモリ窓全体を読み込みと書き込みの両方に使い、二つの
  バンクレジスタによってどちらのバンクを実際に使うかを指定します。 (例:
  ET3000, ET4000) 二番目の方式では SVGA メモリ窓を読み込み／書き込み可能
  な二つのバンクに分配し、それぞれのバンクポインタが一つの窓を制御しま
  す。この場合には一つの窓が読み込み操作に使用され、他の窓が書き込み操作
  に使用されます。 (例: PVGA1/Western Digital, Cirrus)

  単一のバンクレジスタを持つチップセットは、その一つのバンクを読み込みと
  書き出しの両方に使用します。画面のある部分の情報を他の部分へとコピーす
  るには、データを読み込み、蓄え、それから書き出すという手順が要求される
  ため、この方式はあまり好ましいものではありません。幸運にも、チップセッ
  トの持つバンク数が一つでも二つでも、サーバーは問題無く扱うことができま
  す。次に説明するドライバデータ構造中の項目を定義することによってその挙
  動が決まります。

  ドライバを動作させるにはまず `sdc_bank.s' ファイル内に三つの関数をアセ
  ンブラ言語で書く必要があります。これらの関数は、バンク読み込み設定 -
  SDCSetRead(), バンク書き出し設定 - SDCSetWrite() と 両バンク設定 -
  SDCSetReadWrite() です。一つのバンクしか持たないチップセットの場合は、
  三つの関数すべてを同じ関数へのエントリーポイントとして宣言できるでしょ
  う。 (``tvga8900'' ドライバを例として参照してください)

  [訳注: 3.3.3.1 の場合 vga256/drivers/tvga8900/bank.s の最初に書いてあ
  る TVGA8900{SetReadWrite,SetRead,SetWrite} の 3 つが同じ関数に対するエ
  ントリーポイントとして書かれています。なお i386Architecture 以外は
  bankc.c が使われますが、こちらはここで説明している例とは異なります。
  (そもそも C で書かれてます) i386Architecture 以外の環境でドライバーを
  開発しようとする人は注意して下さい。 ]

  これらの関数はとても単純なものです - バンク番号が関数の %al レジスタへ
  渡されるので、その値に対してシフトやビットマスクなど、バンク番号を正し
  い形式に変換するための操作を実行した後、適切な I/O ポートへその値を書
  き出します。二つのバンクが同時に読み込み専用になったり書き出し専用に
  なったりするチップセットの場合、 SetReadWrite()関数はそれぞれのバンク
  に対して一回づつ、計二回上記の動作を実行する必要があります。二つの独立
  な読み込み／書き出し窓を持つチップセットの場合、 SetReadWrite() 関数は
  SetWrite() 関数が使うのと同じバンクを使用します。

  特別な注意として、これらの関数は ``assyntax.h'' ファイルで定義されてい
  るマクロアセンブラの書式で書く必要があります。これは OS に関係なく正し
  いアセンブラコードを生成することを保証する為です。現在、このマクロ形式
  は USL, GNU と インテルのアセンブラの書式をサポートしています。

  以上がバンク機能に関する作業です。普通、チップセットに関する資料がこの
  プログラムの例題を掲載していますが、そうでない場合でも他のドライバを例
  にとれば理解することは難しくはありません。

  6.  ドライバ自身について

  さて本来の作業、つまりドライバの主要な機能を sdc_driver.c ファイルに書
  く作業に取りかかりましょう。まず、ドライバが提供しなければいけない機能
  の概要は次のとおりです:

  1. チップセット記述子のデータ構造をサーバに提供します。このデータ構造
     にはドライバ関数へのポインタに加えていくつかのデータ構造に対する初
     期値も含まれます。

  2. チップセットのレジスタ内容を保持するためにドライバ内部で使用するデ
     ータ構造を提供します。このデータ構造には一般的な部分とドライバ固有
     の部分があります。これはチップセットの初期状態を保存するために使用
     され、またチップセットの表示モードを変更するためにドライバーによっ
     て初期化されます。

  3. ドライバがサポートしているチップセットの一覧を呼び出すためにサーバ
     が使う識別機能を提供します。

  4. ドライバがサポートしているチップセットがインストールされていれば、
     そのチップセットを他のチップセットと異なるものとして認識しプラスの
     値を返すが、そうでなければマイナスの値を返すという探査機能を提供し
     ます。

  5. そのボードで使用可能なドットクロックを選択する機能を提供します。

  6. ドライバ内部で使用するデータ構造の保存、回復、初期化機能を提供しま
     す。

  7. ビデオメモリ内にディスプレイの開始アドレスを設定する機能を提供しま
     す。これはサーバが仮想スクリーンを実現するために必要な機能です。

  8. たぶん VT 切り替えを行うための機能を提供したほうが良いでしょう。

  9. 指定された各モードがそのチップセットの使用するモードとしてふさわし
     いかどうかチェックする機能を提供したほうが良いでしょう。

  ドライバファイルの具体的な中身に踏み込んでいく前に知っておくべき、重要
  な情報がここにあります:

  1. ドライバがカラーとモノクロサーバの両方をサポートする場合、一つの
     ファイルに両方の場合のコードが含まれていることに注意してください。
     これらはほとんど同じものですが、MONOVGA を #define してある所で両者
     を区別することが出来ます。 16 色サーバをサポートする場合、このサー
     バーに固有のコードは XF86VGA16 の #define によって有効化されるよう
     にしてください。ほとんどの場合、次の指定を stub_driver.c ファイルの
     先頭近くに置いておけば充分です。

        #ifdef XF86VGA16
        #define MONOVGA
        #endif

  2. カラーサーバは SVGA の 8-ビットパックトピクセルモードを使用します。
     モノクロと vga16 サーバは VGA の 16-色モード（4 ビットプレーン）を
     使用します。モノクロサーバでは 1 プレーンだけ使用します。
     [ 訳注 : パックトピクセル： 1 ドットのピクセル（画面上の点）を表現
     するのに、連続した 8 ビットを 4 つ並べて表わす方式。 4 ビットプレー
     ン： 1 ドットを表わすのに、それぞれの色毎にプレーンを持ち各プレーン
     上の連続しない 8 ビット 4 つを使って表わす方式。]

  3. モノクロサーバをバンク切り替えを使わないように定義することが可能で
     す。これは表示領域のメモリをたった 64k しか使えないため、あまり魅力
     的ではありません。

     これらのことを踏まえて、自分の使う SVGA チップセットの中で所定の機
     能を制御するレジスタを探す必要があります。特に、以下の項目を制御で
     きるレジスタは重要です：

  1. クロック選択ビット。低位の 2 ビットは標準 Misc 出力レジスタ
     (Miscellaneous Output Register) の一部です。ほとんどの SVGA チップ
     セットはこれに加えてさらに 1 あるいは 2 ビットを備えており、これに
     よって 8 または 16 の離散的なクロック値を使用できます。 [ 訳注：最
     近のチップではプログラマブルクロックを使用することが一般的になって
     いるようです。詳細は既存のコードを参照。 ]

  2. バンク選択。SVGA チップセットは読み書きするバンクの選択を制御するた
     めのレジスタを一つか二つ持っているでしょう。

  3. CRTC 機能拡張。標準 VGA レジスタは高解像度表示を行うのに十分なビッ
     ト数を持っていません。このため SVGA チップセットは拡張ビットを持っ
     ています。
  4. インターレースモード。標準 VGA はインターレース表示をサポートしてい
     ません。このため SVGA チップセットはインターレースモードを制御する
     ビットをどこかに持っています。ある種のチップセットではインターレー
     スモードを制御するために独自に追加されたレジスタを設定しなければな
     りません。

  5. 開始アドレス。標準 VGA では表示用メモリの開始アドレスを指定するため
     に 16 ビットしか使えません。これは仮想スクリーン機能で使う画面サイ
     ズ (解像度) を制限します。SVGA チップセットは通常一つかそれ以上の拡
     張ビットを持っています。

  6. レジスタロック。多くの SVGA チップセットではレジスタを最初に
     ``unlocked'' にしない限り拡張レジスタの内容を変更できません。レジス
     タの内容を変更したい場合には、まずこの保護を無効にすることが必要で
     す。

  7. その他の機能。例えば、ある種のチップセットでは拡張 VGA メモリ
     （IBM-標準の 265k を超える）にアクセスするために、前もって特定の
     ビットを設定しておく必要があります。あるいは他にもなにか必要な機能
     があるかもしれません。各レジスタの詳細な説明をすべて読み通して、何
     か重要な機能が記載されていないかどうか、ちゃんとチェックしておきま
     しょう。

  運がよければ、チップセットのベンダーがデータブックに様々な BIOS モード
  用のレジスタ設定表を掲載してくれているでしょう。この表をじっくり見てそ
  れぞれの BIOS モードを調べることによって、どんな操作をしなければならな
  いかについて多くのことを学ぶことが出来ます。

  6.1.  複数のチップセットとオプション

  同じベンダーから出荷している複数のチップセットを単一のドライバでサポー
  トすることが可能であり、むしろ望ましいとされています。複数のチップセッ
  トをサポートする場合、それらに対応する一連の #define と、ドライバコー
  ド中でチップセットの識別が必要な時に使用する`SDCchipset' 変数を用意す
  ることになるでしょう。具体的な例としては Trident と PVGA1/WD を参照し
  てください（Tseng ET3000 と ET4000 はこれに沿っていない例です。これら
  のコードは複数のチップセットをサポートするためのドライバインターフェー
  スが開発される前に実装されたものであり、現在ではこのような実装方法に従
  うべきではありません。) ドライバーがチップセットのバージョンを区別して
  認識するべきなのは、それらが互いに異なる扱いを必要とする場合だけである
  ことに注意してください。例えば、SDC ドライバが SDC-1a,SDC-1b および
  SDC-2 というチップセットをサポートしているとしましょう。さらにこのと
  き、チップセット -1a と-1b は実質的に同じものであり、-2 は異なるものだ
  とします。このような場合には、ドライバーコードは -1 と -2 の 2 種類の
  チップセットとしてサポートするべきであり、 -1a と -1b を区別するべきで
  はありません。これによってエンドユーサの設定作業も単純になることでしょ
  う。

  ユーザにドライバの挙動を制御させたい場合、または何かを決定するためにユ
  ーザによる介入を必要とする場合には、``option'' フラッグを使いましょ
  う。例えば SDC チップセットを使うビデオボードのベンダーが、 8 クロック
  に対応するボードと 16 クロックに対応するボードを選択できるようにしてい
  たならば、これらのボードをチップセットに対する探査の結果から識別する方
  法はありませんので、 option フラッグを提供し、ユーザが XF86Config ファ
  イルを使ってドライバの挙動を選択できるようにするべきです。 option フ
  ラッグは ``xf86_option.h'' ファイルに定義します。再利用可能な option
  が既に存在していないかどうか、最初に確認しておきましょう。もし存在する
  場合はそれを使ってください。再利用可能なものが無かった場合は、新たに
  #define を追加し、同じファイルにある「文字列->シンボル」の対応を定義す
  るテーブル中に追加する option フラッグで使う文字列を定義します。
  option フラッグの使い方を理解するには ET4000, PVGA1/WD と Trident のド
  ライバを参照してください。

  6.2.  データ構造

  上記の説明から何が必要なのか理解したら、ドライバのデータ構造を記入する
  段階に進みましょう。最初に `vgaSDCRec' の構造を作成します。このデータ
  構造は SVGA の状態情報を保持するためにドライバ内部で使用するデータ構造
  です。このデータ構造の最初の項目は「常に」 `vgaHWRec std' とします。こ
  の項目は汎用 VGA に関する部分の情報を保持するためのものです。これに続
  いて、追加するドライバによって操作されるレジスタのひとつひとつに対応す
  る `unsigned char' の領域を用意してください。これが最初のデータ構造の
  全てです。

  次に `SDC' 構造 (`vgaVideoChipRec' 型) の初期化をしなければいけませ
  ん。これは追加するドライバをサーバに識別させるためのグローバルな構造体
  です。この構造体の名称はすべて大文字で `SDC' としなければなりません。
  これはつまり、追加するドライバコードの存在するディレクトリの名称と一致
  させる必要がある、ということです。これはリンクキットの再構成時に必要な
  ディレクトリとグローバルなデータ構造をすべて認識させるための条件です。

  この構造体の最初の部分は単にドライバ関数へのポインタを保持しておくため
  に使用されます。

  次に、チップセットがバンク切り替えをどう扱うかについての情報を初期化し
  なければなりません。次に示すような内容の領域を用意する必要があります:

  1. ChipMapSize - サーバのアドレス空間に割り付けるメモリ量。ほとんどの
     場合には 64k (0xA0000 から 0xAFFFF まで) です。チップセットによって
     は 128k (0xA0000 から 0xBFFFF まで) を使います。もし使用するチップ
     セットがどちらにも対応しているのなら 64k の窓を使ってください。128k
     の窓を使用すると Hercules またはモノクロディスプレイアダプタのカー
     ドを SVGA サーバーで使うことができなくなります。

  2. ChipSegmentSize - ChipMapSize の窓内のバンクの大きさ。これもまた通
     常 64k ですが、チップセットによっては割り付けられた窓を読み込み部分
     と書き込み部分に分割して扱います（例えば PVGA1/Western Digital チッ
     プセット）。

  3. ChipSegmentShift - バンク番号をマスクするためにアドレスを右シフトす
     る際のビット数。これは 2 を底にした ChipSegmentSize の対数 (log) に
     なります。

  4. ChipSegmentMask - 与えられたバンク内のアドレスをマスクオフするとき
     のビットマスク。これは (ChipSegmentSize-1) になります。

  5. ChipReadBottom,ChipReadTop - 割り付けられた窓内で読み込み操作を行う
     ためのアドレス。チップセットが窓を読み込み用と書き込み用に分割する
     場合を除けば、通常はそれぞれ 0 と 64k になります。

  6. ChipWriteBottom,ChipWriteTop - 書き込み操作のためのものであるという
     点以外は、上記と同様です。

  7. ChipUse2Banks - チップセットのバンクレジスタが 1 つまたは 2 つのど
     ちらであるかを示すブーリアン値。これはスクリーンからスクリーンへの
     操作を適切に設定するために使用されます。

     これに加えてさらに 3 個の領域を用意しなければなりません:

  1. ChipInterlaceType - VGA_NO_DIVIDE_VERT または VGA_DIVIDE_VERT のど
     ちらかになります。チップセットによってはインタレースモード用に垂直
     方向の調整数値を 2 で割ったものを必要とします。このフラッグを設定す
     ることによって、サーバがそれに応じた処理をしてくれます。

  2. ChipOptionFlags - データ構造の初期化では常に `{0,}' とします。これ
     はこのドライバで有効な Option フラッグを示すビット列です。探査関数
     の終了時に適正な値に初期化されます。
  3. ChipRounding - 256 色サーバの場合、仮想スクリーンの幅はここで設定し
     た値の倍数になるよう丸められます。この値は通常 8 ですが、チップセッ
     トによっては 4 とか 16 にする場合もあります。

  6.3.  Ident() 関数

  Ident() 関数は大変単純な関数です。サーバは自分自身に組み込まれているド
  ライバの一覧を出力するときに、返り値が NULL になるまでこの関数を繰り返
  し呼び出します。 Ident() 関数はサポートしているチップセットのそれぞれ
  についてその名称を返さなければなりません。この関数には繰り返して呼ばれ
  るたびに 0 から順に 1 つずつ増加していく数値が渡されます。

  6.4.  ClockSelect() 関数

  ClockSelect() 関数は、クロックを探査する（これはつまり、 XF86Config
  ファイルで `Clocks' 行を指定しなかった場合ですが）際に、パラメータの一
  部として渡された数値により指示されたドットクロックを選択するために使用
  されます。この関数は、渡された数値に従ってチップセットの clock-select
  ビットを設定しなければなりません。これに加えて 2 種類のダミーとしての
  値 (CLK_REG_SAVE, CLK_SAVE_RESTORE) がこの関数に渡される場合もありま
  す。 CLK_REG_SAVE を受け取った場合には、関数がクロックの選択中に内容を
  変更する可能性のあるすべてのレジスタについて、その内容を保存しておくよ
  うにします。 CLK_REG_RESTORE を受け取った場合には、これらのレジスタに
  ついて、関数が保存しておいた内容を回復するようにします。これは、クロッ
  ク探査によってレジスタの内容が破壊されないことを確実にするためのもので
  す。

  渡されたインデックスが不正な値であるか、もしくは何らかの理由によってク
  ロックを設定できなかった場合、この関数は FALSE を返すべきです。

  6.5.  Probe() 関数

  Probe() 関数はドライバの中で多分最も重要でかつ最も直感的でない関数で
  しょう。 Probe 関数は他のすべてのチップセットを誤認識することなく、対
  象とするチップセットを識別しなければなりません。もし XF86Config ファイ
  ルに `Chipset' 行が指定されているのなら、単純な文字列比較を実行させる
  だけです。それ以外の場合には、どんなチップセットがシステムにインストー
  ルされているか、何か別の方法で判定しなければなりません。運がよければ、
  チップセットに認識機構 (識別/バージョンレジスタなど) が用意されてい
  て、かつそのことがデータブックに説明されているでしょう。さもなければ、
  次に述べるような基準を使い、何らかの手順を決めて認識させなければなりま
  せん。

  認識手順としてよく使われるのは、対象とするチップに固有のパターンがレジ
  スタ中に存在するかどうかを調べる方法、またはそのチップに固有の拡張レジ
  スタが存在するかどうかを調べる方法です。あるいはボードやチップセットに
  よっては、特定の署名文字列を BIOS から読み取ることによって必要な情報を
  入手することの可能な場合もあります。既存の探査関数を勉強すること、およ
  び参考資料をきちんと使うことが最善のアドバイスです。またここで追加する
  探査関数のコードが非破壊的なものであることを確認しておかなければなりま
  せん。これは、もし探査中にレジスタの内容を変更するのであれば、最初に元
  のレジスタ設定を保存しておかなければいかないこと、そして最後に自分が保
  存した内容を復元しておかなければいけないことを意味します。

  うまくチップセットを認識できたら、Probe() 関数はさらに他の部分の初期化
  をも行う必要があります。

  1. XF86Config ファイルに `VideoRam' パラメタが指定されていない場合に備
     えて、搭載メモリ量を判定する必要があります。

  2. XF86Config ファイルに `Clocks' パラメタが指定されていない場合に備え
     て、使用可能なドットクロックの値を判定する必要があります。これは
     vgaGetClocks() 関数を呼び出して、使用できるクロックの数と
     ClockSelect() 関数へのポインタを渡してやることで実現できます。

  3. サーバの `vga256InfoRec' 構造体に用意されている `maxClock' 領域にド
     ライバーが認識したチップセットで許容可能な最大ドットクロックを (KHz
     単位で) 指定しておくことをお勧めします。探査時にこの値を指定しなけ
     れば、標準値 (現在は 90MHz) が使用されます。

  4. サーバの `vga256InfoRec' 構造体に用意されている `chipset' 領域を搭
     載チップセットの名称によって初期化しなければなりません。

  5. ドライバがモノクロサーバと組み合わせて使用されるのなら、サーバの
     `vga256InfoRec' 構造体に用意されている `bankedMono' 領域を適切に設
     定して、モノクロドライバがバンク切り替えをサポートしているかどうか
     を示さなければいけません。

  6. 新しく作成するドライバーが何らかのオプションフラッグをサポートする
     場合には、 `vgaVideoChipRec' 型として定義した `SDC' 構造の中に含ま
     れている `ChipOptionFlags' 構造体を OFLG_SET() マクロを用いて初期化
     し、使用を認めるオプションフラッグをこの中に設定しておくことが必要
     です。

  6.6.  EnterLeave() 関数

  EnterLeave() 関数はサーバを起動した仮想コンソールに入ったり出たりする
  度に呼ばれます(仮想コンソール機能をもたない OS では、この関数はまずサ
  ーバーの開始時に呼ばれ、終了時にもう一度呼ばれます)。この関数の目的は
  (そうすることが必要な OS の場合に) I/O の権限を譲渡したり剥奪したりす
  ること、およびドライバが操作しなければならない ``保護された''レジスタ
  へのアクセスをロック解除したり再ロックしたりすることです。これは非常に
  簡単な関数であり、スタブドライバ中のコメントに書かれた方法で実装できま
  す。

  6.7.  Restore() 関数

  Restore() 関数は保存しておいたビデオ状態を回復するために使用されます。
  この `restore' という名称は少しばかり誤った名称であり、実際には保存さ
  れた状態を回復するためばかりでなく、サーバが新規に作成した状態へと移行
  するためにこの関数を使用することもあります。 Restore() 関数は次の動作
  を完全に実行しなければなりません。

  1. バンク 0 が選択されていること、および新しい状態へ移行する前に必要と
     なるその他の状態情報がすべて設定済みであることを確認します。

  2. vgaHWRestore() を呼び出して状態情報の汎用 VGA 部分を回復させます。
     この関数は vgaHW.c ファイルの中で定義されています。

  3. 状態情報のチップセットに特有部分を回復します。これは単純にレジスタ
     に書き込むか、あるいはもしレジスタ中の一部のビットだけを変更する必
     要がある場合には read/modify/write 操作を実行します。クロック選択
     ビットを扱う方法について、サンプルドライバ中のコメントを確認してお
     いてください。

  6.8.  Save() 関数

  Save() 関数はサーバ起動時にビデオカードの初期状態に関する情報を取り出
  すために使用されます。Save() 関数は次の動作を完全に実行しなければなり
  ません。

  1. バンク 0 が選択されていることを確認します。

  2. vgaHWSave() を呼び出して状態情報の汎用 VGA 部分を取り出します。この
     関数は vgaHW.c ファイルの中で定義されています。

  3. 状態情報のチップセット特有部分を取り出す。

  6.9.  Init() 関数

  Init() 関数はドライバの中で (Probe() 関数に次いで) 二番目に重要な関数
  です。これを使って、サーバの中に定義された各表示モードに対するデータ構
  造を初期化します。この関数は `vgaSDCRec' データ構造全体を初期化し
  て、SVGA チップセットを目的の状態に移行させるために必要となる情報を設
  定しなければなりません。このデータ構造の汎用 VGA 部分は (これも
  vgaHW.c 内にある) vgaHWInit() を呼び出して初期化します。

  いったん汎用の部分が初期化されたら、Init() 関数は必要に応じて汎用レジ
  スタの中身を好きなように変更できます。その他必要な領域のすべてに適正な
  初期化情報を設定します。初期化される特定のモードについての情報は
  `DisplayModeRec' 構造体へのポインタである `mode' パラメタを経由して渡
  されます。このポインタを辿ることで必要なパラメータを決定できます。

  レジスタの特定ビットの初期化方法だけが分かっている場合には、ここで初期
  化しましょう。特定ビットだけを操作する場合には Restore() 関数を使って
  read/modify/write を実行するのだということをしっかり覚えておいて下さ
  い。繰り返しますが、例えばこの関数の中で何が実行されるのかについて、既
  存のドライバーコードを参照して調べておいてください。

  6.10.  Adjust() 関数

  <!_- The Adjust() function is another fairly basic function.  It is
  called whenever the server needs to adjust the start of the displayed
  part of the video memory, due to scrolling of the virtual screen or
  when changing the displayed resolution.  All it does is set the
  starting address on the chipset to match the specified coordinate.
  Follow the comments in the stub driver for details on how to implement
  it.  --> Adjust() 関数はまた別の、とても基本的な関数です。仮想スクリー
  ンのスクロールや表示解像度の変更によって、サーバがビデオメモリの表示用
  領域の開始点を調整する必要のあるときはいつも呼ばれます。この関数の担当
  は、指定された座標に合わせてチップセットの開始アドレスを設定することだ
  けです。実装方法の詳細は、スタブドライバ中のコメントを参照してくださ
  い。

  6.11.  ValidMode() 関数

  ValidMode() 関数は、このドライバーで扱うチップセットに固有の事情によっ
  て、特定のグラフィックモードを使用できない場合があるかどうかを確認する
  ために使用されるものであり、必ず用意しなければいけません。この関数は
  Probe() 実行後により上位のプログラムから呼ばれます。多くの場合、この関
  数の中で特別な調査を実行する必要は無く、常に TRUE を返すような単純なも
  のでも充分でしょう。

  6.12.  SaveScreen() 関数

  SaveScreen() 関数はほとんどのチップセットでは必要ありません。この関数
  が必要になるのは、 SVGA チップセット上で同期リセットが実行された時に、
  ドライバの動作に必要な拡張レジスタの内容も一緒に変更されてしまうような
  場合です。（このような場合、データブックに説明が記載されているはずで
  す。) この関数が必要 *無い* 場合には、単にこれを定義しないでおいて、
  vgaVideoChipRec 構造体を初期化する際には、この関数を指定するためのフィ
  ールドに `NoopDDA' を設定します。（NoopDDA は汎用の中身の無い関数で
  す）。

  この関数が *必要* な場合には、やるべきことは至極単純です。この関数は必
  ず二回 (一回目はリセット前、二回目はリセット後) 呼ばれます。前者の場合
  には引数として SS_START が渡され、後者の場合は SS_FINISH が渡されま
  す。必要な作業は、 SS_START で呼び出された際にはリセットによって影響を
  受けるレジスタの内容をすべて保存すること、またここで保存した内容を次に
  SS_FINISH で呼び出された際に回復することです。

  6.13.  GetMode() 関数

  GetMode() 関数は XFree86 1.3 では使われていません。 vgaVideoChipRec 中
  に用意されているこの関数のためのフィールドは、 `NoopDDA' を指定して初
  期化してください。

  将来的には、この関数を使用することによって、サーバーおよびサーバーのド
  ライバーライブラリを利用したスタンドアローンプログラム、またはそのどち
  らかからビデオモードを対話的に調節することが可能となる予定です。この関
  数は、 SVGA レジスタを読み込み、DisplayModeRec 構造体に現在のビデオモ
  ードを書き出します。

  [ 訳注：最新の公開版である XFree86 3.3.3.1 でも、この GetMode()関数を
  まともに実装したドライバは vga256/drivers 以下に 30種ほどあるドライバ
  のうち、わずかに ati ドライバーだけです。他に 2 種類ほど、中身の無い定
  義だけの関数を用意した例がありますが、それ以外のドライバーでは
  `NoopDDA' が指定されています。現状ではこの関数はあまり必要とされていな
  いということなのかもしれません。 ]

  6.14.  FbInit() 関数

  FbInit() 関数はアクセラレータグラフィックスをサポートするドライバが必
  ず用意しなければならない関数です。この関数は標準の cfb.banked 関数を、
  それぞれのチップに合わせたアクセラレータ対応版の関数に置き換えるために
  使用されます。 vga256LowlevFuncs は置き換え可能な関数の一覧を含む構造
  体です。この構造体は vga256.h で定義されています。 FbInit() 関数の例は
  et4000, pvga1 および cirrus のドライバにあります。

  [ 訳注： XFree86 3.3.3.1 では、 vga256/drivers 以下のドライバーの多く
  がアクセラレータ対応となっており、多くのドライバーでこの関数が定義され
  ています。例えば chips(C&T) や tvga8900(trident)、それに neo(NeoMagic)
  などのドライバーにも用意されています。 ]

  この関数が必要 *無い* 場合には、単にこれを定義しないでおいて、
  vgaVideoChipRec 構造体を初期化する際には、この関数を指定するためのフィ
  ールドに `NoopDDA' を設定します。

  7.  新サーバの生成

  ドライバーコード開発の準備作業と同じく、サーバーを生成する作業の手順は
  ソースツリー中で作業しているのか、それともリンクキットを利用しているの
  かによって異なります。次に述べるのは新しいドライバーファイルを追加した
  後で最初に生成するための手順です。

  o  ソースツリー中で作業している場合には、次の手順に従って実行します。

     xc/programs/Xserver ディレクトリに移動して、 `make Makefile' を実行
     した後、 `make Makefiles depend all' を実行します。

  o  リンクキットを利用している場合には、次の手順に従って実行します。

     1. /usr/X11R6/lib/Server ディレクトリに移動して、 `./mkmf' を実行し
        ます。

     2. 同じディレクトリ内で、 `make' を実行します。

     最初のサーバー生成を実行した後で（例えば新しく開発したドライバにさ
     らに変更を加えてから）サーバを再生成する場合には:

  o  ソースツリー中で作業している場合には、次の手順に従って実行します。

     1. 適切な drivers/ 下の ディレクトリへ移動して、（例えば
        xc/programs/Xserver/hw/xfree86/vga256/drivers） `make' を実行し
        ます。

     2. xc/programs/Xserver へ移動して、次のコマンドを実行します。 `make
        loadXF86_SVGA' (カラーサーバへのリンク), `make loadXF86_VGA16'
        (16 色サーバへのリンク) または `make loadXF86_Mono' (モノクロサ
        ーバへのリンク)。

  o  リンクキットを利用している場合には、次の手順に従って実行します。

     1. 適切なドライバのディレクトリへ移動して、 `make' を実行します。

     2. /usr/X11R6/lib/server に移動して、次のコマンドを実行します。
        `make loadXF86_SVGA' (カラーサーバへのリンク)、 `make
        loadXF86_VGA16' (16 色サーバへのリンク) または `make
        loadXF86_Mono' (モノクロサーバへのリンク)。

  8.  デバッグ

  残念ながら新しいドライバのデバッグは辛いものです。例えば SVGA チップ
  セットのプログラミング (レジスタ設定) を間違えた場合にはマシンが固まっ
  てしまうでしょう。しかし、もっと頻繁に起きる可能性があるのはディスプレ
  イの表示が消えてしまうことです。この場合、正常に戻すためには再起動させ
  る必要があるでしょう。新しく生成したサーバーを実行してテストする際に
  は、外部端末を繋ぐか、ネットワークからログインすることを *強く* お勧め
  します。これはサーバに対してデバッガを使用することを可能にする唯一の合
  理的な方法です。複数の VT を使いながらのデバッグするのは基本的に時間の
  無駄です。

  マシンが固まってしまう危険性の存在を考慮すると、サーバを起動する前に
  1、2 回 `sync' コマンドを実行しておくことは *とても* 良い考えです。さ
  らに言えば、（本来は不要なはずの fsck が実行されることを避けるために）
  デバッグ実行中はどうしても必要なファイルシステム以外、すべてアンマウン
  トしておきましょう。

  標準では、サーバはデバッグ用のシンボル抜きで生成されます。デバッグでき
  るように生成したサーバは *とても* 大きなものになります。しかしドライバ
  ーコードをデバッグのために再構築することはとても簡単です。次の手順で
  行ってください:

  1. ドライバのディレクトリへ移動してください。

  2. Makefile を編集してください。 `CDEBUGFLAGS' の *二番目* の定義を探
     して、それを次のように修正してください。

                     CDEBUGFLAGS = -g -DNO_INLINE

  (これはデバッグ用シンボルを有効にし、シングルステップ実行時の悪夢を引
  き起こす関数のインライン展開を無効にします。)

  3. `sdc_driver.o' ファイルを消してください。

  4. 上記の手順に従って、サーバを再構築してください。

     (または、Makefile を修正する代わりに、古い .o ファイルを消した後で
     単に `make CDEBUGFLAGS="-g -DNO_INLINE"' を実行するという方法もあり
     ます。この後上記の手順でサーバを再構築してください。)

  これによって、ドライバ関数にブレークポイントを設定してシングルステップ
  実行させることのできるサーバが生成されます。ソースツリー中で作業を行っ
  ていて、かつ SVGA プログラミングを学習し始めたばかりならば、vgaHW.c も
  同様にデバッグ可能にして再構築すると便利でしょう。

  9.  アドバイス

  次に述べることは、いくら強調しても足りないくらいです。

  ドライバーコードの中で何が起きているのかを理解できるようになるまでは、
  すべての利用できる参照文献と既存のドライバーコードをじっくり調べて内容
  を把握するよう努めてください。ドライバーコードを書き始める *前に* この
  調査を行なって下さい。それによって頭痛のタネをかなり減らすことができる
  でしょう。可能ならば、これから追加しようとするチップセットに似たチップ
  セットのドライバを探しましょう。またもし、そうしたドライバを見つけるこ
  とができたら、それを例題として利用しましょう。たぶん、そのコードから新
  しいドライバを派生させることができるでしょう。

  デバッグ中は暗く思い詰めてはいけません。たぶん、最初のうちはいろいろと
  問題を抱えることになるでしょう。 (私もまだまだそこから抜け出せていませ
  ん。) けれども、注意深く、慎重にデバッグの手順を進めていけば、非常に短
  い間に成果を挙げることができます。おそらく、チップセットのことを詳しく
  理解していれば、 1, 2 日でドライバーコードの作成とデバッグをやってのけ
  ることさえ可能でしょう。この種のプログラミングを学習し始めたばかりの人
  の場合には、一週間というのが、より妥当な線でしょう。

  10.  高度な話題

  新しいチップセットは二つの高度な技術領域に取り組み始めました。それはプ
  ログラマブルクロックジェネレータとアクセラレータの各種特性 (BitBlt,
  line drawing, HW カーソル) です。これらは新しい技術領域で、正式なイン
  ターフェースは未だ定義されていません。これらの新しい技術領域について作
  業したい場合は、XFree86 チームと連絡を取って開発/ベータテストチームに
  参画してください。

  [ 訳注： XFree86 3.3.3.1 では vga256/drivers 以下のドライバーコードで
  プログラマブルクロックやアクセラレータ機能を使用しているものがけっこう
  あります。アクセラレータ機能についてはソースツリーの xaa/NOTES を参照
  すると良いでしょう。 ]

  11.  参考文献

  o  Programmer's Guide to the EGA and VGA Cards, 3rd ed.
     Richard Ferraro
     Addison-Wesley, 1994
     ISBN 0-201-62490-7
     (これは SVGA プログラミングの必読書です。ちょっと誤記があるので注意
     しましょう。第 3 版ではいくつかのアクセラレータビデオカードにも言及
     しています。)

  o  vgadoc4.zip
     Finn Thoegersen
     (これは SVGA とその他のチップセットの資料を集めたものです。
     wuarchive を含むほとんどの MS-DOS/Windows 関連の FTP アーカイブから
     取り寄せ可能です。これは DOS/BIOS を対象としたものですが、その一方
     特に探査 (probe) 関数を開発する時にはとても有用な資料です。)

  12.  ベンダー連絡先情報

     ATI Technologies (VGA-Wonder, Mach8, Mach32, Mach64)
        33 Commerce Valley Drive East" Thornhill, Ontario
        Canada L3T 7N6
        (905) 882-2600 (sales)
        (905) 882-2626 (tech support)
        (905) 764-9404 (BBS)
        (905) 882-0546 (fax)

     Chips & Technologies
        ???

     Cirrus Logic (SVGA, Accelerators - CL-GD5426)
        3100 West Warren Ave.
        Fremont, CA  94538
        (510) 623-8300 (N. CA, USA)
        (49) 8152-40084 (Germany)
        (44) 0727-872424 (UK)

     Genoa Systems (GVGA)
        75 E. Trimble Road
        San Jose, CA 95131
        (408) 432-9090 (sales)
        (408) 432-8324 (tech support)

     Headland Technologies, Inc (Video-7 VGA 1024i, VRAM II)
        46221 Landing Parkway
        Fremont, CA  94538
        (415) 623-7857

     Oak Technology, Inc (OTI-067,OTI-077)
        139 Kifer Ct.
        Sunnyvale, CA 94086
        (408) 737-0888
        (408) 737-3838 (fax)

     S3 (911, 924, 801/805, 928, 864, 868, 964, 968, 764, 765)
        (408) 980-5400

     Trident Microsystems Inc (8800, 8900, 9000)
        205 Ravendale Dr
        Mountainside, CA 94043
        (415) 691-9211

     Tseng Labs Inc,
        6 Terry Drive
        Newtown, PA  18940
        (215) 968-0502

     Weitek (Power9000, 5186)
        1060 E. Arques Ave,
        Sunnyvale, CA  94086
        (408) 738-5765

     Western Digital
        (714) 932-4900

  $XFree86: xc/programs/Xserver/hw/xfree86/doc/Japanese/VGADriver.doc,v 3.1.2.3 1999/11/26 15:23:22 hohndel Exp $

  $XConsortium: VGADriv.sgml /main/9 1996/10/28 05:13:22 kaleb $

  このファイルは xc/programs/Xserver/hw/xfree86/doc/sgml/VGADriv.sgml,v
  3.13.2.1 1998/02/01 16:04:54 を、佐野 武俊 ( Taketoshi Sano
  <kgh12351@nifty.ne.jp> <mailto:kgh12351@nifty.ne.jp> ) が XFree86
  3.3.3.1 を日本でインストールする人向けに和訳したものです。ここがおかし
  いとか、ここはこうしたほうがいいといったご意見がありましたら、電子メー
  ルでお知らせ下さい。

  なお、翻訳にあたっては岡本  一幸 ( Kazuyuki Okamoto
  <ikko-@pacific.rim.or.jp> <mailto:ikko-@pacific.rim.or.jp> ) さんによ
  る XFree86 3.3.2 の和訳から大部分の文章を頂きましたことをここに記し、
  感謝を示します。原文の著作権は XFree86 プロジェクト社にあります。この
  和訳の著作権は X Japanese Documentation Project
  http://xjman.dsl.gr.jp/ <http://xjman.dsl.gr.jp/> (略称 xjman プロジェ
  クト) にあります。この和訳の不具合は私 <kgh12351@nifty.ne.jp> または
  xjman プロジェクトまで電子メールで送って下さい。

  [EOF]

