<!DOCTYPE linuxdoc PUBLIC "-//XFree86//DTD linuxdoc//EN">
 
<article>

<!-- 
<title> Information for Tseng Chipset Users
-->
<title> Tseng チップセットユーザ向けの情報
<author> The XFree86 Project, Inc.
Dirk H. Hohndel, Koen Gadeyne and others.
<date> 03 Nov 1998
<trans>The X Japanese Documentation Project
<tdate> 03 Feb 1999
<toc>

<!-- 
<sect> Supported chipsets <p>
-->
<sect> サポートしているチップセット <p>

<!--
The Tseng chipsets supported by XFree86 are ET3000, ET4000, ET4000/W32 and
ET6000. Accelerated features of the ET4000/W32, W32i, W32p and ET6000 are
supported by the SVGA driver. For details about the separate accelerated
8bpp (=256 color) ET4000/W32 and ET6000 server, refer to
<htmlurl name="README.W32" url="W32.html">.
-->
XFree86 がサポートしている Tseng チップセットは ET3000, ET4000,
ET4000/W32, ET6000 です。SVGA ドライバは ET4000/W32, W32i, W32p,
ET6000 のアクセラレーション機能もサポートしています。SVGA サーバとは別
になっている 8bpp(=256 色)の ET4000/W32, ET6000 サーバに関する詳しい情
報については、<htmlurl name="README.W32" url="W32.html"> を参照してく
ださい。

<!--
Note that you should NOT be using XF86_W32 unless XF86_SVGA doesn't work on
your hardware. No further development is being done on the W32 server; all
new efforts go into the SVGA server.
-->
お使いのハードウェアで XF86_SVGA が動作しない場合以外では、XF86_W32 を
使うべきでは<em/ない/点に注意してください。W32 サーバに関する新規開発
は行われていません。全ての労力は SVGA サーバに投入されるようになりまし
た。

<!--
Some ET4000W32 ISA cards are known NOT to work with the SVGA server in this
version (XFree86 3.3.1): they hang the machine... Use the W32 server
<tt>XF86_W32</tt> for these cards!
-->
現在のバージョン(XFree86 3.3.1)の SVGA サーバでは、ET4000W32 ISA カー
ドの一部は動作しないことが明らかになっています(マシンがハングしてしま
います…)。このようなカードの場合には W32 サーバ(<tt>XF86_W32</tt>) を
使ってください。

<!--
<sect> Terminology <p>
-->
<sect> 用語 <p>

<!--
In the rest of this document, "8bpp" is short for "8 bits per pixel", which
means a 256-color mode. Similarly, 15bpp refers to 32768 colors, 16bpp to
65536 colors , 24bpp to a "packed" 16 million color mode, and 32bpp to a
"sparse" 16 million color mode (at 32bpp, only 24 of the 32 bits are
actually used, hence the "sparse").
-->
本ドキュメントの以降の記述では、&dquot;8bpp&dquot; を
&dquot;8 bit per pixel&dquot; の略語とします。これは 256 色モードのこ
とです。同様に、15bpp は 32768色モードを、16bpp は 65536 色モードを、
24bpp は &dquot;packed 形式&dquot; の 1600万色モードを、32bpp は
&dquot;sparse 形式&dquot; の1600万色モードを示します(32bpp モードでも
実際に使われるのは 32ビット中 24 ビットです。だから
&dquot;sparse (疎な)形式&dquot; なのです)。

<!--
15bpp is only used here to differentiate it from 16bpp, but they are both
normally referred to as 16bpp. 15bpp is actually 16bpp with a 5-5-5 color
weight (wasting one bit per pixel), while 16bpp is, well, 16bpp, with 5-6-5
color weight.
-->
ここでは 16bpp と区別するためだけに 15bpp を使いますが、通常はどちらも
16bpp と言われます。15bpp は実際には 16bpp で、色の重みが 5-5-5 になっ
ています(ピクセルごとに 1 ビット分が無駄になります)。一方、16bpp は
16bpp で、色の重みが 5-6-5 となっています。

<!--
<sect> ET4000 driver features <p>
-->
<sect> ET4000 ドライバの機能 <p>

<!--
The SVGA driver for ET4000 chipsets supports all color depths (8, 15, 16, 24
and 24 bpp) on most ET4000 chips starting with the ET4000W32i. The ET4000W32
only supports 8bpp. Depending on the RAMDAC and the support code in the SVGA
server, some cards may only support a few of these color depths, or even
only 8bpp.
-->
<!-- ..., 24 and 24 ってのは ..., 24 and 32 のことっすよね? -->
ET4000 チップセット用の SVGA ドライバは、ET4000W32i 以降のほとんどの
ET4000 チップに対して全ての色の深さ(8, 15, 16, 24,32 bpp) をサポートし
ています。ET4000W32 は 8bpp しかサポートしていません。RAMDAC と SVGA
の対応コードに依存して、一部のカードでは色の深さの一部あるいは 8bpp だ
けしかサポートしていないこともあります。

<!--
On W32i and W32p chips all color depths are supported on the supported
RAMDACs (currently ICS5341, STG170x and Chrontel CH8398). These modes are
also accelerated.
-->
W32i チップと W32p チップの場合、対応している RAMDAC (現在は ICS5341,
STG170x ,Chrontel CH8398)で全ての色の深さがサポートされています。これ
らのモードではアクセラレーションも有効です。

<!--
Some W32p board implementations are limited to 1 MB of video memory in
linear memory modes. This is a hardware limitation that cannot be solved in
the driver. Since XFree86 requires linear memory for 16/24/32 bpp modes, the
usefulness of these cards for highcolor and truecolor applications is
severely limited (those modes mostly use a lot of video memory).
-->
W32p ボードの一部の実装においては、リニアメモリモードで使えるビデオメ
モリが 1MB に制限されています。これはハードウェアの制限なので、ドライ
バで解決することはできません。XFree86 では 16/24/32bpp モードを使うた
めにリニアメモリが必要なので、ハイカラーやトゥルーカラーのアプリケーショ
ンを使う場合には、このようなカードは極めて不便になってしまいます(この
ようなモードでは大抵ビデオメモリを大量に使います)。

<!--
In addition, those cards also don't support acceleration in linear mode.
This is a design choice in the driver code: if acceleration were to be
supported in linear mode, you'd only be able to use 768 kb of video memory,
and the driver code would be twice as complex.
-->
さらに、このようなカードはリニアモードではアクセラレーションをサポート
していません。これはドライバのコードを書くときの設計判断です。もしリニ
アモードでアクセラレーションをサポートすれば、ビデオメモリは 768kB し
か使えないでしょうし、ドライバのコードは倍くらい複雑になってしまうでしょ
う。

<!--
Cards with a RAMDAC that is not yet supported will be limited in a similar
manner as the older cards, i.e. to a maximum pixel clock of 86 MHz, whilst
they actually might be able to go up to 135 MHz. As a result, 1280x1024
modes will only be possible when using interlacing, and non-interlaced modes
are limited to about 1024x768 at 75 Hz refresh.
-->
まだサポートされていない RAMDAC を積んだカードは、古いカードと同じよう
な制限を受けます。つまり、実際にはピクセルクロック値を 135MHz まで上げ
られるところを最大値 86MHz に制限されます。その結果、1280x1024 モード
はインタレースモードでしか使えず、非インタレースモードではリフレッシュ
レート 75 Hz の 1024x768 程度に制限されます。

<!--
For a non-interlaced 1280x1024x(256 colors) at say 135-MHz on a W32-type
card, you need a w32p (with its 16-bit RAMDAC bus) with a multiplexing
RAMDAC so that the w32p sees only (135/2 = 67.5) MHz, not 135 MHz. This
requires special code only provided for cards using the ICS5341 GENDAC, the
STG170x or the CH8398. This code seems to work fine for most people, except,
with the ICS5341, for a small band of frequencies around 90MHz.
-->
W32 タイプのカードで非インタレースの 1280x1024x(256 色) 135MHz を使う
には、RAMDAC の多重化の機能を持つ w32p(16 ビットの RAMDAC バスを搭載)
が必要です。というのも、w32p は 135MHz ではなく (135/2 = 67.5) MHz し
か参照しないからです。これにより、ICS5341 GENDAC, STG170x, CH8398 のい
ずれかを使っているカード専用の特別なコードが必要となります。このコード
は大抵の場合うまく動作するようですが、ICS5341 を使う場合だけは例外で、
90MHz 付近の周波数で小さい縞が現われます。

<!--
Linear memory mode (especially important for some DGA clients, like
xf86quake) is supported on all ET4000W32i and ET4000W32p cards, but not on
the ET4000W32. See the section on linear memory for more information. There
are some important issues related to linear memory.
-->
リニアメモリモード(特に xf86quake 等の DGA クライアントでは重要)は、
全ての ET4000W32i, ET4000W32p カードでサポートされていますが、
ET4000W32 ではサポートされていません。詳しくはリニアメモリに関するセク
ションを参照してください。リニアメモリに関する重要事項がいくつかありま
す。

<!--
For the higher color depths (16, 24 and 32 bpp), linear memory mode is
REQUIRED. It is enabled by default in these modes. There is no need to
specify that in the <tt>XF86Config</tt> file. Please read the section on
linear memory below: it contains some vital information on how to avoid
serious problems.
-->
色の深さが大きい場合、リニアメモリモードは<em/必要/です。これらのモー
ドの場合には、リニアメモリモードはデフォルトで有効になります。
<tt>XF86Config</tt> ファイルで指定する必要はありません。後述のリニアメ
モリに関するセクションを参照してください。このセクションには、困難な問
題を回避するための重要な情報が書かれています。

<!--
To force "banked" mode in 8bpp modes (where linear memory mode is the
default), put the following in the Device section of your
<tt>XF86Config</tt>:
-->
8bpp モードで強制的に「バンク切替え」モードにするには(リニアメモリモー
ドがデフォルトです)、以下の行を <tt>XF86Config</tt> ファイルの Device
セクションに以下の行を追加してください:
<verb>
  Option "no_linear"
</verb>

<!--
Acceleration support is present, and enabled by default, for all W32 and
ET6000 family chips. This is based on the new XFree86 acceleration interface
(XAA).
-->
W32 系と ET6000 系の全てのチップにおいてアクセラレーションはサポートさ
れており、デフォルトで有効になっています。アクセラレーションのサポート
は XFree86 の新しいアクセラレーションインタフェース(XAA)に基づいていま
す。

<!--
If you have problems with acceleration, acceleration can be disabled by
putting the following in the Device section of your
<tt>XF86Config</tt>:
-->
アクセラレーションを使っていて問題が起こる場合には、以下の行を 
<tt>XF86Config</tt> ファイルの Device セクションに追加して、アクセラレー
ションを無効にすることができます:
<verb>
  Option "noaccel"
</verb>

<!--
On some PCI systems (i.e. only on the ET6000 and the ET4000W32p),
acceleration may cause occasional font corruption. This is probably caused
by a badly written system BIOS that ignores the fact that the Tseng PCI
devices have their "non-prefetchable" attribute set. On such a BIOS, a PCI
feature called "write combining" (or "byte merging") is enabled for the
Tseng video card, although it is not permitted. Some systems allow you to
manually enable or disable the Write Combining feature in the BIOS setup
(sometimes abbreviated to WC). Make sure WC is disabled for the VGA memory
aperture.
-->
PCI システムの一部(つまり、ET6000 や ET4000W32p だけ)では、アクセラレー
ションを使うとフォントが壊れてしまうことが時々起こります。この原因は多
分、Tseng PCI デバイスには「プリフェッチ不可能」属性が設定されているこ
とを無視するシステム BIOS が、おかしな書き込みを行うことです。このよう
な BIOS は、&dquot;write combining(書き込み連結)&dquot;(または
&dquot;byte merging&dquot;) と呼ばれる PCI の機能を Tseng ビデオカード
に対して有効にしますが、カードはこれを認めません。一部のシステムでは、
BIOS 設定において手動で Write Combining 機能(WC と省略されることもあり
ます)の有効・無効を切替えることができます。VGA メモリアパーチャに対し
て WC が無効になっていることを確認してください。

<!--
If you experience font corruption on your system and are unable to manually
disable WC in your BIOS, font acceleration may be disabled using the following
in the Device section of your
<tt>XF86Config</tt>:
-->
システム上でフォントが壊れるけれど BIOS では手動で WC を無効にすること
ができない場合、<tt>XF86Config</tt> ファイルの Device セクションに以下
の行を追加してフォントのアクセラレーションを無効にすることができます:
<verb>
  Option "xaa_no_color_exp"
</verb>

<!--
Note that this will reduce the performance of the X server.
-->
この設定を行うと X サーバの性能が落ちる点に注意してください。

<!--
<sect> ET6000 driver features <p>
-->
<sect> ET6000 ドライバの機能 <p>
<!--
In addition to the features in the ET4000 driver, the SVGA ET6000 server
supports all possible color depths in the SVGA server: 8bpp, 16bpp (both at
5-5-5 and 5-6-5 color resolutions), 24bpp and 32 bpp.
-->
ET4000 ドライバの機能に加え、SVGA ET6000 サーバは SVGA サーバで利用可
能な全ての色の深さをサポートしています: 8bpp, 16bpp(色解像度は 5-5-5
と 5-6-5 の両方), 24bpp, 32bpp.

<!--
Linear memory mode (as opposed to the VGA default, banked memory layout) is
supported. It is required and enabled by default for the 16/24/32 bpp modes.
For 8bpp, the default is linear mode for PCI cards and banked mode for
ISA/VLB cards.
-->
リニアメモリモード(VGA のデフォルトと逆で、バンク切替えレイアウトです)
がサポートされています。リニアメモリモードは 16/24/32bpp モードの場合
には必要であり、デフォルトで有効になります。8bpp の場合は、PCI カード
ではリニアモードがデフォルトで、ISA/VLB カードではバンク切替えモードが
デフォルトです。

<!--
To force linear memory at 8bpp, put the following in the SVGA section of your
<tt>XF86Config</tt>:
-->
8bpp で強制的にリニアメモリモードにするには、<tt>XF86Config</tt> ファ
イルの SVGA セクションに以下の行を追加します:
<verb>
  Option "linear"
</verb>

<!--
Acceleration is supported and is enabled by default, and accelerates all
color depths on the ET6000. Acceleration can be disabled by adding the
following in the Device section of your
<tt>XF86Config</tt>:
-->
アクセラレーションがサポートされており、デフォルトで有効になっています。
ET6000 では全ての色の深さでアクセラレーションが有効です。
<tt>XF86Config</tt> のデバイスセクションに以下の行を追加することで、ア
クセラレーションを無効にすることができます:
<verb>
  Option "noaccel"
</verb>

<!--
The hardware cursor is supported in all color depths. Due to a hardware
limitation in the ET6000, only a limited set of colors is supported (2
significant bits per color component). This may cause some (small) cursor
color errors. If absolute cursor color accuracy is required, the hardware
cursor should not be enabled. However, in most applications, this will not
be a problem. The hardware cursor can be enabled using
-->
全ての色の深さにおいて、ハードウェアカーソルがサポートされています。
ET6000 のハードウェアの制限により、使える色の集合だけは制限されていま
す(色の要素ごとに上位 2 ビット)。その結果、カーソルの色が(少し)おかし
くなることがあります。カーソルの色が絶対に正確であることが必要な場合に
は、ハードウェアカーソルを有効にしてはなりません。しかし、大抵のアプリ
ケーションでは色の狂いは問題にならないでしょう。ハードウェアカーソルを
有効にするには以下の指定を行います:
<verb>
  Option "hw_cursor"
</verb>

<!--
There is a problem with the hardware cursor at high dotclocks (above
approx. 110MHz) at which point the cursor does strange things when partly off
the left-hand side of the screen.
-->
ドットクロック値が高い(100MHz 辺りを越える値)ときにハードウェアカーソ
ルを使うと問題が起こります。この問題は、画面の左半面から一部が出た時に
カーソルが指す場所がおかしくなるというものです。

<!--
On older ET6000 chip revisions, DoubleScan modes currently don't work with
the hardware cursor: only the top half of the cursor is visible. If you want
to use DoubleScan modes (320x200 is a popular one), then do not enable the
hardware cursor. Most recent ET6000 cards and the ET6100 do not exhibit this
problem.
-->
ET6000 チップの古いリビジョンでは今のところ、ダブルスキャンモードでは
ハードウェアカーソルが使えません。具体的には、カーソルの上半分しか表示
されない状態になります。ダブルスキャンモード(320x200 がよく使われます)
を使いたければ、ハードウェアカーソルを有効にしてはいけません。最近の
ET6000 カードと ET6100 カードでは、この問題は現われません。

<!--
On some PCI systems, acceleration may cause occasional font corruption. As
described above, this is caused by a bug in your system BIOS or a wrong
setting of the write combining feature in that BIOS. If you are unable to
fix the BIOS or force the option off, font acceleration may be disabled
using the following in the Device section of your
<tt>XF86Config</tt>:
-->
一部の PCI システムでは、アクセラレーションを使うとフォントが壊れるこ
とが時々起こります。先に説明したように、この原因はシステムの BIOS のバ
グか、あるいは BIOS における write combining 機能の設定ミスです。BIOS
を修正したり、オプションを強制的に無効にできない場合には、
<tt>XF86Config</tt> ファイルの Device セクションに以下の行を追加するこ
とにより、フォントのアクセラレーションを無効にすることができます:
<verb>
  Option "xaa_no_color_exp"
</verb>

<!--
When using accelerated high color-depths (24bpp and 32bpp), high-resolution
modes (starting somewhere around 800x600) may cause temporary "garbage"
lines to the right of the screen while the accelerator is busy. The garbage
should not be persistent: it should go away as soon as the server is left
alone. This is a memory bandwidth problem, and thus cannot be resolved
(except by not allowing such modes at all, which is what is done in the
current driver).
-->
色の深さが大きいとき(24bpp, 32bpp)にアクセラレーションを用いると、高解
像度モード(800x600 辺りより大きい解像度)で問題が起こります。これは、ア
クセラレータの動作時に画面の右に一時的に「ゴミ」の線が現われるというも
のです。ゴミはずっと残るわけではないはずです。これはサーバが解放されれ
ばすぐに消えるはずです。この問題はメモリのバンド幅によるもので、回避す
ることはできません(このようなモードを全く使わないという回避方法だけが
あり、現在のドライバではこれを行っています)。

<!--
Ignoring it is one option (it isn't destructive). Disabling acceleration in
the Device section of the <tt>XF86Config</tt> file is another option: since
the accelerator is not being used, there is ample bandwidth to avoid such
problems.
-->
この問題を無視するというのも一つの手です(破壊的な問題ではありませんか
ら)。<tt>XF86Config</tt> ファイルの Device セクションでアクセラレーショ
ンを無効にするという方法もあります。アクセラレータが使われないので、こ
のような問題を起こさないだけの広いバンド幅が確保できます。

<!--
<sect> Clock selection problems with some ET4000 boards <p>
-->
<sect> 一部の ET4000 ボードにおけるクロック値選択の問題 <p>
<!--
XFree86 has some problems getting the clock selection right with some
ET4000 boards when the server is started from a high-resolution text mode.
The clock selection is always correct when the server is started from a
standard 80x25 text mode.
-->
XFree86 では、高解像度のテキストモードからサーバを起動すると、ET4000
ボードの一部についてクロック値の選択を行うことができません。標準の
80x25 のテキストモードからサーバを起動すると、クロック値の選択は必ず正
しく行えます。

<!--
This problem is indicated when the reported clocks are different when the
server is started from the high-resolution text mode from what they are
when it is started from the 80x25 text mode.  To allow the server to work
correctly from the high-resolution text mode, there are some Option flags
that may be set in <tt>XF86Config</tt>.
To find out which flags to set, start the
server with the -probeonly flag from an 80x25 text mode and look at the
information printed by the server.  If the line:
-->
サーバを高解像度のテキストモードから起動したときと、80x25 のテキストモー
ドから起動したときで通知されるクロック値が異なる場合、この問題が起こる
可能性があります。高解像度のテキストモードからでもサーバを正しく動作さ
せるために、<tt>XF86Config</tt> で指定できるオプションがいくつか用意さ
れています。セットするフラグを見つけるために、まずは 80x25 のテキスト
モードから -probeonly フラグを付けてサーバを起動し、サーバが出力する情
報を見ましょう。
<verb>
  VGAXXX: ET4000: Initial hibit state: low
</verb>
<!--
is printed, put the following in the SVGA, VGA16 and VGA2 sections of your
<tt>XF86Config</tt>:
-->
という行が出力された場合、<tt>XF86Config</tt> ファイルの SGVA, VGA16,
VGA32 セクションに次の行を追加します:
<verb>
  Option "hibit_low"
</verb>
<!--
If the line:
-->
<verb>
  VGAXXX: ET4000: Initial hibit state: high
</verb>
<!--
is printed, put the following in the SVGA, VGA16 and VGA2 sections of your
<tt>XF86Config</tt>:
-->
という行が出力された場合には、<tt>XF86Config</tt> ファイルの SGVA,
VGA16, VGA32 セクションに次の行を追加します:
<verb>
  Option "hibit_high"
</verb>

<!--
<sect> Text mode restore problems <p>
-->
<sect> テキストモードの復元に関する問題 <p>
<!--
In XFree86 1.3, an option flag ``force_bits'' was provided as an experiment
to attempt to alleviate text-restoration problems that some people experienced.
We have now made the behavior of this option the default, hence the flag
has been removed.  Hopefully the past text-restoration problems are alleviated 
in XFree86 2.0.
-->
XFree86 1.3 では、一部で起こっていたテキスト復元の問題を軽減しようとし
て、オプション ``force_bits'' が用意されていました。現在はこのオプショ
ンの動作がデフォルトになっているので、このオプションそのものはなくなり
ました。以前のテキスト復元の問題は、XFree86 2.0 では軽減されていること
と思います。

<!--
<sect> Basic configuration <p>
-->
<sect> 基本設定 <p>

<!--
It is recommended that you generate an XF86Config file using
the <tt>XF86Setup</tt>' or <tt>xf86config</tt>' program, which should
produce a working
high-resolution 8bpp configuration. You may want to include mode
timings in the <tt>Monitor</tt> section that better fit your monitor
(e.g 1152x864 modes). The driver options are described in detail in
the next section; here the basic options are hinted at.
-->
XF86Config の作成には、<tt>XF86Setup</tt> プログラムまたは
<tt>xf86config</tt> プログラムを使うことをお勧めします。これらのプログ
ラムは、高解像度の 8bpp の設定できちんと動作する XF86Config ファイルを
作ってくれるはずです。よりモニタに適したモード(例: 1152x864 モード)の
タイミング値を <tt>Monitor</tt> セクションに追加してもよいでしょう。ド
ライバのオプションの詳細については、次のセクションで説明します。ここで
は基本的なオプションを簡単に説明します。

<!--
If graphics redrawing goes wrong on accelerated chips (ET4000W32 and
ET6000), first try the <tt>"noaccel"</tt> option, which disables
all accelerated functions.
-->
アクセラレーションが使えるチップ(ET4000W32 と ET6000)でグラフィックス
の再描画がおかしくなる場合には、まず <tt>"noaccel"</tt> を試してみてく
ださい。このオプションはアクセラレーション機能を全て無効にします。

<!--
<sect> general options in the <tt>XF86Config</tt> file <p>
-->
<sect> <tt>XF86Config</tt> ファイルの全体に関するオプション <p>

<!--
The following options are of particular interest to the Tseng driver. Each
of them must be specified in the <tt>svga</tt>' driver section of the
<tt>XF86Config</tt>
file, within the <tt>Screen</tt> subsections of the depths to which they are
applicable (you can enable options for all depths by specifying them in the
Device section).
-->
以下のオプションは Tseng ドライバのためのものです。各オプションは、
<tt>XF86Config</tt> ファイル内の <tt>svga</tt> ドライバのセクションに
ある、オプションが適用できる色の深さの <tt>Screen</tt> サブセクション
で指定しなければなりません(Device セクションで指定すれば、全ての色の深
さにおいてオプションを有効にすることができます)。
<descrip>
<!--
<tag>Option "noaccel"</tag>   (ET4000W32p, et6000)
        This option will disable the use of any accelerated functions. This
        is likely to help with some problems related to DRAM timing, high
        dot clocks, and bugs in accelerated functions, at the cost of
        performance (which will still be reasonable on a local or PCI bus).
        This option applies only to those chips where acceleration is
        supported.
-->
<tag>Option &dquot;noaccel&dquot;</tag>   (ET4000W32p, et6000)
このオプションはアクセラレーション機能を無効にします。これにより、DRAM
のタイミングや高いドットクロック値、アクセラレーション機能のバグに関連
する問題が解決することが多いのですが、性能が犠牲になってしまいます(ロー
カルバスや PCI バスではそれでも十分でしょう)。このオプションはアクセラ
レーションがサポートされているチップに対してのみ有効です。
<!--
<tag>Option "fast_dram" "slow_dram" </tag>
        These options set the DRAM speed of certain cards where it applies. 
-->
<tag>Option &dquot;fast_dram&dquot; &dquot;slow_dram&dquot; </tag>
このオプションは、特定のカードの DRAM のスピードを設定します。カードは
DRAM のスピードの設定ができるものでなければなりません。

<!--
        The <tt>"slow_dram"</tt> option is always enabled on ET4000, and
        ET4000W32. If enabled, it slows down DRAM timing, which may avoid
        some memory-related problems. If your card starts up with a black
        screen (and possibly a system hang), this option might be needed.
-->
<tt>"slow_dram"</tt> オプションは ET4000 と ET4000W32 では常に有効にさ
        れます。有効になっている場合、DRAM のタイミングは遅くなり、メ
        モリ関連の問題をいくらか避けることができます。起動時に画面が真っ
        暗になる(システムがハングすることもあります)カードでは、このオ
        プションが必要かもしれません。
<!--
        The <tt>"fast_dram"</tt> option will cause the driver to speed up
        DRAM timings, which may also avoid screen-related problems
        (streaking, stripes, garbage, ...). It may also increase those very
        same effects.
-->
<tt>"fast_dram"</tt> オプションは、ドライバに DRAM のタイミングを速く
        させます。これによっても画面関係の問題(筋、縞、ゴミ等)が直るこ
        とがあります。これらの問題をひどくすることもあります。
<!--        
        All in all, these are potentially dangerous options: they could
        crash your machine as soon as you start the server. Use them with
        caution.
-->
一般的に、これらのオプションは危険です。サーバを起動した途端にマシンを
        クラッシュさせることもあります。注意して使ってください。
<tag>
<!--
option "w32_interleave_off" "w32_interleave_on"   (W32i, W32p)
-->
option &dquot;w32_interleave_off&dquot; &dquot;w32_interleave_on&dquot;   (W32i, W32p)
</tag>
<!--
	Force memory interleaving off or on. W32i and W32p chips can
	increase memory bandwidth when they have 2MB or more video memory.
	Normally the VGA BIOS sets the W32i or W32p chip to the correct
	mode. If you suspect problems with memory sizing or interleaving,
	fooling around with these options may improve the situation. It may
	also make things worse. These options are not normally needed: the
	server will use the correct value automatically. Setting this option
	the wrong way will result in a completely distorted display.
-->
メモリインタリーブのオン/オフを指定します。W32i と W32p チップでは、
ビデオメモリが 2MB 以上ある場合にメモリのバンド幅が広くなります。通常、
VGA BIOS は W32i と W32p を正しいモードに設定します。メモリのサイズ決
定やインタリーブに関する問題の疑いがあれば、このオプションの周りをいじっ
てみると状況が改善するかもしれません。悪化することもあるかもしれません
が。これらのオプションは通常は必要ないものです。というのも、サーバが正
しい値を自動的に使うからです。このオプションにおかしな設定をすると、表
示が全く変になってしまうでしょう。
<tag>
<!--
option "pci_burst_off" "pci_burst_on"   (W32p)
-->
option &dquot;pci_burst_off&dquot; &dquot;pci_burst_on&dquot;   (W32p)
</tag>
<!--
	This option disables or enables PCI bursts on the W32p chip if it's
	a PCI card. Normally, a good BIOS will set the motherboard and the
	VGA card to the same setting, but if both don't match, you may
	experience garbage on the screen (e.g. mouse droppings). These
	options allow you to match the W32p burst setting to the motherboard
	setting.
-->
PCI カードを使っている場合、このオプションは W32p チップの PCI バース
ト転送の有効/無効を切替えます。通常は、まともな BIOS ならマザーボード
と VGA カードの設定を合わせるのですが、両者が一致していない場合には画
面にゴミが出るでしょう(マウスの通った跡など)。これらのオプションを使う
と、W32p のバースト転送の設定をマザーボードの設定と合わせることができ
ます。
<tag>
<!--
videoram 1024 (or another value)   (all chips)
-->
videoram 1024 (または別の値)   (全てのチップ)
</tag>
<!--
        This option will override the detected amount of video memory, and
        pretend the given amount of memory is present on the card. This is
        useful on cards with 2Mbyte of memory whose DRAM configuration is
        not compatible with the way the driver enables the upper megabyte of
        memory, or if the memory detection goes wrong. It must be specified
        in the Device section.
-->
このオプションは検出されたビデオメモリの量を上書きし、指定された量のメ
モリがカードに載っているかのように動作させます。このオプションは、カー
ドにメモリが 2MB 載っているけれど DRAM の構成がドライバがメモリの上位
1MB の部分を有効にする方法と互換でない場合や、メモリの検出がうまく行か
ない場合に役に立ちます。このオプションは Device セクションで指定しなけ
ればなりません。
<tag>
<!--
Clockchip "et6000"  (et6000)
-->
Clockchip &dquot;et6000&dquot;  (et6000)
</tag>
<!--
        This enables programmable clocks, but obviously only on the et6000.
        It must be specified in the Device section. Normally the server will
        automatically use this feature when it detects an ET6000. Use it
        only when you suspect auto-detection is not working. Note that some
        frequencies may be unstable (resulting in a `Wavy' screen). Only
        tried and tested frequencies (like the default clocks) are
        guaranteed to be stable. If this happens, try a slightly different
        frequency in the modeline (like 0.5 MHz more or less). The monitor
        should still be capable of syncing to this frequency, but the
        clockchip may already be outside an unstable region.
-->
このオプションはプログラマブルクロックを有効にしますが、明らかに
ET6000 でしか使えません。このオプションは Device セクションで指定しな
ければなりません。サーバは ET6000 を検出すると通常、プログラマブルクロッ
クを自動的に使います。このオプションを使うのは、自動検出がうまく動作し
ていない疑いがあるときだけにしましょう。周波数によっては不安定になるこ
とがある(画面が「波打って」しまいます)点に注意してください。安定だと保
証できるのは、(デフォルトのクロック値のように)試してみた周波数だけです。
画面が乱れた場合には、少しだけ異なる値(0.5MHz ずれている値など)を試し
てください。モニタはこの周波数に同期できるはずですが、クロックチップが
これで不安定な領域の外に出てくれるかもしれません。
<tag>
<!--
Option "linear"  (ET4000W32i, ET4000W32p, ET6000)
-->
Option &dquot;linear&dquot;  (ET4000W32i, ET4000W32p, ET6000)
</tag>
<!--
        This enables linear addressing, which is the mapping of the entire
        framebuffer to a high address beyond system memory, making the full
        length of the framebuffer directly accessible. In this way, slow
        SVGA bank switching (where only a small fraction of the framebuffer
        is visible at one time) is not necessary. It enhances performance at
        256 colors, and is currently required for 16bpp, 24bpp, and 32bpp.
-->
このオプションはリニアアドレッシングを有効にします。これにより、フレー
ムバッファ全体がシステムメモリより上位のアドレスにマップされ、フレーム
バッファ全体に直接アクセスできるようになります。この方法を使うと、遅い
SVGA のバンク切替えが不要になります(バンク切替えでは、同時にフレームバッ
ファの一部しか参照できません)。リニアアドレッシングは 256 色時には性能
が向上しますし、現在のところ 16bpp, 24bpp, 32bpp では必ず使わなければ
なりません。
<tag>
<!--
MemBase 0xE0000000. (or a different address) (ET4000W32, ET6000)
-->
MemBase 0xE0000000 (あるいは別のアドレス) (ET4000W32, ET6000)
</tag>
<!--
        This sets the physical memory base address of the linear
        framebuffer. It must be specified in the Device section. It may be
        required for non-PCI linear addressing configurations, and might be
        useful for PCI-based systems where auto-detection fails. However,
        almost all PCI systems will not need this.
-->
このオプションはリニアフレームバッファの物理メモリのベースアドレスを設
定します。このオプションは Device セクションで指定しなければなりません。
このオプションは PCI でない場合のリニアアドレッシングの設定ではたぶん
必要ですし、PCI ベースのシステムでも自動検出に失敗する時に役に立つかも
しれません。しかし、ほとんど全ての PCI システムではこのオプションは不
要です。
<!--        
        Read the section on linear memory base address issues below!
-->
後述のリニアメモリベースアドレスに関する事項を読んでください!

<!--        
        Read the section on linear memory base address issues below!
        (Message repeated for a very good reason)
-->
後述のリニアメモリベースアドレスに関する事項を読んでください!
(ちゃんとした理由があってメッセージを繰り返しています。)

<!--        
        Use this option ONLY if you have trouble with the default MemBase
        used by the server, or if the server explicitly states that you must
        provide one.
-->
このオプションを使うのは、サーバが使うデフォルトの MemBase 値で問題が
起こる場合か、サーバがアドレスの指定を明示的に求めた場合だけにしてくだ
さい。
<tag>
<!--
Option "pci_retry" (ET4000W32p on PCI bus, ET6000)
-->
Option &dquot;pci_retry&dquot; (ET4000W32p(PCI バス用), ET6000)
</tag>
<!--
        This enables the PCI bus retry function, which is a performance
        enhancing mode for local bus or PCI bus-based systems, where the VGA
        controller will put the bus in a hold state (sort of like
        wait-states) when the server tries to start a new accelerated
        operation but the accelerator is still busy with the previous
        operation.
-->
このオプションは PCI バスのリトライ機能を有効にします。この機能は、ロー
カルバスや PCI バスベースのシステムにおける性能向上モードです。サーバ
が新しいアクセラレーション付き操作を開始しようとしているけれど、アクセ
ラレータがまだ前の操作のためにビジー状態になっている時に、VGA コントロー
ラはバスをホールド状態(待ち状態のようなものです)にします。

<!--        
        This is the fastest way to drive a VGA card (no busy-waiting loops
        needed), but it also stresses some hardware that is timing-dependent
        (tape drives, sound cards, etc). See also the trouble shooting
        section.
-->
これは VGA カードを動かすための最速の方法(ビジー待ちループが不要)です
が、タイミング依存のデバイス(テープドライブ、サウンドカード等)に負担を
かけてしまいます。トラブルシューティングのセクションも参照してください。
</descrip>

<!--
<sect> linear memory base address (MemBase) issues <p>
-->
<sect> リニアメモリのベースアドレス(MemBase)に関する事項 <p>

<!--
First a WARNING: defining a bad MemBase may cause serious injury or death
(to your operating system, of course). Especially defining the MemBase to be
inside the range of system memory is a ticket to hell.
-->
最初に警告です: MemBase 値に誤った値を定義すると、(もちろんオペレーティ
ングシステムに)重大な被害を与えたり、殺したりします。特に、MemBase 値
にシステムメモリの範囲内の値を定義するのは、地獄への片道切符を渡すのと
同じことです。

<!--
<sect1>What you should know BEFORE trying another MemBase<p>
-->
<sect1>MemBase 値を変えようとする「前に」知っておくべきこと<p>

<!--
Rule &num;1: first, let the server find a memory base by itself, without
specifying it. Make sure you "sync" all files to disk and close all critical
applications. Make sure nothing bad will happen to your filesystems if you
have to jump for the power switch soon.
-->
規則 &num;1: まずは、指定するのではなく、サーバ自身にメモリベース値を
見つけさせましょう。必ず全てのファイルをディスクに "sync" し、重要なア
プリケーションも全て終了させてください。電源スイッチを即座に切る羽目に
なっても、絶対ファイルシステムに悪影響が出ないようにしておきましょう。

<!--
The most critical cards are the ET4000W32p rev a and rev b on VESA local bus
(VLB). The server will autodetect a linear base address that doesn't work on
all systems.
-->
最も危険なカードは VESA ローカルバス(VLB)用の ET4000W32p のリビジョン 
a と b です。このサーバはリニアベースアドレスを自動検出しますが、この
値は全てのシステムでうまく使えるわけではありません。

<!--
The least critical cards are PCI-bus cards. The PCI BIOS normally takes care
of assigning a good MemBase, and you should never have to deal with all the
mumbo-jumbo below.
-->
ほとんど危険のないカードは PCI バス用のカードです。PCI BIOS は通常正し
い MemBase 値を割り当ててくれるので、以下に述べるようなごちゃごちゃし
たことは全く行う必要がありません。

<!--
If the server gets it wrong, you may end up with a severe system crash (e.g.
if it maps the video memory right on top of your system memory). If this
happens, RESET IMMEDIATELY. Do not try to shut down cleanly, because the
X-server, thinking it writes to the VGA memory, will write to system memory
instead, and you'll be writing corrupted data to disk. If you did a sync
prior to starting the server, there will be no harm done (only a filesystem
check which should end up clean). DO NOT attempt to redirect the server
output to a file on the system you're testing on (that will write data after
you synced).
-->
サーバが間違った MemBase 値を取得した場合、システムがひどくクラッシュ
してしまうかもしれません(例: ビデオメモリがシステムメモリとちょうど重
なってしまった場合)。この場合、<em/即座にリセットしてください/。正常に
シャットダウンしようとしてはいけません。というのも、X サーバが VGA メ
モリへの書き込みを行っていると思いながら、実はシステムメモリへの書き込
みを行ってしまうのです。つまり、壊れたデータがディスクに書き込まれてし
まいます。サーバを起動する前に sync を実行していれば、被害は全く出ない
(正常終了しなければならないファイルシステムのチェックだけ)でしょう。
サーバの出力をテストを行っているシステムのファイルにリダイレクトしては
<em/いけません/(sync の後にデータを書き込むことになってしまいます)。

<!--
These are worst-case scenarios, and it is very unlikely this will happen to
you. The text above is to make sure you are properly prepared, so that
nothing serious happens.
-->
これは最悪のケースのシナリオなので、こうなってしまうことは滅多にないで
しょう。上記の説明は、読者の皆さんに適切な準備を必ずしてもらい、被害を
出さないようにするためのものです。

<!--
When the server can't find a working linear memory base, it's time to
experiment. The rest of this section deals with that.
-->
サーバが使えるリニアメモリベース値を見つけられない時には、実験を行うし
かありません。これについて、このセクションの残りの部分で説明します。

<!--
<sect1>Choosing a MemBase<p>
-->
<sect1>MemBase 値の選択<p>
<!--
Choosing a suitable MemBase can be quite tricky. If you have no way of
determining the MemBase your card uses, trying to put it a few Mb above the
system memory is a good first guess. E.g. if you have 16 Mb of RAM, defining
MemBase 0x01000000 (=16M) or 0x01400000 (=20M) may work.
-->
適切な MemBase を見つける作業は実にトリッキーです。カードが使っている 
MemBase 値を決める方法がない場合、システムメモリの数 MB 上の位置を試す
のが最初の推定として良いものでしょう。例えば、メモリを 16MB 積んでいる
システムの場合、MemBase 値に 0x01000000 (=16M) や 0x01400000 (=20M) を
定義するとうまく動作するかもしれません。

<!--
However, this may only work on non-PCI systems, as PCI systems mostly map all
hardware above the 2GB mark. But then again, on PCI systems the server is
almost always able to detect the correct linear memory base address. The
only exception are those systems with more than one PCI VGA card.
-->
しかし、これは PCI でないシステムでしか動作しないと思います。というの
も、PCI システムは大抵、2GB の点も越えて全てのハードウエアをマップする
からです。しかし、繰り返しになりますが、PCI のシステムではサーバは正し
いリニアベースアドレスをほぼ確実に検出することができます。唯一の例外は
複数の PCI 用 VGA カードが付いているシステムの場合です。

<!--
On most VESA local bus (VLB) boards, there is an additional problem with
address decoding. Most motherboards only decode the first 32, 64 or 128 MB
of address space (a good pointer is to check the amount of DRAM that can be
installed on the board: it will at least decode as much address space as it
supports DRAM).
-->
VESA ローカルバス(VLB)ボードの大部分では、アドレスのデコードに関する問
題が別にあります。ほとんどのマザーボードはアドレス空間の最初の 32, 64, 
128 MB しか展開しません(これを確認する良い方法は、ボードに装着できる 
DRAM の最大量を調べることです。DRAM をサポートしている分のアドレス空間
だけは少なくとも展開できるでしょう)。

<!--
On such boards, you MUST specify a MemBase inside that range, or the actual
address may wrap back onto system memory: if your system only decodes 128MB
of addresses, and you set the MemBase to 128 MB, it will actually be decoded
as being on address 0, which is probably exactly where your kernel memory is
located. That is why the general guideline of putting the MemBase just above
the system memory is a sound one: it stands most chance of actually being
inside the decoded address range of the board. Unless your motherboard's
entire memory space is filled with RAM.
-->
このようなボードの場合は、この範囲に収まる MemBase 値か、あるいはシス
テムメモリに回り込んで戻ってくるような実アドレスを指定
<em/しなければなりません/。後者の場合に、128MB のアドレスしかデコード
しないシステムに対して MemBase を 128MB に設定すると、実際にはアドレス 
0 としてデコードされます。この値はおそらく、ちょうどカーネルメモリが配
置されている場所でしょう。これが、MemBase をシステムメモリのすぐ上に配
置するという一般的なガイドラインが最初に挙げられる理由です。
<!-- a sound one のところが怪しい… -->
こうしておくと、デコードされたボードのアドレス範囲の内部に実際に入って
いる見込みが十分あります。ただし、これはマザーボードのメモリ空間全体が 
RAM で占められていない場合のことです。

<!--
<sect1>An alternative approach<p>
-->
<sect1>別のアプローチ<p>
<!--
If you don't know how much memory address space your motherboard decodes
(and who does?), try using a "non-trivial" address, like 0x1FC00000, which
has enough bits set to "1" to work on any motherboard, even if a few are not
decoded. Keep in mind that using for example 0x10000000 may end up right on
top of your system memory if the motherboard doesn't decode all upper
address bits. You will only do that once.
-->
マザーボードがデコードするメモリアドレス空間空間の大きさがわからない場
合、0x1FC00000 のような「自明でない」アドレスを試してみましょう。
<!-- you を訳出しなかったら、(and who does?) も出せない気がする… -->
このアドレスには"1" にセットされたビットがあり、たとえ一部がデコードさ
れなくても全てのマザーボードでも動作します。0x10000000 等を使うと、マ
ザーボードがアドレスの上位ビットをデコードしない場合には、システムメモ
リとアドレスがちょうど重なってしまうことがある点を覚えておいてください。
これを行うのは一度だけでしょう。

<!--
<sect1>When all else fails...<p>
-->
<sect1>他の試みが全て失敗したら…<p>
<!--
Some other VLB boards can only map the linear framebuffer above the 1GB mark
(0x80000000 and up), so you must use a MemBase that is higher or equal to
0x80000000.
-->
一部の VLB ボードは 1GB を越える領域(0x80000000 以上)にしかリニアフレー
ムバッファをマップできません。したがって、0x80000000 以上の MemBase 値
を使わなければなりません。

<!--
Some other VLB boards can only map the linear framebuffer BELOW the 16 MB
mark. So you may want to try booting your system with up to 12 MB of memory
(some operating systems allow you to supply a boot-time parameter that
limits the memory to a certain amount, so you don't have to open your
computer to try this), and set the MemBase to 0x00C00000 (=12M).
-->
この他にも、16MB <em/以下/の領域にしかリニアフレームバッファをマップで
きない VLB ボードがあります。ですから、メモリを 12MB 以下にしてシステ
ムを起動して、MemBase 値を 0x00C00000 (=12M) に指定してみるのもよいで
しょう。
(一部のオペレーティングシステムでは、起動時にパラメータを指定してメモ
リの大きさを制限することができます。このようなオペレーティングシステム
では、メモリの大きさを変えてみるためにコンピュータを分解する必要はあり
ません。)

<!--
Unfortunately, there is no easy way to tell what system you have (these
details are mostly not in the motherboard manuals). Trial and error is the
only road to success here. The server code will provide a default that works
on most boards... but yours won't be one of those, of course.
-->
残念ながら、使っているシステムにアドレスを教えてやるための簡単な方法は
存在しません(大抵の場合、詳しいことはマザーボードのマニュアルに書かれ
ていません)。成功するためには試行錯誤しかないのです。サーバのコードで
は大部分のボードでうまく動作するデフォルト値を用意しているのですが、こ
こを読んでいるからには当然、読者の皆さんがお使いのボードはこれに該当し
ていないのでしょう…。

<!--
<sect1>Restrictions<p>
-->
<sect1>制限<p>
<!--
There are some limits as to where the linear memory base may be put. On any
ET4000W32, it must have a 4MB granularity (i.e. it can be put at 16M or at
20M, but not at 18M). On ET6000, it needs a 16M granularity (note: the
ET6000 driver should be able to determine the linear memory base
automatically, so you should never need to define MemBase in the first
place).
-->
リニアメモリのベース値を配置する場所については、制限がいくつかあります。
ET4000W32 系の全てのボードでは、4MB 単位で指定しなければなりません(つ
まり 16MB, 20MB に配置できますが、18M には配置できません)。
<!-- 「粒度」とか言うのもアレな気がする… -->
ET6000 の場合には、16MB 単位で指定する必要があります(ET6000 ドライバは
自動的にリニアメモリのベース値を決められるはずですので、そもそも 
MemBase 値を指定する必要はないはずです)。

<!--
On ET4000W32i, things are worse: the linear address base is hardwired on the
card, and there is no reliable way to read it back from the card. You need
to know the address in some way, and specify it. The current code does an
intelligent guess at it, but this is no guarantee.
-->
ET4000W32i の場合は面倒です。リニアアドレスのベース値はカードがハード
ウェア的に持っているので、これをカードから読み戻す確実は方法がありませ
ん。そこで、何らかの方法でこのアドレスを調べ、指定してやる必要がありま
す。現在のコードでは賢い方法で推定しているのですが、保証はできません。

<!--
On ISA cards, things are much more simple: ISA only uses 24 address lines,
and hence the linear memory MUST lie within the 16 MB boundary. Together
with the 4MB granularity of the linear memory base address on ET4000 cards,
this means that you cannot have more than 12 MB of system memory in the
machine if you want to use linear memory. Hence, the only realistic MemBase
for ISA cards is 0x00C00000. This is also what the server will automatically
choose if it detects an ISA W32 card.
-->
ISA カードならば話はずっと簡単です。ISA では 24 個のアドレス線しか使わ
ないので、リニアメモリは 16MB の範囲に収まらなければ「なりません」。
ET4000 カードでは 4MB 単位でリニアメモリを指定しなければならないことも
考慮に入れると、リニアメモリを使いたい場合には、マシンのシステムメモリを 
12MB より多くしてはならないということになります。したがって、ISA カー
ドの場合に現実的に使える MemBase 値は 0x00C00000 だけです。この値は 
ISA の W32 カードをサーバが検出した場合に、サーバが自動的に選択する値
でもあります。

<!--
WARNING: you must not have over 12 MB of system memory in this case. Or if
you have it, you must disable access to all memory above the 12 MB mark.
Some operating systems allow you to specify at startup how much memory it is
allowed to use, so you don't have to unplug some memory each time you want
to use linear memory.
-->
警告: コンピュータに 12MB を越えるシステムメモリを積んではいけません。
積んでいる場合には、12MB を越える領域のメモリへのアクセスを全て無効に
しなければなりません。一部のオペレーティングシステムでは、利用できるメ
モリの量を起動時に指定することができるので、リニアメモリを使おうとする
度に物理的にメモリを取り外す必要はありません。

<!--
<sect1>Some boards simply cannot work in linear mode<p>
-->
<sect1>リニアモードでは単に動作しないボードがあります<p>
<!--
Yes, and in that case, you're out of luck.
-->
その通りです。
そういう場合は、運が悪いのです。

<!--
There can be at least two reasons for this.
-->
動作しない理由は少なくとも 2 つ考えられます。

<!--
The first is the most common: the board manufacturer has left out the
necessary connections and hardware to be able to use linear addressing. This
means that no coding effort on this planet can help you with your problem:
it is physically impossible to use linear addressing.
-->
最初の理由はありふれています。ボードのメーカーがリニアアドレッシングを
使うために必要な配線やハードウェアを省いていることです。つまり、どんな
に努力しても問題を解決することはできません。リニアアドレッシングが物理
的に不可能なのですから。

<!--
The second reason is that the current XFree86 Tseng linear addressing code is
incompatible with the way your board is designed. The XFree86 Tseng code
assumes a 1:1 mapping of the address lines from the bus (either ISA, VLB or
PCI) to the address lines on the Tseng VGA chip. As unlikely as it may
sound, this may NOT be the case!
-->
2番目の理由は、現在の XFree86 の Tseng 用のリニアアドレッシングのコー
ドが、ボードの設計が想定している方法と互換でないことです。XFree86 の 
Tseng 用のコードでは、(ISA, VLB, PCI いずれも含む)バスのアドレス線と 
Tseng VGA チップのアドレス線が 1:1 で対応していることを想定しています。
こういうことはあまりないと思うので、たぶん原因では<em/ない/でしょう。

<!--
Some very rare boards do not have such a 1:1 mapping (e.g. two address lines
swapped). It is possible to support this type of hardware, but at this
moment, this has not been implemented yet.
-->
このように 1:1 に対応していないボードもごくまれにあります(例: 2つのア
ドレス線を入れ換えているもの)。このタイプのハードウェアをサポートする
ことは可能ですが、現時点では実装は行っていません。

<!--
Other boards use external address decoding hardware that combines a number
of address lines on the bus to a (smaller) number of address lines to the
VGA chip. One such board for example uses three NOR gates (one 74F02 chip)
to combine the 6 upper address lines to three address pins on the W32i chip.
Obviously, this represents a 2:1 mapping, and not a 1:1 mapping. Therefor,
this board is not "compatible" with the way XFree86 implements linear mode.
-->
他には、ボードがアドレスをデコードするハードウェアを外部に持っている場
合があります。このハードウェアは、バスのアドレス線の数と VGA チップに
繋がるアドレス線の数(少ない)を合わせるためのものです。

このようなボードの 1 つは、3 つの NOR ゲート(74F02 チップ 1 つ)を使っ
て 6 つの上位アドレスの線を W32i チップの 3 つのアドレスピンに接続して
います。これは明らかに 2:1 のマッピングを表し、1:1 のマッピングではあ
りません。したがって、このボードは XFree86 のリニアモード実装方法とは
「互換」ではありません。

<!--
<sect1>How can I see if the linear address is wrong?<p>
-->
<sect1>リニアアドレスが間違っているかどうかはどうやって調べるのですか?<p>
<!--
Simple: nothing works, or your machine locks solid, or it crashes, or a
zillion of other things.
-->
単純な話では: 全く動作しない、マシンが凍ってしまう、クラッシュしてしま
う、その他諸々の問題が起きた時です。

<!--
However, sometimes it is not always as obvious. Sometimes nothing bad
happens: you just get a black screen, or a screen with rubbish on it, but
nothing is drawn on it. Sometimes you get a core dump when the first
application starts.
-->
しかし、必ずしも明らかなわけではありません。問題が起こらないこともあり
ます。単に画面が真っ黒になったり、画面にゴミが表示されたりしますが、ス
クリーンに何も描画されません。最初のアプリケーションを起動した時にコア
ダンプすることもあります。
<!-- 何かヘン… -->

<!--
If acceleration is enabled in those cases, you will almost always see
multiple "WAIT_ACL: timeout" messages in the server output. That is because
the accelerator registers are also mapped in the linear memory, and if
linear memory doesn't work, then also the accelerator doesn't work.
-->
このような場合にアクセラレーションを有効にしていたら、ほぼ確実にサーバ
の出力に"WAIT_ACL: timeout" というメッセージが複数回現われているでしょ
う。この理由は、アクセラレータのレジスタもリニアメモリにマップされてい
ることです。そして、もしリニアメモリが動作しなければ、アクセラレータも
動作しません。

<!--
NOTE however that a WAIT_ACL message doesn't necessarily mean the linear
memory address is bad. There are a number of other reasons for this message
as well. But if you never saw these messages at 8bpp banked, then there's a
good chance you have a linear memory problem ("banked" is the opposite of
"linear", and is the default mode when "option linear" is not in the
XF86Config file).
-->
しかし、WAIT_ACL のメッセージは必ずしもリニアメモリアドレスの誤りを意
味するわけではない点に注意してください。このメッセージが出力される原因
は他にもたくさんあります。しかし、8bpp のバンク切り替えモードの時には
このメッセージが全く現われない場合には、リニアメモリの問題を考えるとよ
いでしょう(「バンク切り替え」は「リニア」の反対のモードです。
XF86Config ファイル中で "option linear" が指定されていなければ、デフォ
ルトでバンク切り替えモードとなります)。

<!--
<sect> Mode issues <p>
-->
<sect> モードの問題 <p>

<!--
The accelerated driver on ET4000W32/W32i/W32p and ET6000 needs at least 1K
bytes of scratch space in video memory. Consequently, if you want
acceleration, a 1024x1024 virtual resolution should not be used with a
1Mbyte card. This also means that a 1024x768 mode at 24bpp on a 2.25 MB
ET6000 card cannot be accelerated, since you've used up all the memory for
the display.
-->
ET4000W32/W32i/W32p と ET6000 におけるアクセラレーション付きのドライバ
は、少なくとも 1KB の作業用空間をビデオメモリ上に必要とします。したがっ
て、アクセラレーションを使う場合には、1MB のカードでは 1024x1024 の仮
想解像度は使えないはずです。これは、2.25MB の ET6000 カードの場合、
24bpp 時には 1024x768 モードでアクセラレーションが使えないということで
もあります。なぜなら、表示で全てのメモリが使われてしまうからです。

<!--
The same thing goes for the ET6000 hardware cursor: it also requires 1kb of
free video memory. If that memory is not available, the hardware cursor
cannot be used.
-->
同じことが ET6000 のハードウェアカーソルでも言えます。ハードウェアカー
ソルも空きのビデオメモリを 1MB 必要とします。これだけのメモリが利用で
きなければ、ハードウェアカーソルは使用できません。

<!--
The use of a higher dot clock frequencies has a negative effect on the
performance of graphics operations on non-et6000 cards (the effect is much
less, or even non-existing, on ET6000 cards), especially BitBlt, when little
video memory bandwidth is left for drawing. Memory bandwidth is the speed at
which data can be pumped into the memory while the RAMDAC is pulling it out
to display it on the screen.
-->
ET6000 でないカードの場合、高いドットクロック周波数を使うと、グラフィッ
クス操作の性能に悪影響が出ます(ET6000 の場合は影響がずっと小さいか、全
く存在しません)。特に BitBlt 操作と、描画に使えるビデオメモリのバンド
幅がほとんど残っていない時に性能が悪くなります。メモリのバンド幅は、
RAMDAC が画面に表示するためにデータを吸い出す間に、データがメモリに送
り込まれる速度です。

<!--
Higher dot-clocks (mostly related to higher resolutions) consume more
bandwidth, so that less of it is left for drawing into the framebuffer. With
a working accelerator, things become increasingly crammed, because modern
accelerators can consume huge amounts of bandwidth (but they also give you
high speeds in return). High color depths also need extra bandwidth.
-->
ドットクロック値を高くすると(普通は高解像度と関連します)より多くのバン
ド幅を使うので、フレームバッファに描画を行うためのバンド幅は少なくなり
ます。アクセラレータが動作していると、データはいよいよ詰め込まれるよう
になります。なぜなら、最近のアクセラレータは大量のバンド幅を使うことが
できるからです(しかし、その代わりに高速に動作します)。色の深さが大きい
と、さらに多くのバンド幅を必要とします。

<!--
If you are short on memory bandwidth (see the separate section on this) and
experience blitting slowness or screen "glitches", try using the lowest dot
clock that is acceptable; for example, on a 14" or 15" screen 800x600 with
high refresh (50 MHz dot clock) is not so bad, with a large virtual screen.
-->
メモリのバンド幅が足りず(この話題に関する別のセクションを参照してくだ
さい)動作が遅くなったり画面の「不調」が起こった場合には、指定できるう
ちで最も遅いドットクロック値を試してください。例えば 14 インチや 15 
インチの画面で解像度を 800x600 とし、リフレッシュレートを高くし(ドット
クロック値が 50MHz)、仮想解像度を大きく取るのは悪くない考えです。
<!-- blitting って辞書に載ってないんですけど… -->

<!--
Tseng chips are mostly known for their (very) good memory bandwidth, so you
should only start to see problems in the higher regions.
-->
Tseng チップは大抵メモリのバンド幅が(大変)良いことで知られています。で
すから、問題が起こるのは高いクロック値の場合だけのはずです。

<!--
It does not make much sense performance-wise to use the highest clock (85
MHz) for 1024x768 at 76 Hz on a 1 MB ET4000W32; the card will very slow,
because there is almost no bandwidth left for drawing. A 75 MHz dot clock
results in 70 Hz which should be acceptable. If you have a monitor that
supports 1024x768 at 76 Hz with a 85 MHz dot clock, an 1MB card is a poor
match anyway.
-->
メモリが 1 MB の ET4000W32 で、76Hz の時に解像度を 1024x768 にする場合、
ドットクロック値を高く(85MHz)しても性能を上げるためには無意味です。描
画のためのバンド幅がほとんど残らなくなり、カードの動作がとても遅くなる
でしょう。ドットクロックを 75MHz にすると 70Hz となり、この値なら問題
ないはずです。76Hz 時に 1024x768 を ドットクロック値 85MHz でサポート
するモニタを使っている場合には、メモリ 1MB のカードはいずれにせよ貧弱
と言えます。

<!--
The ET4000W32i and ET4000W32p have a special feature that almost doubles
memory bandwidth (+70%) using "interleaving" between the two banks.
Upgrading to 2MB is a real bonus on these cards. This is not true for W32
cards or for ET6000 cards.
-->
ET4000W32i と ET4000W32p は、2つのバンク間での「インタリーブ」を用いて
メモリのバンド幅をほとんど倍(+70%)にするという特殊な機能を持っています。
これらのカードは 2MB にアップグレードすると大変効果があります。これは 
W32 カードや ET6000 カードには当てはまりません。

<!--
<sect> Acceleration issues <p>
-->
<sect> アクセラレーションの問題 <p>

<!--
The XFree Acceleration Architecture makes extensive use of the unused video
memory on the VGA card. If there is not enough free video memory, some
acceleration features will be disabled or crippled, resulting in less
performance.
-->
XFree Acceleration Architecture は VGA カードの未使用のビデオメモリを
最大限に利用します。空いているビデオメモリの量が十分でなければ、アクセ
ラレーション機能の一部が無効になったり制限されたりします。この場合には
性能は悪くなります。

<!--
To avoid this from happening, try to keep an absolute minimum of 16 kb of
free memory, in addition to the 1kb already reserved by the accelerator.
-->
そうならないようにするためには、既にアクセラレータが予約している 1KB 
に加えて、最低限 16KB の空きメモリを絶対に確保しましょう。

<!--
In practice, this small amount of memory should not be a problem. Most cards
nowadays have 2 MB of video memory, and running 1280x1024 still leaves
plenty of memory unused. Even a 1600x1200 desktop will leave over 170kb
unused, which will then be used by the accelerator to enhance performance.
-->
実際には、これだけの小量のメモリを確保しても問題にはならないはずです。
最近のカードの大部分はビデオメモリが 2MB あるので、1280x1024 モードで
も多くのメモリが未使用のままです。デスクトップを 1600x1200 にしてさえ、
170KB 以上が未使用のままです。この領域はアクセラレータが性能向上のため
に使います。

<!--
Most 1MB cards cannot display modes larger than 1024x768 with a decent
refresh rate, leaving 256kb unused.
-->
1MB カードのほとんどでは、256KB を未使用状態にすると、ちゃんとしたリフ
レッシュレートで 1024x768 より大きいモードの表示を行えません。

<!--
The order in which free memory is used to accelerate certain features is as
follows.
-->
ある機能にアクセラレーションを効かせるために空きメモリを使う順序は以下
のようになります。

<!--
If no video memory is unused (i.e. all of it is used for display memory),
no acceleration can be used at all &ndash; not even a hardware cursor on the
ET6000.
-->
未使用のビデオメモリが全くないい場合(つまり、ビデオメモリが全て表示メ
モリに使われている場合)には、アクセラレーションは全く使用できません。
ET6000 でハードウェアカーソルを使うことさえできません。

<!--
If the hardware cursor is enabled (ET6000 only) and there's at least 1kb of
free video memory, 1kb is used for that.
-->
ハードウェアカーソルが有効で(ET6000 のみ)、かつビデオメモリが少なくと
も 1KB 空いている場合、1KB がハードウェアカーソルのために使われます。

<!--
If there is at least 1kb of free memory remaining after this, most
acceleration features are enabled as well, reserving an extra 1kb of video
memory.
-->
この後に少なくとも 1KB 空きメモリが残っていれば、アクセラレーション
機能もほとんどが有効になります。この際には追加のビデオメモリがさらに 
1KB 予約されます。

<!--
If there's still some free memory, some extra acceleration features are
enabled. These require more free video memory, depending on the virtual
screen width and the color depth (bpp). The server will print out how much
memory it used if it could.
-->
まだ空きメモリがある場合、追加のアクセラレーション機能がいくつか有効に
なります。これらの機能は、仮想スクリーンの幅と色の深さ(bpp)に依存して、
空きのビデオメモリをさらに必要とします。追加のアクセラレーション機能が
使えるならば、サーバは使用するメモリの量を出力するでしょう。

<!--
If there's still some free video memory, it is used as a pixmap cache. This
way, small patterns and images can be kept in the video memory so that they
don't need to be transferred into the video memory each time they're needed.
This is beneficial because transferring an image over the bus to the video
memory takes a lot more time than letting the accelerator blit it from the
pixmap cache to the display memory.
-->
これでもまだビデオメモリが空いていれば、この領域はピックスマップのキャッ
シュとして使われます。これを使うと、小さなパターンやイメージをビデオメ
モリに保持することができるので、必要となる度に毎回ビデオメモリに転送す
る必要が無くなります。バスを使ってビデオメモリにイメージを転送する方法
は、アクセラレータを使ってピックスマップキャッシュから表示メモリに 
blit 操作を行わせる方法と比べてずっと時間がかかるので、このキャッシュ
は有効です。

<!--
<sect> ET6000 memory size facts and fiction <p>
-->
<sect> ET6000 メモリサイズの嘘と真実 <p>

<!--
The ET6000 uses a special kind of video memory called MDRAM (multi-bank
DRAM). It may have a non-power-of-two amount of MDRAM: 2.25 or even 4.50 MB.
Especially 2.25 MB MDRAM is popular, since this can support 1024x768 at
24bpp without needing 4MB of RAM.
-->
ET6000 は MDRAM (複数バンク DRAM)と呼ばれる特殊な種類のビデオメモリを
使っています。このカードは 2 の乗数でない量の MDRAM(2.25MB や 4.50MB) 
を積んでいることがあります。特に 2.25MB MDRAM が一般的です。というのも、
RAM が 4MB 無くても 24bpp で 1024x768 をサポートできるからです。

<!--
There are a few less intuitive problems with this.
-->
このカードについては分かりにくい問題がいくつかあります。

<!--
First of all, All memory above the 4 MB limit is a waste of money, because
the ET6000 cannot use this memory for anything at all. There are boards with
4.5 MB around, but that extra 0.5 MB is a waste. The ET6000 can only refresh
4 MB of (M)DRAM (refresh register). It can only access 64 banks of 64KB in
VGA mode (bank select register). All accelerated commands use a 22-bit
address (=4MB) inside the video memory. You get the idea... There is no way
for the ET6000 to use anything above the 4Mb limit.
-->
まず最初に、4MB の制限を越えるようなメモリは全てお金の無駄です。なぜな
ら、ET6000 はこのようなメモリを全く使うことができないからです。4.5MB 
くらいメモリを積んでいるボードもありますが、4MB を越える分の 0.5MB は
無駄になります。 ET6000 がリフレッシュできる (M)DRAM は 4MB だけです
(リフレッシュレジスタ)。このカードは VGA モードだと 64KB のバンク 64 
個にしかアクセスできません(バンク選択レジスタ)。アクセラレーション付き
のコマンドの全ては、ビデオメモリ内部では 22 ビット(=4MB)のアドレスを使
います。これでお分かりかと思いますが…ET6000 には 4MB の限界を越えるメ
モリを使う方法は存在しません。

<!--
And Secondly (more importantly): you may not have 2.25 MB at all! There have
been several reports about ET6000 cards that were sold with (supposedly)
2.25 MB of MDRAM, but which turned out to be standard 2MB MDRAM cards.
People have been having trouble with these all along, since sometimes the
X-server used to detect this as 2.25 MB (or even 2.5 MB) due to internal
chip design and also due to faulty BIOSs. This memory detection problem
has been fixed now, and the server should detect the correct amount of memory.
-->
次に(こちらの方が重要なのですが)、2.25MB のカードを使うことはできませ
ん! ET6000 カードに関する報告がいくつかあるのですが、これによると 
ET6000 カードは MDRAM を 2.25 MB (たぶん)積んでいるものとして売られて
いますが、これは標準の 2MB DRAM カードであることが明らかになっています。
多くの人がこのカードを使ってずっとトラブル続きでしたが、これは使用した 
X サーバがメモリを 2.25MB(あるいは 2.5MB)として検出したためです。誤っ
た値が検出されるのは、チップの内部的な設計や、BIOS の内容が誤っている
ためです。このようなメモリ検出に関する問題は既に修正されているので、サー
バは正しい量のメモリを検出できるはずです。

<!--
Do NOT define the amount of memory in the XF86Config yourself, unless you
are absolutely sure about the amount.
-->
メモリの量が絶対に正しいという自信が無い限り、自分自身でメモリの量を 
XF86Config ファイルに指定しては<em/いけません/。

<!--
There is a simple way to determine the amount of MDRAM on your card beyond
doubt.
-->
カードに載っている MDRAM を量を確実に調べるための簡単な方法があります。

<!--
Look at the video card. There is one large chip with 204 pins on it, which
is the ET6000. One socketed rectangular chip, mostly with a sticker on it,is
the BIOS. The remaining big chips are (mostly) 2 or 4 other large square
chips on it with the following markings:
-->
ビデオカードを見てください。カードには ピンが 204 個付いている大きいチッ
プがありますが、これが ET6000 です。ソケットに刺さっている長方形のチッ
プ(大抵ステッカーが貼られていますが)が BIOS です。残りの大きいチップと
しては、(大抵)以下のような印が付いている大きな正方形のチップ 2 つか 4 
つあります。

<!--
	MDRAM
	MD9xy     ("xy" is a two-digit number)
	SJ-5-100  (this may differ, but it will have the same layout)
-->
	MDRAM
	MD9xy     ("xy" は 2 桁の数字です)
	SJ-5-100  (これは違うかもしれませんが、レイアウトは同じでしょう)

<!--
and a nice logo next to all that with 4 diamonds and the name "MoSys"
underneath.
-->
これら全ての隣には、4つの菱形の下に "MoSys" という名前をあしらった素敵
なロゴがあります。

<!--
The "xy" number tells you how much MEGABITS there are in that one chip.
-->
"xy" の数字を見ると、1 つのチップのメガビットでのサイズが分かります。

<!--
The amount of RAM on the card is then:
-->
したがって、カードに載っている RAM の量は次のようになります:

<!--
	("xy" * number_of_MDRAM_chips) / 8    Mbytes
-->
	("xy" * [MDRAM チップの数]) / 8    MB

<!--
On my board, there are two MD908 chips, which means I have
-->
筆者のボードには、MD908 チップが 2 つ載っていたので、MDRAM の量は

<!--
	(08 * 2) / 8 = 2 MB of MDRAM.
-->
	(08 * 2) / 8 = 2 MB

ということになります。
<!--
Boards with two MD909 chips have 2.25 MB, etc.
-->
同様に MD909 チップを 2つ 積んでいるボードのメモリは 2.25MB のようにな
ります。

<!--
Current MDRAM chips are MD904, MD906, MD908, MD909, MD910, MD916, MD918 and
MD920.
-->
現時点で存在する MDRAM チップには、MD904, MD906, MD908, MD909, MD910,
MD916, MD918, MD920 があります。

<!--
<sect> ET6000 memory bandwidth hype and the impact on video modes <p>
-->
<sect> ET6000 のメモリバンド幅に関する誇大広告と、ビデオモードへの影響<p>

<!--
Tseng has always had wet dreams about memory bandwidth, and their press
announcements about the ET6000 memory bandwidth are no exception.
-->
Tseng はメモリのバンド幅について妄想を持っているようで、ET6000 のバン
ド幅に関する報道関係へのアナウンスも例外ではありません。

<!--
They claim the ET6000 using MDRAM is capable of reaching an incredible 1.2
Gbytes/sec of bandwidth. That would surpass just about everything on the
market (even SGI).
-->
Tseng は、MDRAM を使っている ET6000 は 1.2GB/秒のバンド幅が出せるとい
う信じられないことを言っています。これでは市場に出ているどんな製品も
(SGI のグラフィックスワークステーションさえ)上回ってしまいます。

<!--
And that would be true, _if_ they actually used the fastest available MDRAMs
on their boards, which they don't. The stunning 1.2 GByte mark is only
reached when using 4 MDRAM chips at their max clock rate of 166 MHz. But due
to design limitations, the first-generation ET6000 can only drive the
memories at 92 MHz (that will change when the ET6100 and ET6300 hit the
streets).
-->
「もし」利用できる最速の MDRAM を実際にボードに載せていれば、これは本
当になるでしょうが、そんな RAM は載せていません。聞こえの良い 1.2GB と
いう数字は、4 つの MDRAM チップを最大のクロックレートである 166MHz で
使った時に出るものです。しかし設計による制限のため、最初の世代の 
ET6000 はメモリを 92MHz でしか駆動できません(ET6100 や ET6300 が出れば
この数値は変わるでしょう)。

<!--
This means the max. theoretical bandwidth available on current ET6000 boards is "only"
360 MB/sec on boards with 2 MDRAM chips, and 720 MB/sec on boards with 4
MDRAM chips. And this assumes a best-case situation (=extremely long bursts
&ndash; the MDRAMs use a shared address/data bus, much like the PCI bus does). In
the real world, unaligned accesses both from the PCI bus and the accelerator
will reduce the effective available bandwidth. The current ET6000 boards
peak out at about 225 MB/sec, with 2 or 4 MDRAMs.
-->
つまり、現在の ET6000 ボードで実現できる理論的な最大のバンド幅は「たっ
た」 320 MB/秒(MDRAM チップを 2 つ載せたボード)か 720MB/秒(MDRAM チッ
プを 4 つ載せたボード)なのです。さらに、これは最善の場合を想定した数字
です(すなわち、ここではバースト転送を極めて長いものとしていますが、実
際には MDRAM は PCI バスと同様にアドレスバスやデータバスを共有します)。
現実には、PCI バスとアクセラレータ両方から来る順序が不定のアクセスによ
り、利用できるバンド幅の実効値はもっと低くなります。現在の ET6000 ボー
ドの最大性能は、DRAM が 2 つまたは 4 つの場合で約 225MB/秒 です。

<!--
Whatever you may have read in press releases, the ET6000 has a 32-bit memory
bus (not 128 bits; that's only the accelerator data path within the chip, if
anything). That means that, with their 16-bit busses, 2 MDRAM chips already
use the full bus capacity. Having 4 memory chips on an ET6000 board will not
give you extra memory bandwidth.
-->
プレスリリースをどんなに見たところで、ET6000 のメモリのバスは 32 ビッ
トです(128 ビットではありません。いずれにしても、この数字はチップ内の
アクセラレータのデータ経路だけです)。つまり、このチップの 16 ビットバ
スでは、MDRAM チップ 2 つだけでバスの容量を全て使ってしまいます。
ET6000 ボードにメモリチップが 4 つ載っていても、メモリのバンド幅が増え
るわけではありません。

<!--
Memory bandwidth limits the maximum resolution you can use at a given color
depth. The ET6000 RAMDAC can cope with 135 MHz in any situation. But the RAM
cannot. At 32bpp (sparse 16M color mode), using a 135 MHz pixel clock would
require a memory bandwidth of 135*4 = 540 MB/sec, which the current ET6000
boards simply cannot cope with. And then you still need some spare bandwidth
for the PCI bus and the accelerator.
-->
ある色の深さで利用できる最大の解像度は、メモリのバンド幅による制限を受
けます。ET6000 の RAMDAC はどんな場合でも 135MHz でうまく動作できます。
しかし、RAM についてはそうではありません。32bpp (sparse 形式の 1600万
色モード)でピクセルクロック値を 135MHz にすると、メモリのバンド幅は 
135*4 = 540 MB/秒が必要となります。これは現在の ET6000 ではどうやって
も扱えません。PCI バスやアクセラレータの場合には、バンド幅をもっと節約
する必要があります。

<!--
That is why some modes will be refused, depending on your MDRAM memory
layout, even if the amount of memory would permit such a mode. See also the
trouble shooting section to see what can happen if too little memory
bandwidth is available.
-->
以上が、あるモードのために十分なメモリがあっても、MDRAM のメモリ配置に
よっては使えないモードがある理由です。利用できるメモリのバンド幅が足り
ない場合に起こる問題については、トラブルシューティングのセクションを参
照してください。

<!--
<sect> Linear addressing and 16bpp/24bpp/32bpp modes <p>
-->
<sect> リニアアドレッシングと 16bpp/24bpp/32bpp モード <p>

<!--
Currently the 16-bit (32768 or 65536 colors), 24-bit (16M colors, packed
pixel), and 32-bit (16M colors, sparse) pixel support in the SVGA server
requires linear addressing. This restriction may be removed in a future
version, but with nearly all new cards using the PCI bus (where linear
addressing poses no problem), removing the linear addressing requirement
presently has a lower priority than other features. Option "linear" can be
specified in a depth-specific screen section to enable linear addressing; a
MemBase setting (in the device section) is probably also required on non-PCI
based systems, and optionally on PCI systems that have trouble finding out
for themselves where the MemBase is.
-->
現在は 16 ビット(32768 色または 65536 色)、24 ビット(1600万色、packed 
形式)、32 ビット(1600万色、sparse 形式)のピクセルを SVGA サーバでサポー
トするには、リニアアドレッシングが必要です。この制限は将来のバージョン
ではなくなるかもしれませんが、最近のカードはほとんど全てが PCI バスを
使っているので(リニアアドレッシングが問題となりません)、リニアアドレッ
シングを必須でなくすることの優先度は他の機能よりも低くなっています。
深さ別に指定する Screen セクションで Option "linear" を指定すると、リ
ニアアドレッシングを有効にすることができます。PCI ベースでないシステム
の場合には、たぶん MemBase 値も設定する(Device セクション)必要があるで
しょう。また、自力で MemBase の場所を発見できない PCI システムの場合は、
追加的な設定が必要です。

<!--
Non-PCI cards are not (or not well) supported in linear memory mode at this
moment. Some of them don't support it at all, and some of the ones that do
have so many address decoding bugs that it isn't feasible to provide a
working solution.
-->
現時点では、PCI でないカードはリニアメモリモードでサポートされていませ
ん(あるいはうまくサポートされていません)。全くサポートしていないカード
もありますし、アドレスのデコードにバグがあってうまく動作しないカードも
あります。

<!--
For the most part, many of the accelerated features in the 8bpp server have
been implemented to support 16, 24, and 32 bpp modes for the W32 and the
ET6000. So although there are now up to 4 times as many bits to display, the
X server shouldn't feel overly sluggish. Note also that the 24bpp and 32bpp
modes are only supported on a limited set of cards, and with at least 2Mb of
memory.
-->
W32 と ET6000 の場合は大抵、8bpp サーバのアクセラレーション付き機能の
多くは、16, 24, 32bpp モードをサポートするように実装されています。した
がって、表示するビット数は 4 倍までになりますが、X サーバが重くなりす
ぎることは無いはずです。24bpp と 32bpp は一部のカードでしかサポートさ
れていない点と、少なくともメモリが 2MB あるカードでしかサポートされて
いない点に注意してください。

<!--
An ET6000 with 2.25 MB MDRAM is cheap-and-sound, since it can support exactly
1024x768 at 24bpp (using all available video memory). On all other video
cards, you need at least 4MB of video memory to do this. With only 2MB of
(M)DRAM, 960x720 is the best you can hope for.
-->
2.25MB の MDRAM を積んだ ET6000 はお買い得です。というのも、(利用可能
なメモリを全て使って) 24bpp で 1024x768 をちょうどサポートできるからで
す。他のビデオカードの場合は、これを行うためには少なくともビデオメモリ
が 4MB 必要です。(M)DRAM が 2MB しかないと、期待できる最大の大きさは 
960x720 です。

<!--
In the <tt>XF86Config</tt> <tt>"Screen"</tt> section, a
<tt>"Display"</tt> subsection must be
defined for each depth that you want to run, with separate Modes
and virtual screen size. Example (2Mb of video memory):
-->
<tt>XF86Config</tt> ファイルの <tt>"Screen"</tt> セクションでは、実行
しようと考えている全ての色の深さに対して <tt>"Display"</tt> サブセクショ
ンを定義しなければなりません。<tt>"Display"</tt> サブセクションではそ
れぞれ、Modes 値、仮想スクリーンのサイズを定義します。例(ビデオメモリ 
2MB の場合)を以下に示します:
<tscreen><verb>
Section "screen"
    SubSection "Display"
        Depth 8
        Virtual 1280 1024
        ViewPort 0 0
        Modes "640x480" "800x600" "1024x768"
    EndSubSection
    SubSection "Display"
        Depth 16
        Virtual 1024 992
        ViewPort 0 0
        Modes "640x480" "800x600" "1024x768"
    EndSubSection
    SubSection "Display"
        Depth 24
        Virtual 960 720
        ViewPort 0 0
        Modes "640x480" "800x600"
    EndSubSection
    SubSection "Display"
        Depth 32
        Virtual 832 600
        ViewPort 0 0
        Modes "640x480" "800x600"
    EndSubSection
EndSection
</verb></tscreen>

<!--
<sect> Trouble shooting with the SVGA Tseng driver<p>
-->
<sect> SVGA Tseng ドライバに関するトラブルシューティング<p>

<!--
First of all, make sure that the default modes selected from your
<tt>XF86Config</tt>
are supported by your monitor, i.e. make sure the horizontal sync limit is
correct. It is best to start with standard 640x480x256 with a 25.175 MHz
clock (by specifying a single horizontal sync of 31.5) to make sure the
driver works on your configuration. The default mode used will always be
the first mode listed in the modes line, with the highest dot clock listed
for that resolution in the timing section.
-->
まず最初に、<tt>XF86Config</tt> で指定した中から選択したデフォルトのモー
ドが、お使いのディスプレイでサポートされていることを確かめてください。
つまり、水平同期の範囲が正しいことを確かめます。最初は(水平周波数 31.5
だけを指定することにより)クロック値 25.175MHz で標準の 640x480x256 を
使い、お使いの機器構成でドライバが動作することを確かめるとよいでしょう。
使用されるデフォルトのモードは必ず、モード行に最初に書かれている行で、
タイミングのセクションに書かれている、その解像度に対してリストされた最
も高いドットクロック値を持つものになります。

<!--
Some general hints:
-->
一般的なヒントをいくつか挙げておきます:
<itemize>
<!--
<item>Put Option "slow_dram" in the Device Section.
-->
<item>Device セクションに Option "slow_dram" を追加します。
<!--
<item>Put Option "pci_burst_off" in the Device Section.
-->
<item>Device セクションに Option "pci_burst_off" を追加します。
<!--
<item>Put Option "w32_interleave_off" in the Device Section.
-->
<item>Device セクションに Option "w32_interleave_off" を追加します。
<!--
<item>Take out the Hercules monochrome adapter, if you have one.  Many
    configurations of the ET4000/W32 series do not allow one in the
    system.
-->
<item>Hercules のモノクロのアダプタが付いていれば、これを外します。
ET4000/W32 シリーズの多くの構成は、システムにこのカードがあると動作し
ません。
<!--
<item>Get a motherboard with its local bus running at 33 MHz.  Many, if not
    all, ET4000/W32 boards will surely behave in a funny way on a 50-MHz
    bus.  You may have to use a wait state or two, but first try without
    any.
-->
<item>ローカルバスが 33MHz で動作するマザーボードを入手します。
ET4000/W32 ボードの多く(全てではなくても)は、50MHz のバスでは確実に動
作がおかしくなります。待ち状態を 1 つか 2 つ入れる必要があるかもしれま
せんが、何はともあれまず試してください。
<!--
<item>Cold-boot your machine.  Do not run anything that messes with the
    video hardware, including other X servers, before running
    <tt>XF86_SVGA</tt>.
-->
<item>マシンをコールドブートします。<tt>XF86_SVGA</tt> を実行する前に
は、(他の X サーバを含めて)ビデオハードウェアを変にするものを実行して
はいけません。
<!--
<item>In case of an ET6000 card, try specifying chipset "et6000"
    in the Device Section. The card normally auto-probes from the PCI bus,
    but on some systems, another on-board VGA card, although disabled, may
    cause the ET6000 server to want to use the other card.
-->
<item>ET6000 カードの場合は、Device セクションでチップセットに 
"et6000" を指定してみてください。このカードは通常、PCI バスから自動検
出を行います。しかし一部のシステムでは、別のオンボードの VGA カードが
載っていると(これを無効にしてあっても)ET6000 が間違った方のカードを使
おうとすることがあります。
</itemize>

<!--
Note that some VESA standard mode timings may give problems on some monitors
(try increasing the horizontal sync pulse, i.e. the difference between
the middle two horizontal timing values, or try multiples of 16 or 32 for
all of the horizontal timing parameters).
-->
VESA 標準モードタイミングの一部は、モニタによっては問題を起こすことに
注意してください(水平同期パルスを増やすか(つまり、真中の 2 つの水平タ
イミング値を増やす)、あるいは水平タイミングのパラメータを全て 16 や 32 
の倍数にしてみてください)。

<descrip>
<!--
<tag>There is a video signal, but the screen doesn't sync.</tag>
-->
<tag>ビデオ信号は出ていますが、画面が同期しない</tag>
<!--
        You are using a mode that your monitor cannot handle. If it is
        a non-standard mode, maybe you need to tweak the timings a bit. If
        it is a standard mode and frequency that your monitor should be able
        to handle, try to find different timings for a similar mode and
        frequency combination.
-->
モニタが扱えないモードを使っています。これが非標準のモードであれば、タ
イミングを少しずらす必要があるかもしれません。モニタが扱えるはずである
標準のモードと周波数であれば、同様のモードと組み合わせに対する別のタイ
ミングを見つけてください。

<!--
<tag>Horizontal jitter at high dot clocks.</tag>
-->
<tag>ドットクロック値を高くすると水平方向にぶれる</tag>
<!--
        This problem shows up especially when drawing operations such as
        scrolling or blitting are in progress. There is currently no easy
        fix for this, You can try the <tt>"fast_dram"</tt> option, or use a
        lower dot clock. If that is not sufficient, the <tt>"noaccel"</tt>
        option will almost always help (it leaves more bandwidth for the
        RAMDAC). In most cases, this is caused by the video memory not being
        able to provide pixel data to the RAMDAC fast enough, so it gets fed
        with garbage.
-->
この問題は、スクロールや blit 操作のような描画機能の動作中に特に顕著に
なります。現時点ではこの問題の簡単な解決方法はありませんが、
<tt>"fast_dram"</tt> オプションを試したり、ドットクロック値を下げるな
どしてみてください。それでも不十分であれば、<tt>"noaccel"</tt> オプショ
ンを使えばほぼ確実に問題が解決するでしょう(RAMDAC が使えるバンド幅が多
くなるためです)。ほとんどの場合、この原因は RAMDAC に十分速くピクセル
データを送ることができないビデオメモリにあり、そのためにゴミが出るので
す。

<!--
<tag>`Wavy' screen.</tag>
-->
<tag>画面が「波打つ」</tag>
<!--
        Horizontal waving or jittering of the whole screen, continuously
        (independent from drawing operations). You are probably using a dot
        clock that is too high; it is also possible that there is
        interference with a close MCLK. Try a lower dot clock (sometimes
        even dropping it by 0.5 MHz may work). You can also try to tweak the
        mode timings; try increasing the second horizontal value somewhat.
        Here's a 65 MHz dot clock 1024x768 mode (about 60 Hz) that might
        help:
-->
画面全体が(描画操作とは無関係に)ずっと水平に揺れたり震えたりします。た
ぶんドットクロック値が高すぎるのでしょう。また、近い MCLK 値が衝突して
いることも考えられます。このような場合には、ドットクロック値を低くして
みましょう(0.5MHz だけ下げればうまく動作することもあります)。モードの
タイミングをずらしてみてもよいでしょう。水平方向の 2 番目の値を少し増
やしてみてください。うまく動作すると思われる、ドットクロック値が 65MHz 
の 1024x768 (約 60Hz)の例を以下に示します:
<verb>
 "1024x768"     65      1024 1116 1228 1328     768  783  789  818
</verb>
<!--
<tag>Crash or hang after start-up (probably with a black screen).</tag>
-->
<tag>起動の後にクラッシュやハングする(たぶん画面は真っ暗になります)</tag>
<!--
        Try the <tt>"noaccel"</tt> option. Check that the BIOS settings are
        OK; in particular, disable caching of 0xa0000-0xaffff. Disabling
        hidden DRAM refresh may also help.
-->
<tt>"noaccel"</tt> オプションを試してください。BIOS の設定が正しいこと
を確認してください。特に、0xa0000-0xaffff のキャッシュは無効にしてくだ
さい。裏 DRAM のリフレッシュを無効にしても問題が解決するかもしれません。

<!--
        On Linux systems, if "APM" (power management) support is enabled in
        the kernel, the server may start up in power-save mode or with a
        black screen. Rebuild your kernel with APM support disabled.
-->
Linux システムの場合は、カーネルで「APM」(電源管理)のサポートを有効に
していると、X サーバが省電力モードや画面が真っ暗な状態で起動することが
あります。APM のサポートを無効にしてカーネルを再構築してください。
<tag>
<!--
Crash, hang, or trash on the screen after a graphics operation.
-->
グラフィックス操作を行った後にクラッシュやハングしたり、画面にゴミが表示される
</tag>
<!--
        This may be related to a bug in one of the accelerated functions, or
        a problem with the BitBLT engine. Try the <tt>"noaccel"</tt> option.
        Also check the BIOS settings.
-->
これはアクセラレーション付きの機能のいずれかのバグか、BitBLT エンジン
の問題に関係するかもしれません。<tt>"noaccel"</tt> オプションを試して
ください。また、BIOS の設定も確かめてください。
<tag>
<!--
`ACL: TIMEOUT' messages from the server.
-->
サーバが `ACL: TIMEOUT' というメッセージを出力する
</tag>
<!--
        Same as for the above entry. However, on some systems, the problem
        will not go away no matter what you do. It may be related to the
        operating system you use (it has only been seen on Linux systems,
        and even then it depends on the kernel versions). Sometimes,
        choosing another MemBase may help.
-->
前の項目と同じです。しかし一部のシステムでは、問題はどうやっても解決で
きません。これは使っているオペレーティングシステムに関連しているかもし
れません(この問題は Linux だけで見られ、カーネルのバージョンにまで依存
します)。MemBase 値を変えると問題が解決することもあります。
<tag>
<!--
Occasional erroneous pixels in text, pixel dust when moving window-frame
-->
テキスト中のピクセルが時々狂ったり、ウィンドウの枠を動かした時にゴミピクセルが出る
</tag>
<!--
        Probably related to MCLK setting that is too high (can happen with
        linear addressing even though banked mode runs OK). Most (if not
        all) ET6000 cards are sold with the MCLK slightly over clocked for
        performance (the current norm is 90 or 92 MHz), which may cause
        these problems. There is currently no fix for this. If the pixel
        dust is only temporary (it disappears as soon as nothing moves on
        the screen anymore), then memory bandwidth is probably the cause.
        The only solution is to disable acceleration, or, if that doesn't
        help, using a lower pixel clock.
-->
おそらく MCLK 値の設定が高すぎることに関係しています(バンク切り替えモー
ドで OK であっても、リニアアドレッシングモードで問題が起こることがあり
ます)。(全てでなくとも)ほとんどの ET6000 カードは性能を出すために MCLK 
を少しオーバークロックして売っており(現在の標準値は 90 か 92 MHz で
す)、これにより問題が起こることがあります。現時点ではこれを解決する方
法はありません。ゴミピクセルが一時的なもの(スクリーン上で動くものが無
くなるとすぐ消える)であれば、おそらくメモリのバンド幅が原因です。唯一
の解決方法はアクセラレーションを無効にすることか、(これで解決しなけれ
ば)ピクセルクロック値を低くすることです。
<tag>
<!--
Textmode is not properly restored
-->
テキストモードがうまく復元できない
</tag>
<!--
        This has been reported on some configurations. Sometimes a Chipset
        line will fix this. Normally you should be able to restore the
        textmode font using a utility that sets it (<tt>setfont</tt>,
        <tt>runx</tt>, <tt>restorefont</tt> on Linux).
-->
この問題は一部の機器で報告されています。Chipset 行の設定で問題が解決す
ることがあります。通常はテキストモードのフォントをセットするユーティリ
ティを使えば、うまく復元ができるはずです(Linux の場合は 
<tt>setfont</tt>, <tt>runx</tt>, <tt>restorefont</tt>)。
<tag>
<!--
Mostly black or blue screen when using accelerated driver features
-->
ドライバのアクセラレーション付きの機能を使うと、画面が真っ暗や真っ青になる
</tag>
<!--
        If you are seeing a mostly black or blue screen, with only a few
        icons (pixmaps) displayed, this section applies to you.
-->
アイコン(ピックスマップ)をいくつか表示しただけで画面が真っ暗や真っ青に
なるになる場合には、このセクションの内容が当てはまります。

<!--
        There can be several causes for this.
-->
この現象には原因がいくつかあります。

<!--
        One is if the amount of memory is not detected (or specified) correctly. If the
        server's autodetection mechanism detects too much memory,
        accelerated features will not work. Define the amount of memory in
        the <tt>XF86Config</tt> file. This seems to happen sometimes on some
        2.25 MB ET6000 cards, where the server detects 2.5 MB instead (add
        <tt>videoram "2304"</tt> in this particular case).
-->
原因の 1 つはメモリの量が正しく検出(指定)されていないことです。サーバ
の自動検出機構が検出した値が多すぎる場合、アクセラレーション付きの機能
は動作しないでしょう。この場合には <tt>XF86Config</tt> ファイルでメモ
リの量を定義してください。この問題はメモリ 2.25 MB の ET6000 カードの
一部で時々起こり、サーバが 2.25MB ではなく 2.5MB と検出するようです(こ
の場合に限れば、<tt>videoram "2304"</tt> を追加してください)。

<!--
        If that doesn't help, disabling acceleration (option
        <tt>"noaccel"</tt>) is the only solution.
-->
これでうまくいかない場合には、アクセラレーションを無効にする(オプショ
ン <tt>"noaccel"</tt>)しか解決方法はありません。
<tag>
<!--
Problems with DMA hardware (floppy, tape)
-->
DMA ハードウェアに関する問題(フロッピー、テープ)
</tag>
<!--
	On some systems, the accelerated server will interfere with other
	hardware that uses ISA DMA. Most notably is the PC floppy controller
	and sound cards. The floppy interface cannot cope with inordinately
	long bus-holds, which may occur during large accelerated operations.
	The Linux-ftape module for example (a floppy-tape driver) will
	generate lots of "write error" messages when running a backup or
	restore operation while the X-server is in use. These errors should
	not be fatal, but that all depends on how well the operating system
	handles these conditions. Linux seems to cope.
-->
一部のシステムでは、アクセラレーション付きのサーバは ISA DMA を使う他
のハードウェアと衝突します。最も顕著なのは、PC のフロッピーコントロー
ラとサウンドカードです。フロッピーインタフェースは、バスを長く占有され
すぎるとうまく動作できません。このような状態はアクセラレーション付きの
大量の操作を行った時に起こります。例えば、Linux-ftape モジュール(フロッ
ピー-テープのドライバ)は、X サーバの使用中にバックアップの作成や書き戻
しの操作を行うと、大量の「書き込みエラー」メッセージを出力します。
<!-- リストアの時は「read error」では。 -->
このエラーは致命的なものではありませんが、それはオペレーティングシステ
ムがこういった情報をいかにうまく処理するかにかかっています。Linux はう
まく処理するようですが。

<!--
	There are two possible solutions: disable acceleration using the
	<tt>"noaccel"</tt> option, or disable PCI-retry (which is causing
	the large bus delays) by removing the <tt>"pci_retry"</tt> option.
	This will cause a very small slowdown of accelerated operations.
-->
解決法は 2 通り考えられます。<tt>"noaccel"</tt> オプションを使ってアク
セラレーションを無効にするか、<tt>"pci_retry"</tt> を削除して PCI のリ
トライ機能(この機能はバスの遅延を大きくします)を無効にすることです。
これにより、アクセラレーション付きの操作が少しだけ遅くなります。

<!--
	The <tt>"pci_retry"</tt> option applies not only to the PCI bus
        systems, but has a similar effect on other busses.
-->
<tt>"pci_retry"</tt> が適用されるのは PCI バスのシステムだけではなく、
他のバスの場合にも同様の影響を与えます。
<tag>
<!--
"Cannot read colourmap from VGA.  Will restore with default"
-->
&dquot;Cannot read colourmap from VGA.  Will restore with default&dquot; というエラーが出る
</tag>
<!--
	If this error occurs, the server was unable to properly initialize
	the RAMDAC, and tries to restore a default color map. On some
	unsupported RAMDACs, this will have the adverse effect of removing
	all color altogether, leaving you with a bunch of weird colors, or
	with a completely black screen. If that happens, add the <tt>ramdac
	"normal"</tt> statement to the Device section in your
	<tt>XF86Config</tt> file. In most cases, this will solve the color
	problem.
-->
このエラーメッセージが出た場合、サーバは RAMDAC を正しく初期化できず、
デフォルトのカラーマップを復元しようとしています。
一部のサポートされていない RAMDAC の場合、この動作は全ての色がまとめて
削除されてしまうという悪影響を及ぼし、色がおかしくなってしまったり、画
面が完全に真っ黒になってしまうでしょう。こうなった場合には、XF86Config 
ファイルの Device セクションに <tt>ramdac "normal"</tt> という行を追加
しましょう。大抵の場合、色の問題はこれで解決します。
<tag>
<!--
Why does the server report my ModeLine with only half the pixel clock?
-->
サーバが報告する ModeLine の値がピクセルクロックの半分だけなのですが?
</tag>
<!--
	For ET4000W32p cards at 8bpp, some modes using a clock over 75 MHz
	(e.g. a 1152x910 mode with 95 MHz pixel clock) will produce the
	following message in the Xserver output:

	(&ndash;) SVGA: Mode "1152x910" will use pixel multiplexing

	And later, when the accepted modelines are reported:

	(**) SVGA: Mode "1152x910": mode clock =  47.500

	This is normal, because with pixel multiplexing, only half the clock
	is needed as two pixels are sent to the RAMDAC per clock pulse. 
-->
ET4000W32p カードを 8bpp で使う場合、75MHz 以上のクロックを使う一部の
モード(例: ピクセルクロック値が 95MHz の 1152x910 モード)では、X サー
バの出力に以下のメッセージが含まれます。

	(--) SVGA: Mode "1152x910" will use pixel multiplexing

	And later, when the accepted modelines are reported:

	(**) SVGA: Mode "1152x910": mode clock =  47.500

ピクセルの多重化が行われているので、これは正常な動作です。クロックパル
スごとにピクセル 2 つが RAMDAC に送られるため、半分のクロックしか必要
としません。
</descrip>
<!--
For other screen drawing related problems, try the <tt>"noaccel"</tt>
option.
-->
他に画面描画関連の問題があれば、<tt>"noaccel"</tt> オプションを試して
ください。

<!--
If you are having driver-related problems that are not addressed by this
document, or if you have found bugs in accelerated functions, you can try
contacting the XFree86 team.
-->
このドキュメントに書かれていないドライバ関連の問題に出会ったり、アクセ
ラレーション付きの機能にバグを見つけた場合には、XFree86 チームに連絡し
てください。

<!--
In fact, reports (success or failure) are very welcome, especially
on configurations that have not been tested. You can do this
via the BetaReport form (mail it to report@XFree86.org). You may want to
keep an eye on forthcoming beta releases at <it>www.xfree86.org</it>.
-->
実際のところ、報告(成功・失敗のいずれでも)は大歓迎です。特に、今までテ
ストが行われていない機器構成の場合は助かります。報告を行うには、
BetaReport フォーム を使います(report@XFree86.org 宛にメールで送ってく
ださい)。<it>www.xfree86.org</it> に現われるベータリリースを待つのも良
いでしょう。

<!--
<sect> Acknowledgments <p>
-->
<sect> 謝辞 <p>
<!--
Most of these stem from the old XF86_W32 server. That code was used
extensively for getting the SVGA server to work on all the Tseng cards, so
they are still somewhat valid.
-->
基本部分は古い XF86_W32 からもらいました。全ての Tseng のカードで SVGA
サーバを動かすために、このコードを広範囲に渡って利用しました。ですから、
このコードは今でもそれなりに有効と言えます。

<!--
Glenn G. Lai wrote the original XF86_W32 server. It was modified by
Dirk Hohndel and Koen Gadeyne to support some more hardware.
-->
Glenn G. Lai さんがオリジナルの XF86_W32 サーバを書きました。これは
Dirk Hohndel さんと Koen Gadeyne さんが修正し、対応ハードウェアを増や
しました。

<!--
Jerry J. Shekhel (<it>jerry@msi.com</it>) gave me (GGL) the 1-M Mirage
ET4000/W32 VLB board on which the initial development (X_W32) was done.
-->
Jerry J. Shekhel さん(<it>jerry@msi.com</it>) は筆者(GGL) にメモリ 1M
の Mirage ET4000/W32 VLB ボードをくださいました。初期開発(X_W32)はこの
カードを使って行いました。

<!--
X11R6 and The XFree86 Project provide the base code for XF86_W32.
-->
X11R6 と XFree86 プロジェクトには XF86_W32 の基本コードを頂きました。

<!--
Hercules Computer Technology Inc. lent me (GGL) a 2-M Hercules Dynamite Pro VLB
board for the development that led to <tt>XF86_W32</tt>.   They donated a
Dynamite Power PCI to The XFree86 Project, that was used by DHH to extend
the server.
-->
Hercules Computer Technology Inc. さんには、<tt>XF86_W32</tt> の開発の
ために筆者(GGL)にメモリ 2MB の Hercules Dynamite Pro VLB ボードを貸し
ていただきました。また、XFree86 プロジェクトに Dynamite Power PCI を寄
付していただきました。DHH がこのボードを使ってサーバの拡張を行いました。

<!--
Tseng Labs kindly donated (KMG) an ET6000-based board (a Jazz Multimedia
G-Force 128), which spurred the development of the ET6000 code. They also
provided an ET6100 evaluation board.
-->
Tseng Labs さんには(KMG に) ET6000 ベースのボード(Jazz Multimedia
G-Force 128)を寄付していただきました。これにより ET6000 コードの開発が
大きく進みました。また、ET6100 の評価用ボードも提供していただきました。

<!--
Heiko Eissfeldt provided an ET4000W32p_rev_b board which allowed us to get
better support for those rev_a and rev_b boards.
-->
Heiko Eissfeldt さんには ET4000W32p_rev_b ボードを提供していただきまし
た。これにより、rev_a と rev_b のボードのサポートを改善することができ
ました。

<!--
Gyorgy Krajcsovits donated an ET4000W32p + CH8398 board. A Really Good Move!
-->
Gyorgy Krajcsovits さんには ET4000W32p + CH8398 ボードを提供していただ
きました。素晴らしいことです!
<!-- A Really Good Move! (実は意味がわかってない ^_^;)って決まり文句? -->

<!--
Numerous testers have given me feedback for <tt>X_W32</tt> and later
<tt>XF86_W32</tt>.  I
apologize for my failure to keep track of the people who tested
<tt>X_W32</tt>, but
the names of the people involved with the <tt>XF86_W32</tt> testing are
listed below:
-->
多くのテスタの方が <tt>X_W32</tt> とそれに続く <tt>XF86_W32</tt> にフィー
ドバックを送ってくれました。筆者の手落ちで <tt>X_W32</tt> をテストして
くださった方は把握できていないのですが、<tt>XF86_W32</tt> のテストに参
加してくださった方々の名前を以下に挙げさせていただきます:
<descrip>
<tag>Linux:</tag>
<it>bf11620@coewl.cen.uiuc.edu</it> (Byron Thomas Faber) <newline>
<it>dlj0@chern.math.lehigh.edu</it> (David Johnson) <newline>
<it>peterc@a3.ph.man.ac.uk</it> (Peter Chang)  <newline>
<it>dmm0t@rincewind.mech.virginia.edu</it> (David Meyer) <newline>
<it>nrh@philabs.Philips.COM</it> (Nikolaus R. Haus) <newline>
<it>jdooley@dbp.caltech.edu</it> (James Dooley) <newline>
<it>thumper@hitchcock.eng.uiowa.edu</it> (Timothy Paul Schlie) <newline>
<it>klatta@pkdla5.syntex.com</it> (Ken Latta) <newline>
<it>robinson@cnj.digex.net</it> (Andrew Robinson) <newline>
<it>reggie@phys.washington.edu</it> (Reginald S. Perry) <newline>
<it>sjm@cs.tut.fi</it> (M{kinen Sami J) <newline>
<it>engel@yacc.central.de</it> (C. Engelmann) <bf>use</bf>
        <it>cengelm@gwdg.de</it> <newline>
<it>postgate@cafe.net</it> (Richard Postgate) <newline>
<it>are1@cec.wustl.edu</it> (Andy Ellsworth) <newline>
<it>bill@celtech.com</it> (Bill Foster)
<tag> FreeBSD: </tag>
<it>ljo@ljo-slip.DIALIN.CWRU.Edu</it> (L Jonas Olsson)
</descrip>

<!--
Several people have developed code for the SVGA Tseng driver (this list is
incomplete):
-->
SVGA Tseng サーバのコードの開発に参加してくださった方々もいます(このリ
ストは不完全です):
<itemize>
<item>Glenn G. Lai
<item>Dirk H. Hohndel
<item>Koen Gadeyne
<item>OEyvind Aabling
<item>Dejan Ilic
<item>Mark Vojkovich
<item>Harald Nordgard Hansen
<item>David Bateman
<item>Gyorgy Krajcsovits
<item>Kurt Olsen
</itemize>





<verb>
$XFree86: xc/programs/Xserver/hw/xfree86/doc/Japanese/sgml/tseng.sgml,v 1.1.2.2 1999/11/26 15:24:00 hohndel Exp $





$XConsortium: tseng.sgml /main/6 1996/10/27 11:06:09 kaleb $
</verb>

</article>
