<!DOCTYPE linuxdoc PUBLIC "-//XFree86//DTD linuxdoc//EN">

<article>

<!--
<title> How to add an (S)VGA driver to XFree86
<author> Copyright (c) 1993, 1994 David E. Wexelblat
  <tt/&lt;dwex@XFree86.org&gt;/
<date> Issue 1.3 - May 29, 1994
-->
<title> XFree86 へ (S)VGA ドライバを追加する方法
<author> Copyright (c) 1993, 1994 David E. Wexelblat
  <tt/&lt;dwex@XFree86.org&gt;/
<date> 1.3 号 - 1994 年 5 月 29 日
<trans> X Japanese Documentation Project &lt;<tt>http://xjman.dsl.gr.jp/</tt>&gt;
<tdate> 1999 年 2 月 6 日


<toc>

<!--
<sect> Introduction <p>
-->
<sect> 序文 <p>
<!--
Adding support for a new SVGA chipset to XFree86 is a challenging project 
for someone who wants to learn more about hardware-level programming.  It 
can be fraught with hazards (in particular, crashing the machine is all too 
common).  But in the end, when the server comes up and functions, it is
immensely satisfying.
-->
XFree86 に新しい SVGA チップセットのサポートを追加することは
ハードウェアに密着したプログラミングについて学習したい人にとって
手ごたえのある作業です。このような作業には危険が一杯です。
特に、マシンがハングアップしてしまうようなことは日常茶飯事です。
それでも最終的に、サーバが立ち上がってうまく動いてくれた時は、
底知れぬ満足感にひたれます。

<!--
Adding support for an SVGA chipset does not change any of the basic 
functioning of the server.  It is still a dumb 8-bit PseudoColor server or 
1-bit StaticGray server.  Adding support for new hardware (e.g. accelerated 
chips) is a major undertaking, and is not anywhere near formalized enough yet 
that it can be documented.
-->
SVGA チップセット対応のドライバを追加することはサーバの基本機能を
変更するものではありません。ただ、256 色同時発色のカラーサーバか
モノクロサーバが出来るだけです。新しいハードウェア（例えばアクセ
ラレータチップ）を追加することは重要な仕事で、文書化出来るような
定型的作業には程遠いものです。

<!--
Nonetheless, the driver-level programming here is a good introduction.  And 
can well be the first step for adding support for an accelerated chipset, as 
many are SVGA-supersets.  Writing an SVGA-level driver for the chipset can 
provide a stable development platform for making use of new features (in fact,
this has been done for the S3, Cirrus, and WD accelerated chipsets, for 
internal use as the accelerated servers are developed for XFree86 2.0).
-->
それにもかかわらず、ここで行うドライバを書くようなプログラミングは
良い入門となります。多くのアクセラレータチップセットは SVGA の上位互換
であるため、それらに対するサポートを追加するための最初の段階としても
意味のある作業です。
該当するチップに対応した SVGA のドライバを書くことによって、新しい機能を
追加するときに安定した開発環境で作業できます (実際、XFree86 2.0 のために
S3, Cirrus および WD のアクセラレータ対応サーバーを開発した際には、先に
これらのチップセットに対応した SVGA ドライバが作成され、XFree86 内部の
開発者たちによって使用されました。)
<p>
&lsqb;訳注: 最近では個別のアクセラレータ対応サーバーを開発することより
むしろアクセラレータ対応の SVGA ドライバを開発することのほうが多いよう
です。3.3.3 で追加された Cyrix や NeoMagic の他 S3V, Trident, C&amp;T
などの SVGA ドライバはアクセラレータに対応しています。一方 3Dlabs や
I128 のように最近でも個別のアクセラレータ対応サーバーとして開発された
例もあります。また、以下の説明は XFree86 3.x までのコードをベースと
していますが、現在 XFree86 で開発中の 4.0 ではサーバーの構造に大きな
変更が加えられており、以下の説明がそのまま合てはまらなくなっています。
これから新しいドライバーを書こうという場合には、できるだけ XFree86 に
参加して最初から 4.0 用に作成したほうが良いでしょう。それでも、以下の
説明を理解しておくことは無駄ではありません。用語や基本的な仕組などに
ついては参考になるものと思います。&rsqb;

<!--
Now let's get down to it.  In addition to this documentation, a stub driver has 
been provided.  This should provide you a complete framework for your new 
driver.  Don't let the size of this document persuade you that this is an
overly difficult task.  A lot of work has been put into making this document
as close to complete as possible; hence it should, in theory, be possible to
use this as a cookbook, and come out with a working driver when you reach the
end.  I do advise that you read it all the way through before starting.
-->
さあ、始めましょう。この文書に加えて、スタブドライバを提供しています。
これは新しいドライバを開発する際に完全な骨組みとして使えるように提供
するものです。
この文書が大きいからといって作業が過度に難しいと思わないでください。
この文書をできる限り完全なものに近づけるために、多くの努力が注がれました。
ですから理論的には、この文書を作業手順書として使い、最後までその手順に
従って実行していけば、ちゃんと動作するドライバーができあがるはずです。
なお作業を開始する前に、この文書を最初から最後までじっくり読み通しておく
ことをお勧めします。

<!--
<sect> Getting Started <p>
-->
<sect> 始めに <p>
<!--
The first step in developing a new driver is to get the documentation for 
your chipset.  I've included a list of vendor contact information that I have 
collected so far (it's far from complete, so if you have any that isn't on 
the list, please send it to me).  You need to obtain the databook for the 
chipset.  Make sure that the person you speak to is aware that you intend to 
do register-level programming (so they don't send you the EE-style datasheet).
Ask for any example code, or developer's kits, etc.  I've learned that at the 
SVGA level, in general, a databook that lists and describes the registers is 
the most you can hope to find.
-->
新しいドライバを作る最初の段階はそのチップセットに関する資料を
集めることです。今までにわたしが集めたベンダーの連絡先情報一覧を
この文書に入れています (完璧とは言えないものですので、この一覧に
無いもので知っているものがありましたら著者まで送ってください)。
チップセットのデータブックを取り寄せる必要があります。
ベンダーの担当者には、レジスタを直接操作して
プログラミングしたいのだとくれぐれも念を押す様にしてください。
(そうすれば電気的スペックシートを受け取らずに済みます) 

なにかサンプルプログラムか開発者用のキット等を入手できるかどうか
問い合わせてください。一般的に言って、SVGA レベルの開発作業に
おいて最も必要となる資料は、レジスタの一覧やその説明を記載している
データブックであることをわたしは学びました。

<!--
If you are not familiar with VGA register-level programming, you should get 
(and read!) a copy of Richard Ferraro's bible (see references below).  The 
best way to understand what is happening in the server is to study the 
workings of the monochrome server's ``generic'' server, and compare it with 
the documentation in Ferraro's book (be aware that there are a few errors 
in the book).  You can find the generic-VGA-register handling functions in 
the file ``vgaHW.c''.
-->
VGA レジスタを直接操作するようなプログラミングに慣れていない場合は
Richard Ferraro の必読書を入手して (是非読んで！) 下さい (この文章の最後に
添付した「参考文献」を見てください)。サーバで何が起っているかを理解する
最良の方法はモノクロの ``generic'' サーバの動作を調べ、Ferraro 
の本に書かれている情報と比較することです (本に少し間違いがあること
に注意してください)。generic サーバーで使われる VGA レジスタを扱う
関数は ``vgaHW.c'' ファイルの中に含まれています。

<!--
Once you understand what's happening in the generic server, you should study 
one or more of the existing SVGA drivers.  Obtain the databook for a supported
SVGA chipset, and study the documentation along with the code.  When you have 
a good understanding of what that driver does over and above the generic VGA, 
you will know what information you need to obtain from the databook for the 
new chipset.  Once you have this information, you are ready to begin work on 
your new driver.
-->
generic なサーバで何が起っているか理解したら、一つまたは複数の
既存の SVGA サーバについて調べてください。
サポートしている SVGA チップのデータブックを入手してプログラムを
追いながら文書を調査してください。
generic な VGA から何が仕様を超えていて何が仕様に収まっているか
良く理解したら、新しいチップについてデータブックからどんな情報を
得ればよいか分かるでしょう。この情報を得られれば、新しいドライバ
に取りかかる準備ができたことになります。

<!--
<sect> Directory Tree Structure <p>
-->
<sect> ディレクトリ構造 <p>
<!--
Here is an outline of the directory tree structure for the source tree.
Only directories/files that are relevant to writing a driver are presented.
The structure for the Link Kit is presented below.
-->
ここではソースのディレクトリ構造の概要を説明します。
ドライバの作成に関連するディレクトリ／ファイルだけを示しています。
リンクキットの構造は以降で示します。

<descrip>
<tag>xc/config/cf/</tag>
	<descrip>
	<tag>site.def</tag>
<!--
		Local configuration customization
-->
                ローカルな構成のカスタマイズ
	<tag>xf86site.def</tag>
<!--
		XFree86 local configuration customization
-->
                XFree86 のローカルな構成のカスタマイズ

	<p>
	&lsqb;訳注: 最近は xf86site.def を直接編集するより
	     host.def というファイルに内容をコピーして、それを
	     編集する方法が推奨されているようです。&rsqb;
	</descrip>

<tag>xc/programs/Xserver/hw/xfree86/</tag>
<!--
	The server source
-->
        サーバのソース
	<descrip>
	<tag>common/</tag>
<!--
			Files common to all of the server (XF86Config
				parser, I/O device handlers, etc)
-->
                        全サーバに共通なファイル (XF86Config のパラメータ
                                解析/パーサ, I/O デバイスハンドラ等)
		<descrip>
		<tag>xf86.h</tag>
<!--
			Contains the `ScrnInfoRec' data structure
-->
                        `ScrnInfoRec' データ構造を含む
		<tag>xf86_Option.h</tag>
<!--
			Contains option flags
-->
                        オプションフラグを含む
		<tag>compiler.h</tag>
<!--
			Contains in-line assembler macros and
				utility functions
-->
                        インラインアセンブラマクロと
                                ユーティリティ関数を含む
		</descrip>
<!--
	<tag>os-support/</tag>		OS-support layer
-->
        <tag>os-support/</tag>          OS サポート層
		<descrip>
		<tag>assyntax.h</tag>
<!--
			Contains macro-ized assembler mnemonics
-->
                        マクロ化したアセンブラニモニックを含む
		<tag>xf86_OSlib.h</tag>
<!--
			OS-support includes, defines, and prototypes
-->
                        OS がサポートする include, define と プロトタイプ
		</descrip>
	<tag>LinkKit/</tag>
		<descrip>
		<tag>site.def.LK</tag>
<!--
			Template for Link Kit site.def
-->
                        リンクキットの site.def 用のテンプレート
		</descrip>
<!--
	<tag>vga256/</tag>			256-color VGA server directories
-->
        <tag>vga256/</tag>                      256 色 VGA サーバのディレクトリ
		<descrip>
		<tag>vga/</tag>
<!--
				The generic VGA handling code
-->
                                generic な VGA を取り扱うプログラム
			<descrip>
			<tag>vga.h</tag>
<!--
				Contains the `vgaVideoChipRec' and `vgaHWRec'
				data structures
-->
                                `vgaVideoChipRec' と `vgaHWRec' データ構造を
                                含む
			<tag>vgaHW.c</tag>
<!--
				Contains the generic-VGA-register handling
				functions <bf>vgaHWInit()</bf>,
				<bf>vgaHWSave()</bf> and 
				<bf>vgaHWRestore()</bf>.
-->
                                generic な VGA レジスタを取り扱う関数
                                <bf>vgaHWInit()</bf>,
                                <bf>vgaHWSave()</bf> と 
                                <bf>vgaHWRestore()</bf>を含む
			</descrip>
<!--
		<tag>drivers/</tag>	Contains the SVGA driver subdirectories.
-->
                <tag>drivers/</tag>SVGA ドライバのサブディレクトリを含む
<!--
				Each contains an Imakefile, a .c file for
				the driver, and a .s file for the bank-
				switching functions.
-->
                                各々、ドライバ用 Imakefile, .c ファイルと
                                バンク切り替え関数用の .s ファイルを含む
		</descrip>
	<tag>vga2/</tag>
<!--
				The monochrome vga server directories.  Most of
				the files are linked from vga256, and the
				differences handled by conditional compilation.
-->
                                モノクロの vga サーバのディレクトリ。vga256 に
                                リンクするファイルと条件コンパイルで使用する差分
		<descrip>
		<tag>drivers/</tag>
<!--
				The SVGA driver subdirectories.  The `generic'
				VGA driver is also located here.
-->
                                SVGA ドライバのサブディレクトリ。`generic' な VGA
                                ドライバもここに配置する
		</descrip>
	<tag>vga16/</tag>
<!--
				The 16-color vga server directories.  Most of
				the files are linked from vga256, and the
				differences handled by conditional compilation.
-->
                                16 色 vga サーバのディレクトリ。vga256 
                                にリンクする殆どのファイルと条件コンパイルで
                                使用する差分
		<descrip>
<!--
		<tag>drivers/</tag>	The SVGA driver subdirectories.
-->
                <tag>drivers/</tag>     SVGA ドライバのサブディレクトリ
		</descrip>
<!--
	<tag>VGADriverDoc/</tag>		This documentation and the stub driver.
-->
        <tag>VGADriverDoc/</tag>この文書とスタブドライバ
	</descrip>
</descrip>
<!--
The Link Kit is usually installed in /usr/X11R6/lib/Server.
The Link Kit
contains everything that is needed to relink the server.  It is possible
to write a new driver and build a new server without having even the server
source installed.
-->
リンクキットは通常 /usr/X11R6/lib/Server に導入します。
リンクキットにはサーバを再リンクするために必要なものがすべて含まれています。
サーバのソースを導入しなくても、新しいドライバを作成し、新しいサーバを
生成することが可能です。
<descrip>
<tag>Server/</tag>
	<descrip>
	<tag>site.def</tag>
<!--
		Local configuration customization
-->
                ローカルな構成のカスタマイズ
	<tag>include/</tag>
<!--
		All of the include files listed under the
		`common' directory above
-->
                上記 `common' ディレクトリ下にある全ての include ファイル
	<tag>drivers/</tag>
<!--
		All of the SVGA drivers
-->
                すべての SVGA ドライバ
		<descrip>
<!--
		<tag>vga2/</tag> The SVGA driver subdirectories.
		<tag>vga16/</tag> The SVGA driver subdirectories.
		<tag>vga256/</tag> The SVGA driver subdirectories.
-->
		<tag>vga2/</tag> SVGA ドライバのサブディレクトリ
		<tag>vga16/</tag> SVGA ドライバのサブディレクトリ
		<tag>vga256/</tag> SVGA ドライバのサブディレクトリ
		</descrip>
<!--
	<tag>VGADriverDoc/</tag>		The directory with this documentation and
				the stub driver.  `vgaHW.c' is also copied
				here, for reference (it is not built as
				part of the Link Kit).
-->
        <tag>VGADriverDoc/</tag>この文書とスタブドライバのディレクトリ
                                参考のために `vgaHW.c' もここにコピーされます
                                 (リンクキットの一部としては生成しません)
	</descrip>
</descrip>
	
<!--
<sect> Setting Up The Build Information <p>
-->
<sect> 生成情報の設定 <p>
<!--
  This section describes the peripheral configuration and build steps that
must be performed to set up for your new driver.  The steps are the same
whether you are building from the source tree of from the Link Kit; only
the locations of the files is different.  Here are the configuration steps
that must be followed:
-->
この節では新しいドライバの設定に必要な周辺の構成変更と生成手順に
ついて説明します。この手順はソースから生成するかリンクキットから
生成するかにかかわらず同様で、ただファイルの配置が異なっているだけ
のことです。以下に必要な構成変更について説明します:

<enum>
<!--
<item>	 Choose the name for your driver subdirectory and data structures.
	   Since the current driver scheme allows (in fact, encourages)
	   putting drivers for multiple related chipsets in a single driver,
	   it is usually best to use the vendor name, rather than a chipset
	   version.  The fact that older XFree86 drivers do not follow this
	   convention should not deter you from using it now - most of that
	   code was developed before the driver interface had been made
	   flexible and extensible.
-->
<item> ドライバのためのサブディレクトリ名とデータ構造を決定して下さい。
           現在のドライバー体系では、単一のドライバ内に関連する複数の
           チップセットのためのドライバを実装することが可能であるため
	    (実際にはそうすることが奨励されています) 通常チップセット
	   のバージョンよりベンダー名を使用するほうが良いでしょう。
           たしかに古い XFree86 のドライバはこの規定に従っていませんが、
           そのことはこれから開発するドライバーが規定に従わなくて良いと
	   いう理由にはなりません。それらの古いコードのほとんどは、
	   ドライバのインターフェースが現在のように柔軟かつ拡張可能に
	   なる前に開発されたものです。

<!--
	   For this documentation, we'll use chips from the SuperDuper Chips
	   vendor.  Hence, we'll use `sdc' for the name of the driver.
-->
           この文書では SuperDuper Chips というベンダーのチップを
           例に取り挙げます。以降、ドライバの名称に `sdc' を用います。

<!--
<item>	 Decide whether your driver will support the color server, the
	   monochrome server, or both.  For this documentation, we will
	   assume that both the color and monochrome servers will be
	   supported.  If you intend to support only the color server, the
	   steps for the monochrome server can be ignored.  If you intend
	   to support only the monochrome server, the steps for the color
	   server listed should be performed for the monochrome server,
	   and the monochrome steps ignored.  Most of the existing drivers
	   support only the color or both servers; the ``generic'' driver is
	   the only driver (currently) that supports just the monochrome
	   server.
-->
<item>     サポート対象をカラーサーバ、モノクロサーバ、または両方、
           のどれにするか決めてください。この文書では、カラーと
	   モノクロ両方のサーバをサポートするものと仮定しています。
           カラーサーバだけをサポートする場合、モノクロサーバを実現
           するための段階は無視してかまいません。モノクロサーバだけ
           をサポートする場合は、カラーサーバのために記述されている
	   段階をモノクロサーバのために実行し、モノクロサーバのため
	   の段階は無視してください。
           既存のドライバはほとんどがカラーのみか、または両方の
           サーバをサポートしています。``generic'' ドライバは
	    (現時点で) モノクロサーバのみをサポートする唯一の
	    ドライバーです。

<!--
<item>	 Create your driver directories:
-->
<item>ドライバのディレクトリを作成してください:

	 <itemize>
<!--
	 <item>If you are working in the source tree, create the
		  following directories:
-->
         <item>ソースから作業する場合は、次のディレクトリを作成
                してください:

<verb>
   xc/programs/Xserver/hw/xfree86/vga256/drivers/sdc
   xc/programs/Xserver/hw/xfree86/vga16/drivers/sdc
   xc/programs/Xserver/hw/xfree86/vga2/drivers/sdc
</verb>

<!--
	<item>If you are working in the Link Kit, create the
		  following directories:
-->
        <item>リンクキットから作業する場合は次のディレクトリを
                作成してください:
			
<verb>
   /usr/X11R6/lib/Server/drivers/vga256/sdc
   /usr/X11R6/lib/Server/drivers/vga16/sdc
   /usr/X11R6/lib/Server/drivers/vga2/sdc
</verb>
	 </itemize>

<!--
<item>	 Set up the Imakefile parameters to cause your driver to be
	   built:
-->
<item>ドライバを生成する為の Imakefile パラメタを設定しましょう:

	 <itemize>
<!--
	 <item>If you are working in the source tree:
-->
         <item>ソースから作業するなら:
		   <enum>
<!--
		   <item>Edit the file xc/config/cf/xfree86.cf,
			   and add 
			   `sdc' to the list for the definitions for 
			   `XF86Vga256Drivers', `XF86Vga16Drivers' and
			   `XF86Vga2Drivers'.
			   You should put `sdc' just before `generic' in the
			   list (i.e. second last), to ensure that none of the
			   other driver's probe functions incorrectly detect
			   the `sdc' chipset .
-->
                   <item>xc/config/cf/xfree86.cf を編集して `sdc' を
                           `XF86Vga256Drivers', `XF86Vga16Drivers' と
                           `XF86Vga2Drivers' の定義の一覧に追加してください。
                           一覧の `generic' の直前 (例えば最後から二番目) に
                           `sdc' を追加し、他のドライバの探査によって誤って
                           `sdc' チップセットが検知されないかどうか確認する
			   ようにしてください。
<!--
		   <item>Edit the file xc/config/cf/xf86site.def,
			   and add
			   the same entries in this file (this is just a
			   comment that shows the default values).
-->
                   <item>xc/config/cf/xf86site.def を編集してこのファイル
                           にも同じ項目を追加してください (これは標準値を
                           示す単なるコメントです)。
<!--
		   <item>Edit the site.def.LK file in
			   xc/programs/Xserver/hw/xfree86/LinkKit/,
			   and add the same entries in this file.  This is
			   the prototype `site.def' file that will be
			   installed in the Link Kit.
-->
                   <item>xc/programs/Xserver/hw/xfree86/LinkKit/ にある
                           site.def.LK ファイルを編集してこのファイルに同じ項目
                           を追加してください。これはリンクキットの中に含まれる
                           `site.def' ファイルの雛型です。
		   </enum>
		
<!--
	<item>If you are working in the Link Kit, edit the file
		  /usr/X11R6/lib/Server/site.def, and add `sdc' to
		  the `XF86Vga256Drivers', `XF86Vga16Drivers' and
		  `XF86Vga2Drivers' definitions as described in (a) above.
-->
        <item>リンクキットから作業をするなら、/usr/X11R6/lib/Server/site.def
                  を編集して`sdc' を `XF86Vga256Drivers', `XF86Vga16Drivers' 
                  と `XF86Vga2Drivers' の定義に最初に書いた様に
		  追加してください。
	 </itemize>
<!--
<item>	 Now copy the prototype files into your new directories:
-->
<item>さて新しいディレクトリに雛型のファイルをコピーしましょう:
	 <itemize>
<!--
	 <item>If you are working in the source tree, copy the `stub' 
		  files as follows (directories are below xc/programs/Xserver):
-->
         <item>ソースから作業するなら、`stub' ファイルを次のようにコピー
                してください (ディレクトリは xc/programs/Xserver の下です):
		<descrip>
		<tag>Imakefile.stub =&gt;</tag>
		    hw/xfree86/vga256/drivers/sdc/Imakefile
	 	<tag>stub_driver.c =&gt;</tag>
	  	    hw/xfree86/vga256/drivers/sdc/sdc_driver.c
		<tag>stub_bank.s =&gt;</tag>
	  	    hw/xfree86/vga256/drivers/sdc/sdc_bank.s
		<tag>Imakefile.stub =&gt;</tag>
		    hw/xfree86/vga16/drivers/sdc/Imakefile
<!--
		      (then edit this Imakefile and make the changes
		       described in the comments).
-->
                      (そしてこの Imakefile を編集し、コメントに従って
                       変更してください)
		<tag>Imakefile.stub =&gt;</tag>
		    hw/xfree86/vga2/drivers/sdc/Imakefile
<!--
		      (then edit this Imakefile and make the changes
		       described in the comments).
-->
                      (そしてこの Imakefile を編集し、コメントに従って
                       変更してください)
		</descrip>
<!--
	  <item>If you are working in the Link Kit, copy the `stub' files
		  as follows:
-->
         <item>リンクキットから作業するなら、`stub' ファイルを次のよう
            にコピーしてください:
		<descrip>
		<tag>Imakefile.stub =&gt; </tag>
		  /usr/X11R6/lib/Server/drivers/vga256/sdc/Imakefile
		<tag>stub_driver.c =&gt; </tag>
		  /usr/X11R6/lib/Server/drivers/vga256/sdc/sdc_driver.c
		<tag>stub_bank.s =&gt; </tag>
		  /usr/X11R6/lib/Server/drivers/vga256/sdc/sdc_bank.s
		<tag>Imakefile.stub =&gt; </tag>
		  /usr/X11R6/lib/Server/drivers/vga16/sdc/Imakefile
<!--
		     (then edit this Imakefile and make the changes
		      described in the comments).
-->
                      (そしてこの Imakefile を編集し、コメントに従って
                       変更してください)
		<tag>Imakefile.stub =&gt; </tag>
		  /usr/X11R6/lib/Server/drivers/vga2/sdc/Imakefile
<!--
		     (then edit this Imakefile and make the changes
		      described in the comments).
-->
                      (そしてこの Imakefile を編集し、コメントに従って
                       変更してください)
		</descrip>
	 </itemize>
<!--
<item>	 Edit each of the files you've just copied, and replace `stub'
	   with `sdc' and `STUB' with `SDC' wherever they appear.
-->
<item>たった今コピーした各々のファイルを編集して `stub' を `sdc' に、
   `STUB' を `SDC' にすべて置き換えてください。
</enum>
<!--
That's all the prep work needed.  Now it's time to work on the actual driver.
-->
必要な準備作業は以上です。これで実際のドライバを作成する作業ができます。

<!--				
<sect> The Bank-Switching Functions <p>
-->
<sect> バンク切り替え機能 <p>
<!--
The normal VGA memory map is 64k starting at address 0xA0000.  To access
more than 64k of memory, SuperVGA chipsets implement ``bank switching'' - 
the high-order address bits are used to select the bank of memory in which
operations will take place.  The size and number of these banks varies,
and will be spelled out in the chipset documentation.  A chipset will
have zero, one or two bank registers.  Likely the ONLY case of zero bank
registers is a generic VGA, and hence is not a concern.
-->
普通の VGA メモリマップは 0xA0000 から始まる 64k です。64k より
大きなメモリにアクセスするための機構として、SuperVGA チップセット
は ``バンク切り替え機能 (bank switching)'' - 高位のアドレスビット
により画像操作を行うメモリバンクを選択する機能を実装しています。
バンクのサイズと数はチップセットによりさまざまであり、詳細は
それぞれのチップセットに関する資料に記載されています。
チップセットの持つバンクレジスタの数は 0, 1, 2 のいずれかです。
バンクレジスタなしの場合はたぶん generic な VGA *だけ* なので、
ここでは関係ありません。

<!--
Note that some of the newer chipsets (e.g. Trident 8900CL, Cirrus) allow
for a linear mapping of the video memory.  While using such a scheme would
improve the performance of the server, it is not currently supported.  Hence
there is no way to use such features for a new chipset.
-->
新しいチップセット (例えば Trident 8900CL や Cirrus 製チップなど) は
ビデオメモリをリニアに割り当てる事が可能であることに注意してください。
この仕組を使うことによってサーバの性能を向上できますが、現在ではまた
この機能のサポートはありません。従って、新しいチップセットについても
この機能を活用できる方法はまだありません。
<p>
&lsqb;訳注: 例えば C&amp;T や Trident などのアクセラレータに
対応している SVGA ドライバーは PCI バス上のチップについて
リニアアドレスの使用が標準となっています。もし興味があるなら、
既存のコードを調べてみると良いでしょう。&rsqb;

<!--
Most SVGA chipsets have two bank registers.  This is the most desirable 
structure (if any banking structure can be called ``desirable''), because 
data can be moved from one area of the screen to another with a simple 
`mov' instruction.  There are two forms of dual-banking - one where the 
two bank operations define a read-only bank and a write-only bank, and
one with two read/write windows.  With the first form, the entire SVGA
memory window is used for both read a write operations, and the two
bank registers determine which bank is actually used (e.g. ET3000, ET4000).
With the second form, the SVGA memory window is split into two read/write
banks, with each bank pointer being used to control one window.  In
this case, one window is used for read operations and the other for write
operations (e.g. PVGA1/Western Digital, Cirrus).
-->
ほとんどの SVGA チップセットは二つのバンクレジスタを持っています。
データを画面のある領域から他の領域に単純な 'mov' 命令で移動できるため
最も望ましい構造です (もしバンク構造に ``望ましい'' と呼べるものが
存在するなら、ですが)。
二重化バンキング (dual-banking) には二つの方式があり、一方は
二つのバンク操作により読み込み専用バンクと書き込み専用バンクを定義する
もので、もう一方は二つの書き込み／読み込み兼用窓を持つ方式です。
最初の方式は SVGA メモリ窓全体を読み込みと書き込みの両方に使い、
二つのバンクレジスタによってどちらのバンクを実際に使うかを指定します。
 (例: ET3000, ET4000) 
二番目の方式では SVGA メモリ窓を読み込み／書き込み可能な二つのバンクに
分配し、それぞれのバンクポインタが一つの窓を制御します。
この場合には一つの窓が読み込み操作に使用され、他の窓が書き込み操作に
使用されます。 (例: PVGA1/Western Digital, Cirrus)

<!--
A chipset that has a single bank register uses that one bank for both
read and write access.  This is problematic, because copying information
from one part of the screen to another requires that the data be read in,
stored, and then written out.  Fortunately, the server is able to handle
both one-bank and two-bank chipsets; the determination of behavior is
defined by an entry in the driver data structure described below.
-->
単一のバンクレジスタを持つチップセットは、その一つのバンクを
読み込みと書き出しの両方に使用します。画面のある部分の情報を
他の部分へとコピーするには、データを読み込み、蓄え、それから
書き出すという手順が要求されるため、この方式はあまり好ましい
ものではありません。幸運にも、チップセットの持つバンク数が
一つでも二つでも、サーバーは問題無く扱うことができます。
次に説明するドライバデータ構造中の項目を定義することによって
その挙動が決まります。

<!--
A driver requires that three assembly-language functions be written, in
the file `<tt>sdc_bank.s</tt>'.
These functions set the read bank - <bf>SDCSetRead()</bf>,
the write bank - <bf>SDCSetWrite()</bf>, and set both banks -
<bf>SDCSetReadWrite()</bf>.
For a chipset with only one bank, all three will be declared as entry points
to the same function (see the ``tvga8900'' driver for an example).
-->
ドライバを動作させるにはまず `<tt>sdc_bank.s</tt>' ファイル内に
三つの関数をアセンブラ言語で書く必要があります。
これらの関数は、バンク読み込み設定 - <bf>SDCSetRead()</bf>,
バンク書き出し設定 - <bf>SDCSetWrite()</bf> と 両バンク設定 -
<bf>SDCSetReadWrite()</bf> です。
一つのバンクしか持たないチップセットの場合は、三つの関数すべてを
同じ関数へのエントリーポイントとして宣言できるでしょう。
 (``tvga8900'' ドライバを例として参照してください)
<p>
&lsqb;訳注: 3.3.3.1 の場合 vga256/drivers/tvga8900/bank.s の最初
に書いてある TVGA8900{SetReadWrite,SetRead,SetWrite} の 3 つが
同じ関数に対するエントリーポイントとして書かれています。
なお i386Architecture 以外は bankc.c が使われますが、こちらは
ここで説明している例とは異なります。 (そもそも C で書かれてます)
i386Architecture 以外の環境でドライバーを開発しようとする人は
注意して下さい。 &rsqb;

<!--
The functions are fairly simple - the bank number is passed to the function
in register &percnt;al.  The function will shift, bitmask, etc - whatever is 
required to put the bank number into the correct form - and then write
it to the correct I/O port.  For chipsets where the two banks are read-only
HERE
and write-only, the <bf>SetReadWrite()</bf> function will have to do this twice - once 
for each bank.  For chipsets with two independent read/write windows, the
<bf>SetReadWrite()</bf> function should use the same bank as the <bf>SetWrite()</bf> function.
-->
これらの関数はとても単純なものです - バンク番号が関数の &percnt;al 
レジスタへ渡されるので、その値に対してシフトやビットマスクなど、
バンク番号を正しい形式に変換するための操作を実行した後、
適切な I/O ポートへその値を書き出します。
二つのバンクが同時に読み込み専用になったり書き出し専用になったりする
チップセットの場合、 <bf>SetReadWrite()</bf>関数はそれぞれのバンクに
対して一回づつ、計二回上記の動作を実行する必要があります。
二つの独立な読み込み／書き出し窓を持つチップセットの場合、
<bf>SetReadWrite()</bf> 関数は <bf>SetWrite()</bf> 関数が使うのと
同じバンクを使用します。

<!--
A special note - these functions MUST be written in the macroized assembler
format defined in the header file ``assyntax.h''.  This will ensure that
the correct assembler code will be generated, regardless of OS.  This
macroized format currently supports USL, GNU, and Intel assembler formats.
-->
特別な注意として、これらの関数は ``assyntax.h'' ファイルで
定義されているマクロアセンブラの書式で書く必要があります。
これは OS に関係な
く正しいアセンブラコードを生成することを保証する為です。現在、この
マクロ形式は USL, GNU と インテルのアセンブラの書式をサポートしてい
ます。

<!--
That's all there is to the banking functions.  Usually the chipset reference
will give examples of this code; if not, it is not difficult to figure out,
especially using the other drivers as examples.
-->
以上がバンク機能に関する作業です。普通、チップセットに関する資料が
このプログラムの例題を掲載していますが、そうでない場合でも他のドライバを
例にとれば理解することは難しくはありません。

<!--
<sect> The Driver Itself <p>
-->
<sect> ドライバ自身について <p>
<!--
  Now it's time to get down to the real work - writing the major driver
functions in the files sdc_driver.c.  First, an overview of what the
responsibilities of the driver are:
-->
さて本来の作業、つまりドライバの主要な機能を sdc_driver.c ファイル
に書く作業に取りかかりましょう。まず、ドライバが提供しなければいけない
機能の概要は次のとおりです:

<enum>
<!--
<item>	   Provide a chipset-descriptor data structure to the server.  This
	   data structure contains pointers to the driver functions and
	   some data-structure initialization as well.
-->
<item>     チップセット記述子のデータ構造をサーバに提供します。
           このデータ構造にはドライバ関数へのポインタに加えて
           いくつかのデータ構造に対する初期値も含まれます。
<!--
<item>	   Provide a driver-local data structure to hold the contents of
	   the chipset registers.  This data structure will contain a 
	   generic part and a driver-specific part.  It is used to save the
	   initial chipset state, and is initialized by the driver to put
	   the chipset into different modes.
-->
<item>     チップセットのレジスタ内容を保持するためにドライバ内部で
           使用するデータ構造を提供します。このデータ構造には一般的な
           部分とドライバ固有の部分があります。これはチップセットの
           初期状態を保存するために使用され、またチップセットの
	   表示モードを変更するためにドライバーによって初期化されます。
<!--
<item>	   Provide an identification function that the server will call to
	   list the chipsets that the driver is capable of supporting.
-->
<item>     ドライバがサポートしているチップセットの一覧を呼び出すために
           サーバが使う識別機能を提供します。
<!--
<item>	   Provide a probe function that will identify this chipset as
	   different from all others, and return a positive response if
	   the chipset this driver supports is installed, and a negative
	   response otherwise.
-->
<item>     ドライバがサポートしているチップセットがインストールされていれば、
           そのチップセットを他のチップセットと異なるものとして認識し
	   プラスの値を返すが、そうでなければマイナスの値を返すという
	   探査機能を提供します。
<!--
<item>	   Provide a function to select dot-clocks available on the board.
-->
<item>     そのボードで使用可能なドットクロックを選択する機能を提供します。
<!--
<item>	   Provide functions to save, restore, and initialize the driver-
	   local data structure.
-->
<item>     ドライバ内部で使用するデータ構造の保存、回復、初期化機能を
           提供します。
<!--
<item>	   Provide a function to set the starting address for display in
	   the video memory.  This implements the virtual-screen for the
	   server.
-->
<item>     ビデオメモリ内にディスプレイの開始アドレスを設定する機能を提供します。
	   これはサーバが仮想スクリーンを実現するために必要な機能です。
<!--
<item>	   Perhaps provide a function for use during VT-switching.
-->
<item>     たぶん VT 切り替えを行うための機能を提供したほうが良いでしょう。
<!--
<item>	   Perhaps provide a function to check if each mode is suitable for
	   the chipset being used.
-->
<item>     指定された各モードがそのチップセットの使用するモードとして
           ふさわしいかどうかチェックする機能を提供したほうが良いでしょう。
</enum>

<!--
Before stepping through the driver file in detail, here are some important
issues:
-->
ドライバファイルの具体的な中身に踏み込んでいく前に知っておくべき、
重要な情報がここにあります:

<enum>
<!--
<item>	   If your driver supports both the color and monochrome servers,
	   you should take care of both cases in the same file.  Most things
	   are the same - you can differentiate between the two with the
	   MONOVGA <tt>&num;define</tt>.  If the 16 color server is supported,
	   code specific to it can be enabled with the XF86VGA16
	   <tt>&num;define</tt>.  In most cases  it is sufficient to put
	   the following near the top of the stub_driver.c file:
-->
<item>     ドライバがカラーとモノクロサーバの両方をサポートする場合、
           一つのファイルに両方の場合のコードが含まれていることに
           注意してください。これらはほとんど同じものですが、MONOVGA を 
           <tt>&num;define</tt> してある所で両者を区別することが出来ます。
           16 色サーバをサポートする場合、このサーバーに固有のコードは
           XF86VGA16 の <tt>&num;define</tt> によって有効化されるように
           してください。ほとんどの場合、次の指定を stub_driver.c ファイル
           の先頭近くに置いておけば充分です。

<verb>
   #ifdef XF86VGA16
   #define MONOVGA
   #endif
</verb>

<!--
<item>	   The color server uses the SVGA's 8-bit packed-pixel mode.  The
	   monochrome and vga16 servers uses the VGA's 16-color mode
	   (4 bit-planes).  Only one plane is enabled for the monochrome
	   server.
-->
<item>     カラーサーバは SVGA の 8-ビットパックトピクセルモード
           を使用します。モノクロと vga16 サーバは VGA の 16-色モード
           （4 ビットプレーン）を使用します。モノクロサーバでは
            1 プレーンだけ使用します。<newline>
           &lsqb; 訳注 : パックトピクセル： 1 ドットのピクセル（画面上の点）
           を表現するのに、連続した 8 ビットを 4 つ並べて表わす方式。
           4 ビットプレーン： 1 ドットを表わすのに、それぞれの色毎にプ
           レーンを持ち各プレーン上の連続しない 8 ビット 4 つを使って
           表わす方式。&rsqb;
<!--
<item>	   It is possible for you to define your monochrome driver so that
	   no bank-switching is done.  This is not particularly desirable,
	   as it yields only 64k of viewing area.
-->
<item>     モノクロサーバをバンク切り替えを使わないように定義することが
           可能です。これは表示領域のメモリをたった 64k しか使えないため、
           あまり魅力的ではありません。
</enum>
<!--
Keeping these things in mind, you need to find the registers from your
SVGA chipset that control the desired features.  In particular, registers
that control:
-->
これらのことを踏まえて、自分の使う SVGA チップセットの中で所定の機能を
制御するレジスタを探す必要があります。
特に、以下の項目を制御できるレジスタは重要です：
<enum>
<!--
<item>	   Clock select bits.  The two low-order bits are part of the
	   standard Miscellaneous Output Register; most SVGA chipsets
	   will include 1 or 2 more bits, allowing the use of 8 or 16
	   discrete clocks.
-->
<item>     クロック選択ビット。低位の 2 ビットは標準 Misc 出力レジスタ
           (Miscellaneous Output Register) の一部です。ほとんどの SVGA
	   チップセットはこれに加えてさらに 1 あるいは 2 ビットを備えて
	   おり、これによって 8 または 16 の離散的なクロック値を使用
	   できます。
	   &lsqb; 訳注：最近のチップではプログラマブルクロックを使用する
	   ことが一般的になっているようです。詳細は既存のコードを参照。 &rsqb;
<!--
<item>	   Bank selection.  The SVGA chipset will have one or two registers
	   that control read/write bank selection.
-->
<item>     バンク選択。SVGA チップセットは読み書きするバンクの選択を
           制御するためのレジスタを一つか二つ持っているでしょう。
<!--
<item>	   CRTC extensions.  The standard VGA registers don't have enough
	   bits to address large displays.  So the SVGA chipsets have
	   extension bits.
-->
<item>     CRTC 機能拡張。標準 VGA レジスタは高解像度表示を行うのに
           十分なビット数を持っていません。
           このため SVGA チップセットは拡張ビットを持っています。
<!--
<item>	   Interlaced mode.  Standard VGA does not support interlaced
	   displays.  So the SVGA chipset will have a bit somewhere to
	   control interlaced mode.  Some chipsets require additional
	   registers to be set up to control interlaced mode
-->
<item>     インターレースモード。標準 VGA はインターレース表示
           をサポートしていません。このため SVGA チップセットは
           インターレースモードを制御するビットをどこかに持っています。
           ある種のチップセットではインターレースモードを制御するために
           独自に追加されたレジスタを設定しなければなりません。
<!--
<item>	   Starting address.  The standard VGA only has 16 bits in which
	   to specify the starting address for the display.  This restricts
	   the screen size usable by the virtual screen feature.  The SVGA
	   chipset will usually provide one or more extension bits.
-->
<item>     開始アドレス。標準 VGA では表示用メモリの開始アドレスを指定するために
           16 ビットしか使えません。これは仮想スクリーン機能で使う画面サイズ
           (解像度) を制限します。SVGA チップセットは通常一つかそれ以上の
           拡張ビットを持っています。
<!--
<item>	   Lock registers.  Many SVGA chipset prevent modification of
	   extended registers unless the registers are first ``unlocked''.
	   You will need to disable protection of any registers you will
	   need for other purposes.
-->
<item>     レジスタロック。多くの SVGA チップセットではレジスタを最初に
           ``unlocked'' にしない限り拡張レジスタの内容を変更できません。
           レジスタの内容を変更したい場合には、まずこの保護を無効にする
	   ことが必要です。
<!--
<item>	   Any other facilities.  Some chipset may, for example, require
	   that certain bits be set before you can access extended VGA
	   memory (beyond the IBM-standard 256k).  Or other facilities;
	   read through all of the extended register descriptions and see
	   if anything important leaps out at you.
-->
<item>     その他の機能。例えば、ある種のチップセットでは拡張 VGA メモリ
           （IBM-標準の 265k を超える）にアクセスするために、前もって
           特定のビットを設定しておく必要があります。あるいは他にも
	   なにか必要な機能があるかもしれません。
	   各レジスタの詳細な説明をすべて読み通して、何か重要な機能が
	   記載されていないかどうか、ちゃんとチェックしておきましょう。
</enum>

<!--
If you are fortunate, the chipset vendor will include in the databook some
tables of register settings for various BIOS modes.  You can learn a lot
about what manipulations you must do by looking at the various BIOS modes.
-->
運がよければ、チップセットのベンダーがデータブックに様々な BIOS モード用の
レジスタ設定表を掲載してくれているでしょう。この表をじっくり見てそれぞれの
BIOS モードを調べることによって、どんな操作をしなければならないかについて
多くのことを学ぶことが出来ます。

<!--
<sect1> Multiple Chipsets And Options <p>
-->
<sect1> 複数のチップセットとオプション <p>
<!--
It is possible, and in fact desirable, to have a single driver support
multiple chipsets from the same vendor.  If there are multiple supported
chipsets, then you would have a series of &num;define's for them, and a
variable `SDCchipset', which would be used throughout the driver when
distinctions must be made.  See the Trident and PVGA1/WD drivers for
examples (the Tseng ET3000 and ET4000 are counter-examples - these were
implemented before the driver interface allowed for multiple chipsets, so
this example should NOT be followed).  Note that you should only distinguish
versions when your driver needs to do things differently for them.  For
example, suppose the SDC driver supports the SDC-1a, SDC-1b, and SDC-2
chipsets.  The -1a and -1b are essentially the same, but different from the
-2 chipset.  Your driver should support the -1 and -2 chipsets, and not
distinguish between the -1a and -1b.  This will simplify things for the
end user.
-->
同じベンダーから出荷している複数のチップセットを単一のドライバで
サポートすることが可能であり、むしろ望ましいとされています。
複数のチップセットをサポートする場合、それらに対応する一連の
&num;define と、ドライバコード中でチップセットの識別が必要な時に
使用する`SDCchipset' 変数を用意することになるでしょう。
具体的な例としては Trident と PVGA1/WD を参照してください
（Tseng ET3000 と ET4000 はこれに沿っていない例です。
これらのコードは複数のチップセットをサポートするための
ドライバインターフェースが開発される前に実装されたものであり、
現在ではこのような実装方法に従うべきではありません。)
ドライバーがチップセットのバージョンを区別して認識するべきなのは、
それらが互いに異なる扱いを必要とする場合だけであることに注意して
ください。例えば、SDC ドライバが SDC-1a,SDC-1b および SDC-2 と
いうチップセットをサポートしているとしましょう。さらにこのとき、
チップセット -1a と-1b は実質的に同じものであり、-2 は異なるもの
だとします。このような場合には、ドライバーコードは -1 と -2 の
2 種類のチップセットとしてサポートするべきであり、 -1a と -1b を
区別するべきではありません。これによってエンドユーサの設定作業も
単純になることでしょう。

<!--
In cases where you want to give the user control of driver behavior, or
there are things that cannot be determined without user intervention, you
should use ``option'' flags.  Say that board vendors that use the SDC 
chipsets have the option of providing 8 or 16 clocks.  There's no way you 
can determine this from the chipset probe, so you provide an option flag to 
let the user select the behavior from the XF86Config file.  The option flags
are defined in the file ``xf86_option.h''.  You should look to see if there is 
already a flag that can be reused.  If so, use it in your driver.  If not, 
add a new &num;define, and define the string->symbol mapping in the table in 
that file.  To see how option flags are used, look at the ET4000, 
PVGA1/WD, and Trident drivers.
-->
ユーザにドライバの挙動を制御させたい場合、または何かを決定するために
ユーザによる介入を必要とする場合には、``option'' フラッグを使いましょう。
例えば SDC チップセットを使うビデオボードのベンダーが、 8 クロックに
対応するボードと 16 クロックに対応するボードを選択できるようにしていた
ならば、これらのボードをチップセットに対する探査の結果から識別する方法は
ありませんので、 option フラッグを提供し、ユーザが XF86Config ファイルを
使ってドライバの挙動を選択できるようにするべきです。
option フラッグは ``xf86_option.h'' ファイルに定義します。
再利用可能な option が既に存在していないかどうか、最初に
確認しておきましょう。もし存在する場合はそれを使ってください。
再利用可能なものが無かった場合は、新たに &num;define を追加し、
同じファイルにある「文字列->シンボル」の対応を定義するテーブル中に
追加する option フラッグで使う文字列を定義します。
option フラッグの使い方を理解するには ET4000, PVGA1/WD と Trident の
ドライバを参照してください。

<!--
<sect1> Data Structures <p>
-->
<sect1> データ構造 <p>
<!--
Once you have an understanding of what is needed from the above description,
it is time to fill in the driver data structures.  First we will deal with
the `vgaSDCRec' structure.  This data structure is the driver-local structure
that holds the SVGA state information.  The first entry in this data structure
is ALWAYS `vgaHWRec std'.  This piece holds the generic VGA portion of the
information.  After that, you will have one `unsigned char' field for each
register that will be manipulated by your driver.  That's all there is to
this data structure.
-->
上記の説明から何が必要なのか理解したら、ドライバのデータ構造を
記入する段階に進みましょう。
最初に `vgaSDCRec' の構造を作成します。このデータ構造は SVGA の
状態情報を保持するためにドライバ内部で使用するデータ構造です。
このデータ構造の最初の項目は「常に」 `vgaHWRec std' とします。
この項目は汎用 VGA に関する部分の情報を保持するためのものです。
これに続いて、追加するドライバによって操作されるレジスタのひとつ
ひとつに対応する `unsigned char' の領域を用意してください。
これが最初のデータ構造の全てです。

<!--
Next you must initialize the `SDC' structure (type `vgaVideoChipRec').  This
is the global structure that identifies your driver to the server.  Its name
MUST be `SDC', in all caps - i.e. it must match the directory name for your
driver.  This is required so that the Link Kit reconfiguration can identify
all of the requisite directories and global data structures.
-->
次に `SDC' 構造 (`vgaVideoChipRec' 型) の初期化をしなければいけません。
これは追加するドライバをサーバに識別させるためのグローバルな構造体です。
この構造体の名称はすべて大文字で `SDC' としなければなりません。
これはつまり、追加するドライバコードの存在するディレクトリの名称と
一致させる必要がある、ということです。これはリンクキットの再構成時に
必要なディレクトリとグローバルなデータ構造をすべて認識させるための
条件です。

<!--
The first section of this structure simply holds pointers to the driver
functions.
-->
この構造体の最初の部分は単にドライバ関数へのポインタを保持しておく
ために使用されます。

<!--
Next, you must initialize the information about how your chipset does
bank switching.  The following fields must be filled in:
-->
次に、チップセットがバンク切り替えをどう扱うかについての情報を
初期化しなければなりません。次に示すような内容の領域を用意する
必要があります:

<enum>
<!--
<item>	   ChipMapSize - the amount of memory that must be mapped into
	   the server's address space.  This is almost always 64k (from
	   0xA0000 to 0xAFFFF).  Some chipsets use a 128k map (from
	   0xA0000 to 0xBFFFF).  If your chipset gives an option, use the
	   64k window, as a 128k window rules out using a Hercules or
	   Monochrome Display Adapter card with the SVGA.
-->
<item>     ChipMapSize - サーバのアドレス空間に割り付けるメモリ量。
           ほとんどの場合には 64k (0xA0000 から 0xAFFFF まで) です。
	   チップセットによっては 128k (0xA0000 から 0xBFFFF まで) 
	   を使います。もし使用するチップセットがどちらにも対応して
	   いるのなら 64k の窓を使ってください。128k の窓を使用すると
	   Hercules またはモノクロディスプレイアダプタのカードを
	   SVGA サーバーで使うことができなくなります。
<!--
<item>	   ChipSegmentSize - the size of each bank within the ChipMapSize
	   window.  This is usually also 64k, however, some chipsets split
	   the mapped window into a read portion and a write portion (for
	   example the PVGA1/Western Digital chipsets).
-->
<item>     ChipSegmentSize - ChipMapSize の窓内のバンクの大きさ。
           これもまた通常 64k ですが、チップセットによっては
           割り付けられた窓を読み込み部分と書き込み部分に分割して扱います
           （例えば PVGA1/Western Digital チップセット）。
<!--
<item>	   ChipSegmentShift - the number of bits by which an address will
	   be shifted right to mask of the bank number.  This is log-base-2
	   of ChipSegmentSize.
-->
<item>     ChipSegmentShift - バンク番号をマスクするためにアドレスを
           右シフトする際のビット数。
	   これは 2 を底にした ChipSegmentSize の対数 (log) になります。
<!--
<item>	   ChipSegmentMask - a bitmask used to mask off the address within
	   a given bank.  This is (ChipSegmentSize-1).
-->
<item>     ChipSegmentMask - 与えられたバンク内のアドレスをマスクオフ
           するときのビットマスク。これは (ChipSegmentSize-1) になります。
<!--
<item>	   ChipReadBottom,ChipReadTop - the addresses within the mapped
	   window in which read operations can be done.  Usually 0, and 
	   64k, respectively, except for those chipset that have separate
	   read and write windows.
-->
<item>     ChipReadBottom,ChipReadTop - 割り付けられた窓内で読み込み
           操作を行うためのアドレス。
           チップセットが窓を読み込み用と書き込み用に分割する
	   場合を除けば、通常はそれぞれ 0 と 64k になります。
<!--
<item>	   ChipWriteBottom,ChipWriteTop - same as above, for write operations.
-->
<item>     ChipWriteBottom,ChipWriteTop - 書き込み操作のためのもの
	   であるという点以外は、上記と同様です。
<!--
<item>	   ChipUse2Banks - a boolean value for whether this chipset has one
	   or two bank registers.  This is used to set up the screen-to-screen
	   operations properly.
-->
<item>     ChipUse2Banks - チップセットのバンクレジスタが 1 つ
           または 2 つのどちらであるかを示すブーリアン値。
           これはスクリーンからスクリーンへの操作を適切に設定するために
           使用されます。
</enum>
<!--
There are three more fields that must be filled in:
-->
これに加えてさらに 3 個の領域を用意しなければなりません:

<enum>
<!--
<item>	   ChipInterlaceType - this is either VGA_NO_DIVIDE_VERT or
	   VGA_DIVIDE_VERT.  Some chipsets require that the vertical timing
	   numbers be divided in half for interlaced modes.  Setting this
	   flag will take care of that.
-->
<item>     ChipInterlaceType - VGA_NO_DIVIDE_VERT または VGA_DIVIDE_VERT
           のどちらかになります。チップセットによってはインタレースモード
           用に垂直方向の調整数値を 2 で割ったものを必要とします。
           このフラッグを設定することによって、サーバがそれに応じた処理を
	   してくれます。
<!--
<item>	   ChipOptionFlags - this should always be `{0,}' in the data
	   structure initialization.  This is a bitfield that contains
	   the Option flags that are valid for this driver.  The appropriate 
	   bits are initialized at the end of the Probe function.
-->
<item>     ChipOptionFlags - データ構造の初期化では常に `{0,}' とします。
           これはこのドライバで有効な Option フラッグを示すビット列です。
           探査関数の終了時に適正な値に初期化されます。
<!--
<item>	   ChipRounding - this gets set to the multiple by which the
	   virtual width of the display must be rounded for the 256-color
	   server.  This value is usually 8, but may be 4 or 16 for some
	   chipsets.
-->
<item>     ChipRounding - 256 色サーバの場合、仮想スクリーンの幅は
           ここで設定した値の倍数になるよう丸められます。
           この値は通常 8 ですが、チップセットによっては 4 とか 16 に
           する場合もあります。
</enum>

<!--
<sect1> The Ident() function <p>
-->
<sect1> Ident() 関数 <p>
<!--
The <bf>Ident()</bf> function is a very simple function.  The server will call
this function repeatedly, until a NULL is returned, when printing out the
list of configured drivers.  The <bf>Ident()</bf> function should return a chipset
name for a supported chipset.  The function is passed a number which
increments from 0 on each iteration.
-->
<bf>Ident()</bf> 関数は大変単純な関数です。サーバは自分自身に
組み込まれているドライバの一覧を出力するときに、返り値が NULL に
なるまでこの関数を繰り返し呼び出します。
<bf>Ident()</bf> 関数はサポートしているチップセットのそれぞれに
ついてその名称を返さなければなりません。
この関数には繰り返して呼ばれるたびに 0 から順に 1 つずつ増加して
いく数値が渡されます。

<!--
<sect1> The ClockSelect() function <p>
-->
<sect1> ClockSelect() 関数 <p>
<!--
The <bf>ClockSelect()</bf> function is used during clock probing (i.e. when no
`Clocks' line is specified in the XF86Config file) to select the dot-clock
indicated by the number passed in the parameter.  The function should
set the chipset's clock-select bits according to the passed-in number.
Two dummy values will be passed in as well (CLK_REG_SAVE, CLK_SAVE_RESTORE).
When CLK_REG_SAVE is passed, the function should save away copies of
any registers that will be modified during clock selection.  When
CLK_REG_RESTORE is passed, the function should restore these registers.
This ensure that the clock-probing cannot corrupt registers.
-->
<bf>ClockSelect()</bf> 関数は、クロックを探査する（これはつまり、
 XF86Config ファイルで `Clocks' 行を指定しなかった場合ですが）
際に、パラメータの一部として渡された数値により指示されたドットクロックを
選択するために使用されます。この関数は、渡された数値に従ってチップセット
の clock-select ビットを設定しなければなりません。
これに加えて 2 種類のダミーとしての値 (CLK_REG_SAVE, CLK_SAVE_RESTORE) 
がこの関数に渡される場合もあります。
CLK_REG_SAVE を受け取った場合には、関数がクロックの選択中に内容を変更する
可能性のあるすべてのレジスタについて、その内容を保存しておくようにします。
CLK_REG_RESTORE を受け取った場合には、これらのレジスタについて、関数が
保存しておいた内容を回復するようにします。
これは、クロック探査によってレジスタの内容が破壊されないことを確実にする
ためのものです。

<!--
This function should return FALSE if the passed-in index value is invalid
or if the clock can't be set for some reason.
-->
渡されたインデックスが不正な値であるか、もしくは何らかの理由によって
クロックを設定できなかった場合、この関数は FALSE を返すべきです。

<!--
<sect1> The Probe() function <p>
-->
<sect1> Probe() 関数 <p>
<!--
The <bf>Probe()</bf> function is perhaps the most important, and perhaps the
least intuitive function in the driver.  The Probe function is required
to identify the chipset independent of all other chipsets.  If the user
has specified a `<tt>Chipset</tt>' line in the XF86Config file, this is a simple
string comparison check.  Otherwise, you must use some other technique
to figure out what chipset is installed.  If you are lucky, the chipset
will have an identification mechanism (ident/version registers, etc), and
this will be documented in the databook.  Otherwise, you will have to
determine some scheme, using the reference materials listed below.
-->
<bf>Probe()</bf> 関数はドライバの中で多分最も重要でかつ
最も直感的でない関数でしょう。
Probe 関数は他のすべてのチップセットを誤認識することなく、対象とする
チップセットを識別しなければなりません。もし XF86Config ファイルに 
`<tt>Chipset</tt>' 行が指定されているのなら、単純な文字列比較を実行
させるだけです。それ以外の場合には、どんなチップセットがシステムに
インストールされているか、何か別の方法で判定しなければなりません。
運がよければ、チップセットに認識機構 (識別/バージョンレジスタなど) が
用意されていて、かつそのことがデータブックに説明されているでしょう。
さもなければ、次に述べるような基準を使い、何らかの手順を決めて認識
させなければなりません。

<!--
The identification is often done by looking for particular patterns in
register, or for the existence of certain extended registers.  Or with
some boards/chipsets, the requisite information can be obtained by reading
the BIOS for certain signature strings.  The best advise is to study the
existing probe functions, and use the reference documentation.  You
must be certain that your probe is non-destructive - if you modify a
register, it must be saved before, and restored after.
-->
認識手順としてよく使われるのは、対象とするチップに固有のパターンが
レジスタ中に存在するかどうかを調べる方法、またはそのチップに固有の
拡張レジスタが存在するかどうかを調べる方法です。あるいはボードや
チップセットによっては、特定の署名文字列を BIOS から読み取ることに
よって必要な情報を入手することの可能な場合もあります。
既存の探査関数を勉強すること、および参考資料をきちんと使うことが
最善のアドバイスです。またここで追加する探査関数のコードが非破壊的な
ものであることを確認しておかなければなりません。
これは、もし探査中にレジスタの内容を変更するのであれば、
最初に元のレジスタ設定を保存しておかなければいかないこと、
そして最後に自分が保存した内容を復元しておかなければいけないことを
意味します。

<!--
Once the chipset is successfully identified, the <bf>Probe()</bf> function must
do some other initializations:
-->
うまくチップセットを認識できたら、<bf>Probe()</bf> 関数は
さらに他の部分の初期化をも行う必要があります。

<enum>
<!--
<item>	   If the user has not specified the `<tt>VideoRam</tt>' parameter in the
	   XF86Config file, the amount of installed memory must be determined.
-->
<item>     XF86Config ファイルに `<tt>VideoRam</tt>' パラメタが指定されて
           いない場合に備えて、搭載メモリ量を判定する必要があります。
<!--
<item>	   If the user has not specified the `<tt>Clocks</tt>' parameter in the
	   XF86Config file, the values for the available dot-clocks must
	   be determined.  This is done by calling the <bf>vgaGetClocks()</bf>
	   function, and passing it the number of clocks available and
	   a pointer to the <bf>ClockSelect()</bf> function.
-->
<item>     XF86Config ファイルに `<tt>Clocks</tt>' パラメタが指定されて
           いない場合に備えて、使用可能なドットクロックの値を判定する
           必要があります。
	   これは <bf>vgaGetClocks()</bf> 関数を呼び出して、
	   使用できるクロックの数と <bf>ClockSelect()</bf> 関数への
	   ポインタを渡してやることで実現できます。
<!--
<item>	   It is recommended that the `maxClock' field of the server's
	   `vga256InfoRec' structure be filled in with the maximum
	   dot-clock rate allowed for this chipset (specified in KHz).
	   If this is not filled in a probe time, a default (currently
	   90MHz) will be used.
-->
<item>     サーバの `vga256InfoRec' 構造体に用意されている `maxClock' 領域に
	   ドライバーが認識したチップセットで許容可能な最大ドットクロックを
	    (KHz 単位で) 指定しておくことをお勧めします。
           探査時にこの値を指定しなければ、標準値 (現在は 90MHz) が
           使用されます。
<!--
<item>	   The `chipset' field of the server's `vga256InfoRec' structure
	   must be initialized to the name of the installed chipset.
-->
<item>     サーバの `vga256InfoRec' 構造体に用意されている `chipset' 領域を
           搭載チップセットの名称によって初期化しなければなりません。
<!--
<item>	   If the driver will be used with the monochrome server, the
	   `bankedMono' field of the server's `vga256InfoRec' structure
	   must be set to indicate whether the monochrome driver supports
	   banking.
-->
<item>     ドライバがモノクロサーバと組み合わせて使用されるのなら、
           サーバの `vga256InfoRec' 構造体に用意されている `bankedMono' 
	   領域を適切に設定して、モノクロドライバがバンク切り替えを
           サポートしているかどうかを示さなければいけません。
<!--
<item>	   If any option flags are used by this driver, the `ChipOptionFlags' 
	   structure in the `vgaVideoChipRec' must be initialized with the 
	   allowed option flags using the <bf>OFLG_SET()</bf> macro.
-->
<item>     新しく作成するドライバーが何らかのオプションフラッグを
	   サポートする場合には、 `vgaVideoChipRec' 型として定義した
	    `SDC' 構造の中に含まれている `ChipOptionFlags' 構造体を
            <bf>OFLG_SET()</bf> マクロを用いて初期化し、使用を認める
           オプションフラッグをこの中に設定しておくことが必要です。
</enum>

<!--
<sect1> The EnterLeave() function <p>
-->
<sect1> EnterLeave() 関数 <p>
<!--
The <bf>EnterLeave()</bf> function is called whenever the virtual console on which
the server runs is entered or left (for OSs without virtual consoles, the
function is called when the server starts and again when it exits).  The
purpose of this function is to enable and disable I/O permissions (for
OSs where such is required), and to unlock and relock access to ``protected''
registers that the driver must manipulate.  It is a fairly trivial function,
and can be implemented by following the comments in the stub driver.
-->
<bf>EnterLeave()</bf> 関数はサーバを起動した仮想コンソールに入ったり
出たりする度に呼ばれます(仮想コンソール機能をもたない OS では、
この関数はまずサーバーの開始時に呼ばれ、終了時にもう一度呼ばれます)。
この関数の目的は (そうすることが必要な OS の場合に) I/O の権限を
譲渡したり剥奪したりすること、およびドライバが操作しなければならない
``保護された''レジスタへのアクセスをロック解除したり再ロックしたり
することです。
これは非常に簡単な関数であり、スタブドライバ中のコメントに書かれた
方法で実装できます。

<!--
<sect1> The Restore() function <p>
-->
<sect1> Restore() 関数 <p>
<!--
The <bf>Restore()</bf> function is used for restoring a saved video state.  Note
that `restore' is a bit of a misnomer - this function is used to both
restore a saved state and to install a new one created by the server.  The
<bf>Restore()</bf> function must complete the following actions:
-->
<bf>Restore()</bf> 関数は保存しておいたビデオ状態を回復するために
使用されます。この `restore' という名称は少しばかり誤った名称であり、
実際には保存された状態を回復するためばかりでなく、サーバが新規に
作成した状態へと移行するためにこの関数を使用することもあります。
<bf>Restore()</bf> 関数は次の動作を完全に実行しなければなりません。

<enum>
<!--
<item>	   Ensure that Bank 0 is selected, and that any other state
	   information required prior to writing out a new state has been
	   set up.
-->
<item>     バンク 0 が選択されていること、および新しい状態へ移行する前に
           必要となるその他の状態情報がすべて設定済みであることを確認します。
<!--
<item>	   Call <bf>vgaHWRestore()</bf> to restore the generic VGA portion of the
	   state information.  This function is in the vgaHW.c file.
-->
<item>     <bf>vgaHWRestore()</bf> を呼び出して状態情報の汎用 VGA 部分を
           回復させます。この関数は vgaHW.c ファイルの中で定義されています。
<!--
<item>	   Restore the chipset-specific portion of the state information.
	   This may be done by simply writing out the register, or by
	   doing a read/modify/write cycle if only certain bits are to
	   be modified.  Be sure to note the comment in the sample driver
	   about how to handle clock-select bits.
-->
<item>     状態情報のチップセットに特有部分を回復します。これは単純に
           レジスタに書き込むか、あるいはもしレジスタ中の一部のビット
           だけを変更する必要がある場合には read/modify/write 操作を
           実行します。クロック選択ビットを扱う方法について、サンプル
           ドライバ中のコメントを確認しておいてください。
</enum>
<!--
<sect1> The Save() function <p>
-->
<sect1> Save() 関数 <p>
<!--
The <bf>Save()</bf> function is used to extract the initial video state information
when the server starts.  The <bf>Save()</bf> function must complete the following
actions:
-->
<bf>Save()</bf> 関数はサーバ起動時にビデオカードの初期状態に関する情報を
取り出すために使用されます。<bf>Save()</bf> 関数は次の動作を完全に実行
しなければなりません。

<enum>
<!--
<item>	   Ensure that Bank 0 is selected.
-->
<item>     バンク 0 が選択されていることを確認します。
<!--
<item>	   Call <bf>vgaHWSave()</bf> to extract the generic VGA portion of the state
	   information.  This function is in the vgaHW.c file.
-->
<item>     <bf>vgaHWSave()</bf> を呼び出して状態情報の汎用 VGA 部分を
           取り出します。この関数は vgaHW.c ファイルの中で定義されています。
<!--
<item>	   Extract the chipset-specific portion of the state information.
-->
<item>     状態情報のチップセット特有部分を取り出す。

</enum>
<!--
<sect1> The Init() function <p>
-->
<sect1> Init() 関数 <p>
<!--
  The <bf>Init()</bf> function is the second most important function in the driver
(after the <bf>Probe()</bf> function).  It is used to initialize a data structure
for each of the defined display modes in the server.  This function is
required to initialize the entire `vgaSDCRec' data structure with the
information needed to put the SVGA chipset into the required state.  The
generic VGA portion of the structure is initialized with a call to 
<bf>vgaHWInit()</bf> (also located in vgaHW.c).
-->
<bf>Init()</bf> 関数はドライバの中で (<bf>Probe()</bf> 関数に次いで)
二番目に重要な関数です。これを使って、サーバの中に定義された各表示モードに
対するデータ構造を初期化します。この関数は `vgaSDCRec' データ構造全体を
初期化して、SVGA チップセットを目的の状態に移行させるために必要となる
情報を設定しなければなりません。このデータ構造の汎用 VGA 部分は
 (これも vgaHW.c 内にある) <bf>vgaHWInit()</bf> を呼び出して初期化します。

<!--
Once the generic portion is initialized, the <bf>Init()</bf> function can override
any of the generic register initialization, if necessary.  All of the other
fields are filled in with the correct initialization.  The information
about the particular mode being initialized is passed in the `mode'
parameter, a pointer to a `DisplayModeRec' structure.  This can be
dereferenced to determine the needed parameters.
-->
いったん汎用の部分が初期化されたら、<bf>Init()</bf> 関数は必要に応じて
汎用レジスタの中身を好きなように変更できます。その他必要な領域のすべて
に適正な初期化情報を設定します。初期化される特定のモードについての情報
は `DisplayModeRec' 構造体へのポインタである `mode' パラメタを経由して
渡されます。このポインタを辿ることで必要なパラメータを決定できます。

<!--
If you only know how to initialize certain bits of the register, do that
here, and make sure that the <bf>Restore()</bf> function does a read/modify/write
to only manipulate those bits.  Again, refer to the existing drivers
for examples of what happens in this function.
-->
レジスタの特定ビットの初期化方法だけが分かっている場合には、ここで初期化
しましょう。特定ビットだけを操作する場合には <bf>Restore()</bf> 関数を
使って read/modify/write を実行するのだということをしっかり覚えておいて
下さい。繰り返しますが、例えばこの関数の中で何が実行されるのかについて、
既存のドライバーコードを参照して調べておいてください。

<!--
<sect1> The Adjust() function <p>
-->
<sect1> Adjust() 関数 <p>
<!_-
The <bf>Adjust()</bf> function is another fairly basic function.  It is called
whenever the server needs to adjust the start of the displayed part of
the video memory, due to scrolling of the virtual screen or when changing
the displayed resolution.  All it does is set the starting address on the
chipset to match the specified coordinate.  Follow the comments in the 
stub driver for details on how to implement it.
-->
<bf>Adjust()</bf> 関数はまた別の、とても基本的な関数です。
仮想スクリーンのスクロールや表示解像度の変更によって、
サーバがビデオメモリの表示用領域の開始点を調整する必要のあるときは
いつも呼ばれます。
この関数の担当は、指定された座標に合わせてチップセットの開始アドレスを
設定することだけです。
実装方法の詳細は、スタブドライバ中のコメントを参照してください。

<!--
<sect1> The ValidMode() function <p>
-->
<sect1> ValidMode() 関数 <p>
<!--
The <bf>ValidMode()</bf> function is required.  It is used to check
for any chipset-dependent reasons why a graphics mode might not be valid.  It
gets called by higher levels of the code after the Probe() stage.  In
many cases no special checking will be required and this function will
simply return TRUE always.
-->
<bf>ValidMode()</bf> 関数は、このドライバーで扱うチップセットに固有の
事情によって、特定のグラフィックモードを使用できない場合があるかどうかを
確認するために使用されるものであり、必ず用意しなければいけません。
この関数は Probe() 実行後により上位のプログラムから呼ばれます。
多くの場合、この関数の中で特別な調査を実行する必要は無く、常に TRUE を
返すような単純なものでも充分でしょう。

<!--
<sect1> The SaveScreen() function <p>
-->
<sect1> SaveScreen() 関数 <p>
<!--
The <bf>SaveScreen()</bf> function is not needed by most chipsets.  This function
would only be required if the extended registers that your driver needs
will be modified when a synchronous reset is performed on the SVGA chipset
(your databook should tell you this).  If you do NOT need this function,
simply don't define it, and put `NoopDDA' in its place in the vgaVideoChipRec
structure initialization (NoopDDA is a generic-use empty function).
-->
<bf>SaveScreen()</bf> 関数はほとんどのチップセットでは必要ありません。
この関数が必要になるのは、 SVGA チップセット上で同期リセットが実行された時に、
ドライバの動作に必要な拡張レジスタの内容も一緒に変更されてしまうような場合です。
（このような場合、データブックに説明が記載されているはずです。)
この関数が必要 *無い* 場合には、単にこれを定義しないでおいて、
 vgaVideoChipRec 構造体を初期化する際には、この関数を指定するための
フィールドに `NoopDDA' を設定します。
（NoopDDA は汎用の中身の無い関数です）。

<!--
If you DO need this function, it is fairly simple to do.  It will be
called twice - once before the reset, and again after.  It will be passed
a parameter of SS_START in the former case, and SS_FINISH in the latter.
All that needs to be done is to save any registers that will be affected
by the reset into static variables on the SS_START call, and then restore
them on the SS_FINISH call.
-->
この関数が *必要* な場合には、やるべきことは至極単純です。
この関数は必ず二回 (一回目はリセット前、二回目はリセット後) 呼ばれます。
前者の場合には引数として SS_START が渡され、後者の場合は SS_FINISH が
渡されます。必要な作業は、 SS_START で呼び出された際にはリセットによって
影響を受けるレジスタの内容をすべて保存すること、またここで保存した内容を
次に SS_FINISH で呼び出された際に回復することです。

<!--
<sect1> The GetMode() function <p>
-->
<sect1> GetMode() 関数 <p>
<!--
The <bf>GetMode()</bf> function is not used as of XFree86 1.3; its place in the
vgaVideoChipRec should be initialized to `NoopDDA'.
-->
<bf>GetMode()</bf> 関数は XFree86 1.3 では使われていません。
vgaVideoChipRec 中に用意されているこの関数のためのフィールドは、
 `NoopDDA' を指定して初期化してください。

<!--
At some point in the future, this function will be used to enable the server
and/or a standalone program using the server's driver libraries to do 
interactive video mode adjustments.  This function will read the SVGA
registers and fill in a DisplayModeRec structure with the current video
mode.
-->
将来的には、この関数を使用することによって、サーバーおよびサーバーの
ドライバーライブラリを利用したスタンドアローンプログラム、またはその
どちらかからビデオモードを対話的に調節することが可能となる予定です。
この関数は、 SVGA レジスタを読み込み、DisplayModeRec 構造体に現在の
ビデオモードを書き出します。

&lsqb; 訳注：最新の公開版である XFree86 3.3.3.1 でも、
この <bf>GetMode()</bf>関数をまともに実装したドライバは vga256/drivers 
以下に 30種ほどあるドライバのうち、わずかに ati ドライバーだけです。
他に 2 種類ほど、中身の無い定義だけの関数を用意した例がありますが、
それ以外のドライバーでは `NoopDDA' が指定されています。
現状ではこの関数はあまり必要とされていないということなのかもしれません。 &rsqb;

<!--
<sect1> The FbInit() function <p>
-->
<sect1> FbInit() 関数 <p>
<!--
The <bf>FbInit()</bf> function is required for drivers with accelerated graphics
support.  It is used to replace default cfb.banked functions with
accelerated chip-specific versions.  vga256LowlevFuncs is a struct containing
a list of functions which can be replaced.  This struct defined in
vga256.h.  Examples of <bf>FbInit()</bf> functions can be found in the et4000,
pvga1 and cirrus drivers.
-->
<bf>FbInit()</bf> 関数はアクセラレータグラフィックスをサポートする
ドライバが必ず用意しなければならない関数です。
この関数は標準の cfb.banked 関数を、それぞれのチップに合わせた
アクセラレータ対応版の関数に置き換えるために使用されます。
 vga256LowlevFuncs は置き換え可能な関数の一覧を含む構造体です。
この構造体は vga256.h で定義されています。
<bf>FbInit()</bf> 関数の例は et4000, pvga1 および cirrus のドライバに
あります。

&lsqb; 訳注： XFree86 3.3.3.1 では、 vga256/drivers 以下のドライバー
の多くがアクセラレータ対応となっており、多くのドライバーでこの関数が
定義されています。例えば chips(C&amp;T) や tvga8900(trident)、
それに neo(NeoMagic) などのドライバーにも用意されています。 &rsqb;

<!--
If you do NOT need this function, simply don't define it, and put `NoopDDA'
in its place in the vgaVideoChipRec structure initialization.
-->
この関数が必要 *無い* 場合には、単にこれを定義しないでおいて、
 vgaVideoChipRec 構造体を初期化する際には、この関数を指定するための
フィールドに `NoopDDA' を設定します。

<!--
<sect> Building The New Server <p>
-->
<sect> 新サーバの生成 <p>
<!--
As in the setup work, the steps for building the server depend whether
you are working in the source tree or in the Link Kit.  Here are the
steps for the initial build after installing your new driver files:
-->
ドライバーコード開発の準備作業と同じく、サーバーを生成する作業の手順は
ソースツリー中で作業しているのか、それともリンクキットを利用しているのか
によって異なります。次に述べるのは新しいドライバーファイルを追加した後で
最初に生成するための手順です。
<itemize>
<!--
	<item>If you are working in the source tree, follow these steps:
-->
        <item>ソースツリー中で作業している場合には、
	      次の手順に従って実行します。

<!--
		Go to xc/programs/Xserver, and enter
	        `<tt>make Makefile</tt>', then
		`<tt>make Makefiles depend all</tt>'
-->
                xc/programs/Xserver ディレクトリに移動して、
		`<tt>make Makefile</tt>' を実行した後、
		`<tt>make Makefiles depend all</tt>' を実行します。

<!--
	<item>If you are working in the Link Kit, follow these steps:
-->
        <item>リンクキットを利用している場合には、
              次の手順に従って実行します。

	<enum>
<!--
	<item>Go to /usr/X11R6/lib/Server, and enter
	       `<tt>./mkmf</tt>'
	<item>In the same directory, enter `<tt>make</tt>'
-->
        <item> /usr/X11R6/lib/Server ディレクトリに移動して、
	       `<tt>./mkmf</tt>' を実行します。
	<item>同じディレクトリ内で、 `<tt>make</tt>' を実行します。
	</enum>
</itemize>
<!--
To rebuild the server after the initial build (e.g. after making changes
to your driver):
-->
最初のサーバー生成を実行した後で（例えば新しく開発したドライバに
さらに変更を加えてから）サーバを再生成する場合には:

<itemize>
<!--
<item>	If you are working in the source tree, follow these steps:
-->
<item>	ソースツリー中で作業している場合には、次の手順に従って実行します。

	<enum>
<!--
	<item>	Go to the appropriate drivers/ directory (e.g.,
	   xc/programs/Xserver/hw/xfree86/vga256/drivers),
	   and enter `<tt>make</tt>'.
	<item>	Go to xc/programs/Xserver, and enter
	   `<tt>make loadXF86_SVGA</tt>' (to link the color server),
	   `<tt>make loadXF86_VGA16</tt>' (to link the 16 color server) or
	   `<tt>make loadXF86_Mono</tt>' (to link the mono server).
-->
        <item>	適切な drivers/ 下の ディレクトリへ移動して、
           （例えば xc/programs/Xserver/hw/xfree86/vga256/drivers）
           `<tt>make</tt>' を実行します。
        <item>	xc/programs/Xserver へ移動して、次のコマンドを実行します。
           `<tt>make loadXF86_SVGA</tt>' (カラーサーバへのリンク),
           `<tt>make loadXF86_VGA16</tt>' (16 色サーバへのリンク) または
           `<tt>make loadXF86_Mono</tt>' (モノクロサーバへのリンク)。
	</enum>

<!--
<item>	If you are working in the Link Kit, follow these steps:
-->
<item>	リンクキットを利用している場合には、次の手順に従って実行します。
	<enum>
<!--
	<item>	Go to the appropriate driver directory, and enter
	   `<tt>make</tt>'.
	<item>	Go to /usr/X11R6/lib/server, and enter 
	   `<tt>make loadXF86_SVGA</tt>' (to link the color server) or 
	   `<tt>make loadXF86_VGA16</tt>' (to link the 16 color server) or 
	   `<tt>make loadXF86_Mono</tt>' (to link the mono server).
-->
        <item>	適切なドライバのディレクトリへ移動して、
           `<tt>make</tt>' を実行します。
        <item>	/usr/X11R6/lib/server に移動して、次のコマンドを実行します。
           `<tt>make loadXF86_SVGA</tt>' (カラーサーバへのリンク)、
           `<tt>make loadXF86_VGA16</tt>' (16 色サーバへのリンク) または
           `<tt>make loadXF86_Mono</tt>' (モノクロサーバへのリンク)。
	</enum>
</itemize>

<p>

<!--
<sect> Debugging <p>
-->
<sect> デバッグ <p>
<!--
Debugging a new driver can be a painful experience, unfortunately.  It
is likely that incorrect programming of the SVGA chipset can lock up your
machine.  More likely, however, is that the display will be lost, potentially
requiring a reboot to correct.  It is HIGHLY recommended that the server
be run from an attached terminal or a network login.  This is the only
rational way in which a debugger can be used on the server.  Attempting
to use multiple VTs for debugging is basically a waste of time.
-->
残念ながら新しいドライバのデバッグは辛いものです。
例えば SVGA チップセットのプログラミング (レジスタ設定) を間違えた場合には
マシンが固まってしまうでしょう。
しかし、もっと頻繁に起きる可能性があるのはディスプレイの表示が消えてしまう
ことです。この場合、正常に戻すためには再起動させる必要があるでしょう。
新しく生成したサーバーを実行してテストする際には、外部端末を繋ぐか、
ネットワークからログインすることを *強く* お勧めします。
これはサーバに対してデバッガを使用することを可能にする唯一の合理的な方法です。
複数の VT を使いながらのデバッグするのは基本的に時間の無駄です。

<!--
Because of the potential for locking up the machine, it is a VERY good idea
to remember to do a `sync' or two before starting the server.  In addition,
any unnecessary filesystems should be unmounted while the debugging session
is going on (to avoid having to run unnecessary fsck's).
-->
マシンが固まってしまう危険性の存在を考慮すると、サーバを起動する前に
 1、2 回 `sync' コマンドを実行しておくことは *とても* 良い考えです。
さらに言えば、（本来は不要なはずの fsck が実行されることを避けるために）
デバッグ実行中はどうしても必要なファイルシステム以外、すべてアンマウント
しておきましょう。

<!--
By default the server is built without debugging symbols.  The server can
grow VERY large with debugging enabled.  It is very simple to rebuild
your driver for debugging, though.  Do the following:
-->
標準では、サーバはデバッグ用のシンボル抜きで生成されます。
デバッグできるように生成したサーバは *とても* 大きなものになります。
しかしドライバーコードをデバッグのために再構築することはとても簡単です。
次の手順で行ってください:

<enum>
<!--
	<item>Go to the driver directory.
	<item>Edit the Makefile.  Look for the SECOND definition of 
	   `<tt>CDEBUGFLAGS</tt>'.  Change this definition to 
-->
        <item>ドライバのディレクトリへ移動してください。
        <item>Makefile を編集してください。 `<tt>CDEBUGFLAGS</tt>' の
	    *二番目* の定義を探して、それを次のように修正してください。

	<verb>
		CDEBUGFLAGS = -g -DNO_INLINE
	</verb>

<!--
	   (this will enable debugging symbols and disable inlining of
	   functions, which can make single-stepping a nightmare).
	<item>Remove the `sdc_driver.o' file.
	<item>Now follow the steps above for rebuilding the server.
-->
           (これはデバッグ用シンボルを有効にし、シングルステップ実行時
           の悪夢を引き起こす関数のインライン展開を無効にします。)
        <item>`sdc_driver.o' ファイルを消してください。
        <item>上記の手順に従って、サーバを再構築してください。

<!--
	(Alternatively, instead of editing the Makefile, you can simply
	do `<tt>make CDEBUGFLAGS="-g -DNO_INLINE"</tt>' after removing the
	old .o file, then rebuild the server as described above).
-->
        (または、Makefile を修正する代わりに、古い .o ファイルを消した後で
        単に `<tt>make CDEBUGFLAGS="-g -DNO_INLINE"</tt>' を実行するという
        方法もあります。この後上記の手順でサーバを再構築してください。)
</enum>

<!--
This will give you a server with which you can set breakpoints in the driver
functions and single-step them.  If you are working in the source tree,
and just learning about SVGA programming, it may be useful to rebuild 
vgaHW.c with debugging as well.
-->
これによって、ドライバ関数にブレークポイントを設定してシングルステップ実行
させることのできるサーバが生成されます。ソースツリー中で作業を行っていて、
かつ SVGA プログラミングを学習し始めたばかりならば、vgaHW.c も同様にデバッグ
可能にして再構築すると便利でしょう。

<!--
<sect> Advice <p>
-->
<sect> アドバイス <p>
<!--
I cannot stress this enough - study all available references, and the
existing code, until you understand what is happening.  Do this BEFORE you
begin writing a driver.  This will save you a massive amount of headache.
Try to find a driver for a chipset that is similar to yours, if possible.
Use this as an example, and perhaps derive your driver from it.
-->
次に述べることは、いくら強調しても足りないくらいです。

ドライバーコードの中で何が起きているのかを理解できるようになるまでは、
すべての利用できる参照文献と既存のドライバーコードをじっくり調べて
内容を把握するよう努めてください。ドライバーコードを書き始める *前に* 
この調査を行なって下さい。それによって頭痛のタネをかなり減らすことが
できるでしょう。可能ならば、これから追加しようとするチップセットに似た
チップセットのドライバを探しましょう。またもし、そうしたドライバを
見つけることができたら、それを例題として利用しましょう。たぶん、
そのコードから新しいドライバを派生させることができるでしょう。

<!--
Do not let the gloom-and-doom in the debugging section  discourage you.  
While you will probably have problems initially (I still do), careful, 
deliberate debugging steps can bear fruit very quickly.  It is likely 
that, given a good understanding of the chipset, a driver can be written 
and debugged in a day or two.  For someone just learning about this kind 
of programming, a week is more reasonable.
-->
デバッグ中は暗く思い詰めてはいけません。たぶん、最初のうちはいろいろと
問題を抱えることになるでしょう。 (私もまだまだそこから抜け出せていません。) 
けれども、注意深く、慎重にデバッグの手順を進めていけば、非常に短い間に
成果を挙げることができます。おそらく、チップセットのことを詳しく理解して
いれば、 1, 2 日でドライバーコードの作成とデバッグをやってのけることさえ
可能でしょう。この種のプログラミングを学習し始めたばかりの人の場合には、
一週間というのが、より妥当な線でしょう。

<!--
<sect> Advanced Topics <p>
-->
<sect> 高度な話題 <p>
<!--
Newer chipsets are getting into two advanced areas: programmable clock
generators, and accelerated capabilities (BitBlt, line drawing, HW cursor).
These are new areas, and the formal interfaces to them are not yet defined.
It is advised that you contact the XFree86 team and get involved with the
development/beta-testing team if you need to be working in these areas.
-->
新しいチップセットは二つの高度な技術領域に取り組み始めました。
それはプログラマブルクロックジェネレータとアクセラレータの各種特性
(BitBlt, line drawing, HW カーソル) です。これらは新しい技術領域で、
正式なインターフェースは未だ定義されていません。
これらの新しい技術領域について作業したい場合は、XFree86 チームと
連絡を取って開発/ベータテストチームに参画してください。

 &lsqb; 訳注： XFree86 3.3.3.1 では vga256/drivers 以下のドライバー
コードでプログラマブルクロックやアクセラレータ機能を使用している
ものがけっこうあります。アクセラレータ機能についてはソースツリーの
 xaa/NOTES を参照すると良いでしょう。 &rsqb;

<!--
<sect> References <p>
-->
<sect> 参考文献 <p>
<itemize>
<item>Programmer's Guide to the EGA and VGA Cards, 3rd ed. <newline>
   Richard Ferraro <newline>
   Addison-Wesley, 1994 <newline>
   ISBN 0-201-62490-7 <newline>
<!--
   (This is the bible of SVGA programming - it has a few errors, so watch out.
   The third edition also covers several accelerated video cards.)
-->
(これは SVGA プログラミングの必読書です。ちょっと誤記があるので
注意しましょう。第 3 版ではいくつかのアクセラレータビデオカードにも
言及しています。)

<item>vgadoc4.zip <newline>
   Finn Thoegersen <newline>
<!--
   (This is a collection of SVGA and other chipset documentation.  It is
   available on most MS-DOS/Windows related FTP archives, including wuarchive.
   It is DOS/BIOS oriented, but is still extremely useful, especially for
   developing probe functions.)
-->
   (これは SVGA とその他のチップセットの資料を集めたものです。
   wuarchive を含むほとんどの MS-DOS/Windows 関連の FTP アーカイブから
   取り寄せ可能です。これは DOS/BIOS を対象としたものですが、その一方
   特に探査 (probe) 関数を開発する時にはとても有用な資料です。)

</itemize>

<!--
<sect> Vendor Contact Information <p>
-->
<sect> ベンダー連絡先情報 <p>
<descrip>
<tag/ATI Technologies (VGA-Wonder, Mach8, Mach32, Mach64)
     33 Commerce Valley Drive East/
Thornhill, Ontario <newline>
Canada L3T 7N6 <newline>
(905) 882-2600 (sales) <newline>
(905) 882-2626 (tech support) <newline>
(905) 764-9404 (BBS) <newline>
(905) 882-0546 (fax) <newline>

<tag/Chips &amp; Technologies/
???

<tag/Cirrus Logic (SVGA, Accelerators - CL-GD5426)/
3100 West Warren Ave. <newline>
Fremont, CA  94538 <newline>
(510) 623-8300 (N. CA, USA) <newline>
(49) 8152-40084 (Germany) <newline>
(44) 0727-872424 (UK) <newline>

<tag/Genoa Systems (GVGA)/
75 E. Trimble Road <newline>
San Jose, CA 95131 <newline>
(408) 432-9090 (sales) <newline>
(408) 432-8324 (tech support) <newline>

<tag/Headland Technologies, Inc (Video-7 VGA 1024i, VRAM II)/
46221 Landing Parkway <newline>
Fremont, CA  94538 <newline>
(415) 623-7857 <newline>

<tag/Oak Technology, Inc (OTI-067,OTI-077)/
139 Kifer Ct. <newline>
Sunnyvale, CA 94086 <newline>
(408) 737-0888 <newline>
(408) 737-3838 (fax)

<tag>S3 (911, 924, 801/805, 928, 864, 868, 964, 968, 764, 765)</tag>
(408) 980-5400

<tag/Trident Microsystems Inc (8800, 8900, 9000)/
205 Ravendale Dr <newline>
Mountainside, CA 94043 <newline>
(415) 691-9211

<tag/Tseng Labs Inc,/
6 Terry Drive <newline>
Newtown, PA  18940 <newline>
(215) 968-0502

<tag/Weitek (Power9000, 5186)/
1060 E. Arques Ave, <newline>
Sunnyvale, CA  94086 <newline>
(408) 738-5765 

<tag/Western Digital/
(714) 932-4900
</descrip>

<verb>
$XFree86: xc/programs/Xserver/hw/xfree86/doc/Japanese/sgml/VGADriv.sgml,v 3.1.2.4 1999/11/26 15:23:51 hohndel Exp $





$XConsortium: VGADriv.sgml /main/9 1996/10/28 05:13:22 kaleb $
</verb>
<hrule>

このファイルは
xc/programs/Xserver/hw/xfree86/doc/sgml/VGADriv.sgml,v 3.13.2.1 1998/02/01 16:04:54
を、佐野 武俊
( Taketoshi Sano  <url url="mailto:kgh12351@nifty.ne.jp"
name="&lt;kgh12351@nifty.ne.jp&gt;"> ) が XFree86 3.3.3.1 を
日本でインストールする人向けに和訳したものです。ここがおかしいとか、
ここはこうしたほうがいいといったご意見がありましたら、電子メールで
お知らせ下さい。

なお、翻訳にあたっては岡本  一幸 
( Kazuyuki Okamoto <url url="mailto:ikko-@pacific.rim.or.jp"
name="&lt;ikko-@pacific.rim.or.jp&gt;"> ) さんによる XFree86 3.3.2 の
和訳から大部分の文章を頂きましたことをここに記し、感謝を示します。
原文の著作権は XFree86 プロジェクト社にあります。
この和訳の著作権は
X Japanese Documentation Project <url url="http://xjman.dsl.gr.jp/"
name="http://xjman.dsl.gr.jp/"> (略称 xjman プロジェクト) にあります。
この和訳の不具合は私 &lt;kgh12351@nifty.ne.jp&gt; または xjman プロジェクト
まで電子メールで送って下さい。

<hrule>
&lsqb;EOF&rsqb;

</article>
