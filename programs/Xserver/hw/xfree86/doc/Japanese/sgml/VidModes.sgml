<!DOCTYPE linuxdoc PUBLIC "-//XFree86//DTD linuxdoc//EN">

<!-- This is the Linux Distribution HOWTO, SGML source -- >
<!-- Eric S. Raymond, esr@snark.thyrsus.com -- >
<!-- The submission address is gregh@sunsite.unc.edu -- >

<article>

<!--
<title>XFree86 Video Timings HOWTO
-- >
<title>XFree86 ビデオ情報 HOWTO
<author>Eric S. Raymond &lt;esr@thyrsus.com&gt;
<date>Version 3.0, 8 Aug 1997
<trans> 岡本　一幸 Kazuyuki Okamoto &lt;ikko-@pacific.rim.or.jp&gt;<newline>
Hiro Sugawara &lt;hiro@arkusa.com&gt; <newline> &amp; The X Japanese Documentation Project
<tdate>

<abstract>
<!--
How to compose a mode line for your card/monitor combination under XFree86.
The XFree86 distribution now includes good facilities for configuring most
standard combinations; this document is mainly useful if you are tuning a
custom mode line for a high-performance monitor or very unusual hardware.
It may also help you in using xvidtune to tweak a standard mode that is
not quite right for your monitor.
-- >
XFree86 においてお手元のカードやモニタの組み合わせでどのように mode 行を
作成するかを説明します。
XFree86 配布物は現在ほとんどの標準的な組み合わせに関して構成できる素晴ら
しい機能を持っています。この文書は主に mode 行をより高性能なモニタや
使えそうもないハードウェア向けにカスタマイズして調整したい場合に有効です。
また、xvidtune を使ってお手元のモニタにまったく合わない標準的な mode 行を
変更するのに助けになるでしょう。
</abstract>

<toc>

<!--
<sect>Disclaimer
-- >
<sect>責任放棄声明
<p>

<!--
You use the material herein SOLELY AT YOUR OWN RISK.  It is possible
to harm both your monitor and yourself when driving it outside the
manufacturer's specs. Read <ref id="overd" name="Overdriving Your
Monitor"> for detailed cautions. Any damages to you or your monitor
caused by overdriving it are your problem. 
-- >
ここにある資料は単にご自身の責任で使用してください。製造会社の仕様
外の仕様で使用した場合モニタとご自身の両方に危害を与える可能性があります。
詳細な警告については <ref id="overd" name="モニタの仕様外使用"> を
読んでください。

<!--
The most up-to-date version of this HOWTO can be found at the <url
url="http://sunsite.unc.edu/LDP"
name="Linux Documentation Project"> web page.

Please direct comments, criticism, and suggestions for improvement to
<htmlurl url="mailto:esr@thyrsus.com" name="esr@snark.thyrsus.com">. Please do
<em>not</em> send email pleading for a magic solution to your
special monitor problem, as doing so will only burn up my time and
frustrate you '-'- everything I know about the subject is already in
here.
-- >
この HOWTO の最新版は <url url="http://sunsite.unc.edu/LDP"
name="Linux Documentation Project"> のウェブのページにあります。

改良のための率直なご批評、ご批判やご提案は
<htmlurl url="mailto:esr@thyrsus.com" name="esr@snark.thyrsus.com">
までお願いします。私の時間を無駄にし、あなたをいらいらさせるような
ご自身のモニタの特殊な問題について、すてきな
回答を嘆願するような電子メールは<em>送付しない</em>でください。
この問題について私の知っていることの全ては、すでにここにあります。

<!--
<sect>Introduction<label id="intro">
-- >
<sect>序文<label id="intro">
<p>

<!--
The XFree86 server allows users to configure their video subsystem and thus
encourages best use of existing hardware.  This tutorial is intended to help
you learn how to generate your own timing numbers to make optimum use of your
video card and monitor. 

We'll present a method for getting something that works, and then show you how
you can experiment starting from that base to develop settings that optimize
for your taste. 
-- >
ユーザは XFree86 サーバを自分のビデオサブシステムに合わせてハードウェアを
使いこなすように構成出来ます。この手引き書は自分自身のビデオカードとモニタ
の最適な時間調節の数値を、如何に生成するか勉強する助けになるでしょう。

ここではまず XFree86 サーバを何とか動かすための方法を提示し、それを基礎
に実験をしながらいろいろと設定を変更して自分の好みに最適化するためのやり方
を説明します。

<!--
Starting with XFree86 3.2, XFree86 provides an <bf>XF86Setup</bf>(1)
program that makes it easy to generate a working monitor mode
interactively, without messing with video timing number directly.  So
you shouldn't actually need to calculate a base monitor mode in most
cases.  Unfortunately, <bf>XF86Setup</bf>(1) has some limitations; it
only knows about standard video modes up to 1280x1024.  If you have a
very high-performance monitor capable of 1600x1200 or more you will
still have to compute your base monitor mode yourself.
-- >
XFree86 3.2 からはじめる場合、XFree86 は 直接にビデオ情報の調整数値を
意識させずに、動作するモニタの モード を対話的に簡単に作成する
<bf>XF86Setup</bf>(1) プログラムを提供しています。したがって、実際に
基礎となるモニタの モード はほとんどの場合、計算する必要はありません。
残念ながら <bf>XF86Setup</bf>(1) に幾つかの制限があり、1280x1024 まで
の標準的なビデオの モード についてしか知りません。とても高性能な
1600x1200 若しくはそれ以上が可能なモニタを持っている場合は、未だに
自分自身で基礎となるモニタの モード を計算しなければいけません。

<!--
Recent versions of XFree86 provide a tool called <bf>xvidtune</bf>(1)
which you will probably find quite useful for testing and tuning
monitor modes.  It begins with a gruesome warning about the possible
consequences of mistakes with it.  If you pay careful attention to
this document and learn what is behind the pretty numbers in
xvidtune's boxes, you will become able to use xvidtune effectively and
with confidence. 
-- >
最近の XFree86 は <bf>xvidtune</bf>(1) と呼ばれるモニタの モード のテスト
とチューニングに多分かなり使えるツールを提供しています。
このツールは間違えて使った時の結果についてものすごい警告を出し
て起動します。この文書に慎重な注意を払い、xvidtune の箱の中のかなりの数値の
背後にあるものについて学習しましょう。そうすれば xvidtune を効果的に安心して使えるようになります。

<!--
If you already have a mode that almost works (in particular, if one of
predefined VESA modes gives you a stable display but one that's
displaced right or left, or too small, or too large) you can go
straight to the section on <ref id="fixes" name="Fixing Problems with the
Image">.  This will enlighten you on ways to tweak the timing
numbers to achieve particular effects. 
-- >
ほとんど動作しているモードを持っている場合は (特に、前もって設定している
VESA モードは左右に片寄ったり、小さすぎたり、大きすぎたりするでしょうが、
安定しているでしょう) 、さっそく
<ref id="fixes" name="画像表示の問題修正"> の節から始めてください。
この節は調整数値をちょうど良い数値に近づける方法を教えてくれるでしょう。

<!--
If you have <bf>xvidtune</bf>(1), you'll be able to test new modes on the fly,
without modifying your X configuration files or even rebooting your X server.
Otherwise, XFree86 allows you to hot-key between different modes defined in
Xconfig (see XFree86.man for details).  Use this capability to save
yourself hassles!  When you want to test a new mode, give it a unique
mode label and add it to the <EM>end</EM> of your hot-key list.  Leave a
known-good mode as the default to fall back on if the test mode
doesn't work.  
-- >
<bf>xvidtune</bf>(1) を持っている場合、X の構成情報ファイルの変更しないで
または、X サーバの再起動なしに、そのままの状態で新しいモードのテストが
出来ます。他に XFree86 はホットキーで Xconfig ファイル に定義されている
異なるモード間を移動できます (詳細については XFree86.man を参照してくだ
さい) 。これは困った事態から自分を守る
とても便利な機能です。新しいモードを試してみたくなったら、新しいモードを重
複しないモードラベルを付けてホットキーリストの <em>最後</em> に追加してください。
新しいモードが動かなかったときの保険に、既に動いているモードは標準値として
残しておいてください。

<!--
<sect>How Video Displays Work<label id="video">
-- >
<sect>ビデオディスプレイの動作原理<label id="video">

<p>

<!--
Knowing how the display works is essential to understanding what numbers to put
in the various fields in the file Xconfig.  Those values are used in the lowest
levels of controlling the display by the XFree86 server. 

The display generates a picture from a series of dots.  The dots are arranged
from left to right to form lines.  The lines are arranged from top to bottom to
form the picture.  The dots emit light when they are struck by the electron
beam inside the display.  To make the beam strike each dot for an equal amount
of time, the beam is swept across the display in a constant pattern. 
-- >
ビデオディスプレイの動作原理を知ることは Xconfig ファイルの色々な場所に
どんな数字を入れるかを理解する上で重要です。これらの値は XFree86 サーバが
ディスプレイをハードウェアレベルで制御するのに使用されます。

ディスプレイはドットの集まりから画像を表示します。このドットを左から右へ並
べて線を作ります。この線を上から下へ並べて画像を作ります。ドットはディスプ
レイ内部からの電子ビームで叩かれたとき発光します。それぞれのドットに均一に
電子ビームを当てるために、一定のパターンでディスプレイ上を走査します。

<!--
The pattern starts at the top left of the screen, goes across the screen to the
right in a straight line, and stops temporarily on the right side of the
screen.  Then the beam is swept back to the left side of the display, but down
one line.  The new line is swept from left to right just as the first line was.
This pattern is repeated until the bottom line on the display has been swept.
Then the beam is moved from the bottom right corner of the display to the top
left corner, and the pattern is started over again. 
-- >
そのパターンはスクリーンの左上から始まり、右へ真直ぐスクリーンを横切るよう
に走り、スクリーンの右端で一旦停止します。そして電子ビームはディスプレイの
左端に移動し、一本下に移動します。新しい線はディスプレイの左から右へ最初の
線を引いたように走査します。このパターンをディスプレイの一番下まで繰り返し
ます。それから電子ビームがディスプレイの左上から右下まで移動したら、また最
初から繰り返します。

<!--
There is one variation of this scheme known as interlacing: here only
every second line is swept during one half-frame and the others are filled in
in during a second half-frame.

Starting the beam at the top left of the display is called the beginning of a
frame.  The frame ends when the beam reaches the the top left corner again as
it comes from the bottom right corner of the display.  A frame is made up of
all of the lines the beam traced from the top of the display to the bottom. 
-- >
この機能の別の種類にインタレースというのが知られています。:これはすべての
第 2 の線がフレームの半分を操作している間にほかの線がもう半分の第 2 の
フレームを満たすような機構です。<newline>
&lsqb;訳注 : 一本おきにそれぞれの線がフレームを走査します。&rsqb;

フレームの始まりはディスプレイの左上の電子ビームの開始点です。電子ビームが
ディスプレイの右下隅まで届いてから左上隅に再び戻ってくる時がフレームの終了
点です。フレームはディスプレイの一番上から一番下までの全ての電子ビームの線
で出来ています。

<!--
If the electron beam were on all of the time it was sweeping through the frame,
all of the dots on the display would be illuminated.  There would be no black
border around the edges of the display.  At the edges of the display the
picture would become distorted because the beam is hard to control there.  To
reduce the distortion, the dots around the edges of the display are not
illuminated by the beam even though the beam may be pointing at them.  The
viewable area of the display is reduced this way. 
-- >
もし電子ビームがフレームを移動している間ずっと「オン」だったら、ディスプレ
イの全てのドットは点灯してしまい、ディスプレイの縁には黒い部分はなくなるで
しょう。そしてディスプレイの縁では、電子ビームの制御が難しいので画像が歪曲
してしまうでしょう。この歪みを減らすため、ディスプレイの縁のドットには、電
子ビームが届いても、ドットが輝かないようになっています。ディスプレイの実際
に表示される領域が小さくなっているのは、こういうわけなのです。

<!--
Another important thing to understand is what becomes of the beam when no spot
is being painted on the visible area.  The time the beam would have been
illuminating the side borders of the display is used for sweeping the beam back
from the right edge to the left and moving the beam down to the next line.  The
time the beam would have been illuminating the top and bottom borders of the
display is used for moving the beam from the bottom-right corner of the display
to the top-left corner. 
-- >
もう一つ理解してほしい重要なことは、表示される領域を描画していない時に電子
ビームが
どうなっているかということです。ディスプレイの横端を描画するために使われる
はずだった時間は、電子ビームを右の端から左の端まで戻し、一つ下の次のライン
に移動するために使われます。ディスプレイの上端および下端を描画するために掛
かるはずだった時間は、電子ビームをディスプレイの右下隅から左上隅まで移動す
るために使われます。

<!--
The adapter card generates the signals which cause the display to turn on the
electron beam at each dot to generate a picture.  The card also controls when
the display moves the beam from the right side to the left and down a line by
generating a signal called the horizontal sync (for synchronization) pulse.
One horizontal sync pulse occurs at the end of every line.  The adapter also
generates a vertical sync pulse which signals the display to move the beam to
the top-left corner of the display.  A vertical sync pulse is generated near
the end of every frame. 
-- >
アダプタカードはディスプレイの電子銃を点灯させ全てのドットで画像を生成する
ような信号を作成します。また、カードは電子ビームが右から左に移動して一本下
がるときに水平同期信号と呼ばれる信号を作成します。すべてのラインの最後に一
つの水平同期信号が発生します。さらに、アダプタカードは電子ビームをディスプ
レイの左上隅に移動するための垂直同期信号も生成します。垂直同期信号は全ての
フレームの終わり近くに作成されます。

<!--
The display requires that there be short time periods both before and after the
horizontal and vertical sync pulses so that the position of the electron beam
can stabilize.  If the beam can't stabilize, the picture will not be steady. 

In a later section, we'll come back to these basics with definitions,
formulas and examples to help you use them. 
-- >
ディスプレイには、電子ビームの位置を安定させるため、水平同期信号と垂直同期
信号の前後に短時間の余裕が必要です。電子ビームの安定化が出来ないと、画像が
しっかりしません。

以降の節で、定義、公式と例題の補助のために、これらの基本に戻るでしょう。

<!--
<sect>Basic Things to Know about your Display and Adapter<label id="basic">
-- >
<sect> ディスプレイとアダプタについての基礎知識<label id="basic">
<p>

<!--
There are some fundamental things you need to know before hacking an Xconfig
entry.  These are: 
-- >
Xconfig の設定項目をさわる前に、次の基礎的な事項を知っておく必要がありま
す。

<itemize>
<!--
<item>your monitor's horizontal and vertical sync frequency options
<item>your video adapter's driving clock frequency, or "dot clock"
<item>your monitor's bandwidth
-- >
<item> モニタの水平同期信号と垂直同期信号の周波数
<item> ビデオアダプタの動作クロック周波数、または"ドットクロック"
<item> モニタの周波数帯幅
</itemize>
<!--
The monitor sync frequencies: 

The horizontal sync frequency is just the number of times per second the
monitor can write a horizontal scan line; it is the single most important
statistic about your monitor.  The vertical sync frequency is the number of
times per second the monitor can traverse its beam vertically. 
-- >
モニタの同期周波数 :

モニタの水平同期周波数は、そのモニタが 1 秒間に書ける水平走査線の数のこ
とで、これはモニタについて最も重要な統計値です。垂直同期周波数は、そのモ
ニタが 1 秒間に電子ビームを縦方向に通過させることのできる回数のことです。

<!--
Sync frequencies are usually listed on the specifications page of your monitor
manual.  The vertical sync frequency number is typically calibrated in Hz
(cycles per second), the horizontal one in KHz (kilocycles per second).  The
usual ranges are between 50 and 150Hz vertical, and between 31 and 135KHz
horizontal. 
-- >
同期周波数は普通、モニタのマニュアルの仕様の頁に一覧になっています。垂直
同期周波数の数値は一般的に Hz (秒当たりの単位周期) で、水平同期周波数は
KHz (秒当たりの千単位周期) で計測されています。通常の範囲は垂直については
50 から 150Hz、水平については 31 から 135KHz 程度です。

<!--
If you have a multisync monitor, these frequencies will be given as ranges.
Some monitors, especially lower-end ones, have multiple fixed frequencies.
These can be configured too, but your options will be severely limited by the
built-in monitor characteristics.  Choose the highest frequency pair for best
resolution.  And be careful '-'-'- trying to clock a fixed-frequency monitor at a
higher speed than it's designed for can easily damage it. 
-- >
マルチシンクモニタの場合、その周波数は幅のある値として表示されています。
下位のものに多いのですが、複数の固定した周波数を持っているモニタも
あります。このようなモニタも普通のモニタと同様に設定は出来ますが、モニ
タの持つ特徴に厳しく制限されてしまうでしょう。最高の解像度が得られるよう
な最も高い水平同期と垂直同期周波数の組み合わせを選択してください。そして、
固定周波数モニタでは設計値より高い周波数を与えるとモニタを痛めるおそれ
があるので注意してください。

<!--
Earlier versions of this guide were pretty cavalier about overdriving
multisync monitors, pushing them past their nominal highest vertical 
sync frequency in order to get better performance.  We have since had more
reasons pointed out to us for caution on this score; we'll cover those under
<ref id="overd" name="Overdriving Your Monitor"> below. 
-- >
この文書の初期の版では、より良い性能を得るための名目上の最高の垂直同期
周波数を指定したマルチシンクモニタの仕様外使用にかなり無頓着でした。
この警告に対する根拠を指摘できる理由を手にいれました。以降の
<ref id="overd" name="モニタの仕様外使用"> で言及します。

<!--
The card driving clock frequency: 

Your video adapter manual's spec page will usually give you the card's dot
clock (that is, the total number of pixels per second it can write to the
screen).  If you don't have this information, the X server will get it for
you.  Even if your X locks up your monitor, it will emit a line of clock and
other info to standard output.  If you redirect this to a file, it should be
saved even if you have to reboot to get your console back.  (Recent versions 
of the X servers all support a '-'-probeonly option that prints out this
information and exits without actually starting up X or changing the
video mode.) 
-- >
カードの駆動クロックの周波数 :

ビデオアダプタの仕様書にカードのドットクロックがあります (ドットクロックと
は画面へ 1 秒間に点を表示できる総数です) 。この情報が無い場合は、X サーバ
がそれを取ってきます。X がモニタを固めてしまった場合でも、クロックとその
他の情報を標準出力に吐き出します。この情報をファイルにリダイレクトした場合、
コンソールへ戻って再立ち上げしなければならなくなってもファイルに保存されま
す。(最近の X サーバ ではすべて、クロックとその他の情報を出力し X を実際に
起動しないでビデオモードも変更しない -probeonly オプションをサポートして
います。)

<!--
Your X startup message should look something like one of the following
examples: 

If you're using XFree86: 
-- >
X の開始時のメッセージは次のような例題に似ているでしょう。:

XFree86 を使用している場合は:

<!--
    Chipset '-'- this is the exact chip type; an early mask of the 86C911
-- >
<!--
         Size of on-board frame-buffer RAM
-- >
<!--
                                   Bandwidth
-- >
<!--
                              Possible driving frequencies in MHz
-- >
<tscreen><verb>
Xconfig: /usr/X11R6/lib/X11/Xconfig
(**) stands for supplied, (--) stands for probed/default values
(**) Mouse: type: MouseMan, device: /dev/ttyS1, baudrate: 9600
Warning: The directory "/usr/andrew/X11fonts" does not exist.
         Entry deleted from font path.
(**) FontPath set to "/usr/lib/X11/fonts/misc/,/usr/lib/X11/fonts/75dpi/"
(--) S3: card type: 386/486 localbus
(--) S3: chipset:   924
                    ---
    チップセット -- これは正確なチップの型式です。86C911 の前のものです。

(--) S3: chipset driver: s3_generic
(--) S3: videoram:  1024k
                    -----
         フレームバッファメモリの大きさです。

(**) S3: clocks:  25.00  28.00  40.00   3.00  50.00  77.00  36.00  45.00
(**) S3: clocks:   0.00   0.00  79.00  31.00  94.00  65.00  75.00  71.00
                  ------------------------------------------------------
                              動作可能な周波数を MHz で表します。

(--) S3: Maximum allowed dot-clock: 110MHz
                                    ------
                                    帯域幅
(**) S3: Mode "1024x768": mode clock =  79.000, clock used =  79.000
(--) S3: Virtual resolution set to 1024x768
(--) S3: Using a banksize of 64k, line width of 1024
(--) S3: Pixmap cache:
(--) S3: Using 2 128-pixel 4 64-pixel and 8 32-pixel slots
(--) S3: Using 8 pages of 768x255 for font caching
</verb></tscreen>

<!--
If you're using SGCS or X/Inside X: 

<tscreen><verb>
WGA: 86C911 (mem: 1024k clocks: 25 28 40 3 50 77 36 45 0 0 79 31 94 65 75 71)
'-'-'-  '-'-'-'-'-'-       '-'-'-'-'-         '-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-'-
 |     |            |                 Possible driving frequencies in MHz
 |     |            +'-'- Size of on-board frame-buffer RAM
 |     +'-'- Chip type
 +'-'- Server type
</verb></tscreen>
-- >
SGCS X または X/Inside X を使っている場合は:

<tscreen><verb>
WGA: 86C911 (mem: 1024k clocks: 25 28 40 3 50 77 36 45 0 0 79 31 94 65 75 71)
---  ------       -----         --------------------------------------------
 |     |            |                 動作可能な周波数を MHz で表わします。
 |     |            +-- ボード上のフレームバッファメモリの大きさ
 |     +-- チップの型式
 +-- サーバの種類
</verb></tscreen>

<!--
Note: do this with your machine unloaded (if at all possible).  Because X is
an application, its timing loops can collide with disk activity, rendering the
numbers above inaccurate.  Do it several times and watch for the numbers to
stabilize; if they don't, start killing processes until they do.  SVr4 users:
the mousemgr process is particularly likely to mess you up.  

In order to avoid the clock-probe inaccuracy, you should clip out the clock
timings and put them in your Xconfig as the value of the Clocks property '-'-'-
this suppresses the timing loop and gives X an exact list of the clock values
it can try.  Using the data from the example above: 
-- >
注意: なるべくこの作業はマシンの負荷が低い時に行なって下さい。X はアプリケ
ーションですから、ディスクの動作と時間調節のループが衝突すると、上記の数字
は不正確になります。何回か繰り返し実行し、数字が大きく変動しないことを確か
めて下さい。もし変動が大きい場合には、安定するまでプロセスを殺してみてくだ
さい。SVr4 (システム V リリース 4)  を使用している人へ: mousemgr (マウスマ
ネージャ) プロセスは特に混乱の元です。

このような不正確さを避けるため、得られたクロックの数字をそのまま Clocks プ
ロパティの値として Xconfig に取り込んで下さい。これは時間調節のループを抑
止し、X が試してみることのできるクロックの値の正確な一覧を与えるためです。
上記の例のデータを使うと、次のようになります。:

<tscreen><verb>
wga
	Clocks	25 28 40 3 50 77 36 45 0 0 79 31 94 65 75 71
</verb></tscreen>
<!--
On systems with a highly variable load, this may help you avoid mysterious X
startup failures.  It's possible for X to come up, get its timings wrong due
to system load, and then not be able to find a matching dot clock in its
config database '-'-'- or find the wrong one! 
-- >
高く変わりやすい負荷が掛かったシステムでは、この方法は X の起動時に陥るこ
とがある不思議な失敗を回避する助けになるでしょう。X が起動した時システムの
負荷のせいで間違った値を得てしまい、config データベースから丁度いいドット
クロックを見つけることが出来なかったり、間違ったものを見つけてしまうことが
あり得るのです。

<!--
<sect1>The monitor's video bandwidth:
-- >
<sect1>モニタのビデオ信号帯域幅 :
<p>

<!--
If you're running XFree86, your server will probe your card and tell you
what your highest-available dot clock is.

Otherwise, your highest available dot clock is approximately the monitor's
video bandwidth.  There's a lot of give here, though '-'-'- some monitors
can run as much as 30% over their nominal bandwidth.  The risks here have
to do with exceeding the monitor's rated vertical-sync frequency; we'll
discuss them in detail below.
-- >
XFree86 を実行する場合は、サーバがカードを探知して使用可能な最高のドット
クロックを教えてくれます。

さもなければ、最高の使用可能なドットクロックをモニタのビデオ信号帯域幅から
概算しましょう。ここで与えるものが多いですが、例えば、名目上の帯域幅の 30%
増しで動作できるモニタもあります。そのモニタの限度を越えた垂直同期周波数を
用いることでかかるリスクについて以降で詳細に論じます。

<!--
Knowing the bandwidth will enable you to make more intelligent choices
between possible configurations.  It may affect your display's visual
quality (especially sharpness for fine details). 

Your monitor's video bandwidth should be included on the manual's spec page.
If it's not, look at the monitor's highest rated resolution.  As a rule of
thumb, here's how to translate these into bandwidth estimates (and thus into
rough upper bounds for the dot clock you can use): 
-- >
帯域幅を知ることで可能な構成定義からより賢い選択ができるようになります。あ
なたのディスプレイの表示品質 (特に高精細のためのシャープさ) に影響を及ぼし
ます。

モニタのビデオ信号帯域幅はマニュアルの仕様の頁に載っています。無かった場
合は、モニタの最も高い解像度のところを見てください。解像度から帯域幅 (つ
まり使用できるドットクロックの大まかな上限値) を推定するための経験則を下に
示します。

<tscreen><verb>
	640x480			25
	800x600			36
	1024x768		65
	1024x768 interlaced	45
	1280x1024		110
	1600x1200		185
</verb></tscreen>

<!--
BTW, there's nothing magic about this table; these numbers are just
the lowest dot clocks per resolution in the standard XFree86 Modes
database (except for the last, which I interpolated).  The bandwidth
of your monitor may actually be higher than the minimum needed for its
top resolution, so don't be afraid to try a dot clock a few MHz
higher. 

Also note that bandwidth is seldom an issue for dot clocks under 65MHz
or so.  With an SVGA card and most hi-res monitors, you can't get
anywhere near the limit of your monitor's video bandwidth.  The
following are examples: 
-- >
ところで、この表は絶対的なものではありません。これらの数字は標準的な
XFree86 モードデータベースでの解像度毎の最も低いドットクロックです(私が補間した最後のものを除く)。モニタの帯域幅は一番上の解像度に要求される
最小の帯域幅より高いでしょうから、恐れずにドットクロックを数 MHz 高めに
試してみてください。

また、ドットクロックが 65MHz 位より低い場合には帯域幅はほとんど問題になら
ないことに注意してください。SVGA やほとんどの高解像度のモニタでは、これ
はモニタのビデオ信号帯域幅の限界よりもはるかに低い周波数ですから。次に例
を示します。:
<!--
	Brand				Video Bandwidth
-- >

<tscreen><verb>
        ブランド名                      ビデオ信号帯域幅
	----------			---------------
	NEC 4D				75Mhz
	Nano 907a			50Mhz
	Nano 9080i			60Mhz
	Mitsubishi HL6615		110Mhz
	Mitsubishi Diamond Scan		100Mhz
	IDEK MF-5117			65Mhz
	IOCOMM Thinksync-17 CM-7126	136Mhz
	HP D1188A			100Mhz
	Philips SC-17AS			110Mhz
	Swan SW617			85Mhz
	Viewsonic 21PS			185Mhz
</verb></tscreen>
<!--
Even low-end monitors usually aren't terribly bandwidth-constrained for their
rated resolutions.  The NEC Multisync II makes a good example '-'-'- it can't
even display 800x600 per its spec.  It can only display 800x560.  For such low
resolutions you don't need high dot clocks or a lot of bandwidth; probably the
best you can do is 32Mhz or 36Mhz, both of them are still not too far from the
monitor's rated video bandwidth of 30Mhz. 
-- >
一番下のクラスのモニタでも、解像度に関して非常にビデオ信号帯域幅に制約を
受けることはありません。NEC マルチシンク II が良い例です (仕様によれば
800x600は表示出来ない) 。そのディスプレイは 800x560 のみ表示できます。この
ような低解像度の場合は、高いドットクロックや大きなビデオ信号帯域幅を必要と
せず、多分 32Mhz か 36Mhz で十分で、両方の周波数ともモニタのビデオ信号
帯域幅である30Mhz からそれ程かけ離れた値ではありません。

<!--
At these two driving frequencies, your screen image may not be as sharp as it
should be, but definitely of tolerable quality. Of course it would be nicer if
NEC Multisync II had a video bandwidth higher than, say, 36Mhz.  But this is
not critical for common tasks like text editing, as long as the difference is
not so significant as to cause severe image distortion (your eyes would tell
you right away if this were so). 
-- >
これら 2 つの動作周波数では、ディスプレイの持っている性能よりくっきりと表
示しないかもしれませんが、でもかなりの品質だと言い切ってもいいでしょう。勿
論、NEC マルチシンク II がもっと高い、例えば 36MHz ビデオ信号帯域幅を持っ
ているに越したことはありません。しかし、大きく画像が歪む程周波数がかけ離れ
ていなければ、文章を編集する等の一般的な作業には問題はありません。 (もし画
像の歪みがあまりにも大きい場合には、目で見てすぐわかるでしょう) 。

<!--
<sect1>What these control:
-- >
<sect1>どうやって制御するか :
<p>
 
<!--
The sync frequency ranges of your monitor, together with your video adapter's
dot clock, determine the ultimate resolution that you can use.  But it's up to
the driver to tap the potential of your hardware.  A superior hardware
combination without an equally competent device driver is a waste of money.
On the other hand, with a versatile device driver but less capable hardware,
you can push the hardware's envelope a little.  This is the design philosophy
of XFree86. 
-- >
モニタの同期信号帯域幅は、ビデオアダプタのドットクロックと共に、表示でき
る最高の解像度を決定します。しかしハードウェアの性能を引き出すのはドライバ
です。どんなに優れたビデオアダプタやモニタでも、良いデバイスドライバ
がなければ宝の持ち腐れになってしまいます。一方、有能でないハードでも多目的
に使用できるデバイスドライバがあれば十分役に立ちます。これが XFree86 の
設計哲学です。

<!--
<sect>Interpreting the Basic Specifications<label id="specs">
-- >
<sect>基本仕様の読み方<label id="specs">
<p>

<!--
This section explains what the specifications above mean, and some other
things you'll need to know.  First, some definitions.  Next to each in parens
is the variable name we'll use for it when doing calculations 
-- >
この節では仕様が何を意味するかと、その他知らなければならないことを説明しま
す。先ず最初に、定義をします。次に計算をする時に使う変数名を括弧内で示しま
す。<newline>
&lsqb;訳注 : この定義だけは対訳風にします。&rsqb;

<descrip>
<tag/horizontal sync frequency (HSF)/
	Horizontal scans per second (see above). 
<tag/水平同期周波数 (HSF)/
	毎秒の水平走査数 (上記参照) 。

<tag/vertical sync frequency (VSF) /
	Vertical scans per second (see above).  Mainly important as the upper
	limit on your refresh rate. 
<tag/垂直同期周波数 (VSF)/
	毎秒の垂直走査数 (上記参照) 。主に再描画速度の上限として重要。

<tag/dot clock (DCF)/
	More formally, `driving clock frequency'; The frequency of the
	crystal or VCO on your adaptor --- the maximum dots-per-second it can
	emit. 
<tag/ドットクロック (DCF)/
	より正式には、`駆動クロック周波数'; 時々適当に`帯域幅'と呼ぶ。
	アダプタの発信子または VCO の周波数 --- 毎秒描画可能ドット数の最大。

<tag/video bandwidth (VB)/
	The highest frequency you can feed into your monitor's video
	input and still expect to see anything discernible. If your adaptor
	produces an alternating on/off pattern, its lowest frequency is half
	the DCF, so in theory bandwidth starts making sense at DCF/2. For
	tolerably crisp display of fine details in the video image, however,
	you don't want it much below your highest DCF, and preferably higher.
<tag/ビデオ信号帯域幅 (VB)/
	モニタのビデオ入力に注ぎ込み、識別できる何かが見える事を期待すること
	が出来る最高の周波数。アダプタがオンオフ切り替えのパターンを生成した
	場合、最低の周波数は DCF の半分になります。したがって理論上の帯域幅
	は DCF/2 から始めることができると思います。精細な詳細のくっきりした
	表示を我慢するならば、最高の DCF を欲しがらないで、お好みで高めに
	しておきましょう。

<tag/frame length (HFL, VFL)/
	Horizontal frame length (HFL) is the number of dot-clock ticks
	needed for your monitor's electron gun to scan one horizontal line,
	<em>including the inactive left and right borders</em>.  Vertical
	frame length (VFL) is the number of scan lines in the
	<em>entire</em> image, including the inactive top and bottom
	borders.
<tag/フレーム長 (HFL, VFL)/
	水平フレーム長 (HFL) はモニタの電子銃が 1 つの<em>使われていない左右
	の境界を含む</em>水平線を走査するのに必要なドットクロックの数。
	垂直フレーム長 (VFL)は使われていない上と下の境界を含む
	<em>完全な</em>画面の走査線の数です。

<tag/screen refresh rate (RR)/
	The number of times per second your screen is repainted (this is
	also called "frame rate").  Higher frequencies are better, as they
	reduce flicker.  60Hz is good, VESA-standard 72Hz is better.
	Compute it as
<tscreen><verb>
	RR = DCF / (HFL * VFL)
</verb></tscreen>
<tag/画面再描画速度 (RR)/
	毎秒の画面再描画回数。高いほうがちらつきを低減します。60Hzで良く、
	VESA 標準の 72Hz の方がより良いでしょう。計算はこのようにします。
<tscreen><verb>
        RR = DCF / (HFL * VFL)
</verb></tscreen>

&lsqb;訳注 : 対訳風終り。&rsqb;

<!--
	Note that the product in the denominator is <em>not</em> the same
	as the monitor's visible resolution, but typically somewhat larger.
	We'll get to the details of this below.
-- >
	分母にある積はモニタに表示される解像度では<em>なく</em>、幾らか
	大きいことに注意してください。これについては以降で詳細に説明します。

<!--
The rates for which interlaced modes are usually specified (like 87Hz
interlaced) are actually the half-frame rates: an entire screen seems
to have about that flicker frequency for typical displays, but every
single line is refreshed only half as often.

For calculation purposes we reckon an interlaced display at its
full-frame (refresh) rate, i.e. 43.5Hz. The quality of an interlaced
mode is better than that of a non-interlaced mode with the same
full-frame rate, but definitely worse then the non-interlaced one
corresponding to the half-frame rate.
-- >
インタレースモードの周波数は実際は半分のフレームの周波数で、普通
87Hz interlaced のように指定します。:典型的なディスプレイの画面の全体
ではフリッカが出るような周波数ですが、すべての単一の線が半分の周期で
再描画されます。
計算の意図はインタレース表示の周波数を全画面フレームの再描画速度
例えば 43.5Hz から計算することです。インタレースモードは全フレーム
の周波数で表示したインタレースでないモードより表示品質は優れています。
しかし、確実に良くないことはインタレースでない周波数が半分のフレーム
の周波数に一致した時です。

</descrip>

<!--
<sect1>About Bandwidth:
-- >
<sect1>帯域幅について :
<p>

<!--
Monitor makers like to advertise high bandwidth because it constrains the
sharpness of intensity and color changes on the screen.  A high bandwidth
means smaller visible details. 

Your monitor uses electronic signals to present an image to
your eyes.  Such signals always come in in wave form once they are converted
into analog form from digitized form.  They can be considered as combinations
of many simpler wave forms each one of which has a fixed frequency, many of
them are in the Mhz range, eg, 20Mhz, 40Mhz, or even 70Mhz.  Your monitor
video bandwidth is, effectively, the highest-frequency analog signal it can
handle without distortion. 

For our purposes, bandwidth is mainly important as an approximate cutoff point
for the highest dot clock you can use. 
-- >
モニタ製造会社は帯域幅が画面の迫力と色変化のシャープさを制約するので高帯
域幅であることを宣伝します。帯域幅が大きいほど、より細かい画像を表示するこ
とができます。

モニタは電気信号を用いて画像を表示します。信号は一旦デジタルからアナログ
へと変換されると、つねにアナログ波形として取り扱われます。それは多くの、固
定した周波数の単純な波形の組合せであると考えられ、それらの多くは MHz の範
囲で例えば 20MHz、40MHz、さらに 70MHz だったりします。モニタのビデオ信号
帯域幅は事実上歪みが無く扱える高周波のアナログ信号です。

私達の目的のためには、帯域幅は主に使用可能なドットクロックのおおよその上限
として重要です。


<!--
<sect1>Sync Frequencies and the Refresh Rate:
-- >
<sect1>同期周波数と再描画速度 :
<p>

<!--
Each horizontal scan line on the display is just the visible portion of a
frame-length scan.  At any instant there is actually only one dot active on
the screen, but with a fast enough refresh rate your eye's persistence of
vision enables you to "see" the whole image.

Here are some pictures to help: 
-- >
画面上の水平走査線はフレーム長走査の中で実際に表示される部分です。それぞれ
の瞬間には本当はたった一つの点が画面に輝いているのですが、再描画速度が十分
速いので目には絶え間無く全ての画像が"見える"という訳です。

ここでいくつかの絵で解説します :

<!--
     _______________________
    |                       |     The horizontal sync frequency
    |-&gt;-&gt;-&gt;-&gt;-&gt;-&gt;-&gt;-&gt;-&gt;-&gt;-&gt; |     is the number of times per
    |                      )|     second that the monitor's
    |&lt;'-'-'-'-'-&lt;'-'-'-'-'-&lt;'-'-'-'-'-&lt;'-'-'- |     electron beam can trace
    |                       |     a pattern like this
    |                       |
    |                       |
    |                       |
    |_______________________|    
     _______________________
    |        ^              |     The vertical sync frequency
    |       ^ |             |     is the number of times per
    |       | v             |     second that the monitor's
    |       ^ |             |     electron beam can trace
    |       | |             |     a pattern like this
    |       ^ |             |
    |       | v             |
    |       ^ |             |
    |_______|_v_____________|    
-- >
<code>
     _______________________
    |                       |     水平フレーム長は秒当たり
    |-&gt;-&gt;-&gt;-&gt;-&gt;-&gt;-&gt;-&gt;-&gt;-&gt;-&gt; |     電子ビームががこのような
    |                      )|     パターンを秒当り表示
    |&lt;-----&lt;-----&lt;-----&lt;--- |     する回数です。
    |                       |
    |                       |
    |                       |
    |                       |
    |_______________________|    
     _______________________
    |        ^              |     垂直フレーム長は
    |       ^ |             |     電子ビームがこのような
    |       | v             |     パターンを秒当り表示
    |       ^ |             |     する回数です。
    |       | |             |
    |       ^ |             |
    |       | v             |
    |       ^ |             |
    |_______|_v_____________|    
</code>

<!--
Remember that the actual raster scan is a very tight zigzag pattern; that is,
the beam moves left-right and at the same time up-down. 

Now we can see how the dot clock and frame size relates to refresh rate.  By
definition, one hertz (hz) is one cycle per second.  So, if your horizontal
frame length is HFL and your vertical frame length is VFL, then to cover the
entire screen takes (HFL * VFL) ticks.  Since your card emits DCF ticks per
second by definition, then obviously your monitor's electron gun(s) can sweep
the screen from left to right and back and from bottom to top and back DCF /
(HFL * VFL) times/sec.  This is your screen's refresh rate, because it's how
many times your screen can be updated (thus <em>refreshed</em>) per second! 
-- >
実際のラスター走査はとても細かいジグザグ型のパターンをしていて、左右に電子
ビームが動いて同時に上下にも動いています。

さて、ドットクロックとフレームの大きさは再描画速度に関係があるということが
分かります。定義上、 1 ヘルツ (hz) は 1 秒に 1 周期です。それから、水平フレー
ム長を HFL とし垂直フレーム長を VFL とした場合に全ての画面を覆うには (HFL
* VFL) 回ドットクロックが必要です。カードは定義から毎秒 DCF 回信号を出して
いますので、明らかにモニタの電子銃は左から右、戻って、下から上へ、戻って
を毎秒 DCF / (HFL * VFL) 回、画面上を動き回れる訳です。これは毎秒何回画面
を<em>描き直している</em>かを表わしているので、画面の再描画速度なのです。

<!--
You need to understand this concept to design a configuration which trades off
resolution against flicker in whatever way suits your needs. 

For those of you who handle visuals better than text, here is one: 
-- >
解像度とちらつきの関係がトレードオフの関係にあるので、自分の要求に応じて設
定を行なうためにこの概念を理解する必要があります。

テキストよりは視覚に訴えた方が分かるので次に関係図を描きます。:

<code>
        RR                                      VB
         |   min HSF                     max HSF |
         |    |             R1        R2  |      |
max VSF -+----|------------/----------/---|------+----- max VSF
         |    |:::::::::::/::::::::::/:::::\     |
         |    \::::::::::/::::::::::/:::::::\    |
         |     |::::::::/::::::::::/:::::::::|   |
         |     |:::::::/::::::::::/::::::::::\   |
         |     \::::::/::::::::::/::::::::::::\  |
         |      \::::/::::::::::/::::::::::::::| |
         |       |::/::::::::::/:::::::::::::::| |
         |        \/::::::::::/:::::::::::::::::\| 
         |        /\:::::::::/:::::::::::::::::::|
         |       /  \:::::::/::::::::::::::::::::|\
         |      /    |:::::/:::::::::::::::::::::| |
         |     /     \::::/::::::::::::::::::::::| \
min VSF -+----/-------\--/-----------------------|--\--- min VSF
         |   /         \/                        |   \
         +--/----------/\------------------------+----\- DCF
           R1        R2  \                       |     \
                          min HSF                |    max HSF
                                                 VB
</code>

<!--
This is a generic monitor mode diagram.  The x axis of the diagram
shows the clock rate (DCF), the y axis represents the refresh rate
(RR). The filled region of the diagram describes the monitor's
capabilities: every point within this region is a possible video
mode. 

The lines labeled `R1' and `R2' represent a fixed resolutions (such as
640x480); they are meant to illustrate how one resolution can be realized
by many different combinations of dot clock and refresh rate. The R2
line would represent a higher resolution than R1. 
-- >
これは一般的なモニタのモードダイアグラムです。ダイアグラムの x 軸は
クロック周波数 (DCF)、
y 軸は再描画速度 (RR) を意味しています。ダイアグラムで塗り潰してある領域は
モニタのビデオに表示できる領域です。この領域のどの点をとっても表示可能です。

`R1' と `R2' のラベルをつけた線は (640x480 のような) 固定解像度を意味
しており、一つの解像度を複数の異なるドットクロックと再描画速度の組み合わせ
でどうやって実現しているかを図解したことを意味しています。R2 の線は
R1 の解像度より高い事を表しています。

<!--
The top and bottom boundaries of the permitted region are simply
horizontal lines representing the limiting values for the vertical sync
frequency. The video bandwidth is an upper limit to the clock rate and
hence is represented by a vertical line bounding the capability region on
the right.  

Under <ref id="cplot" name="Plotting Monitor Capabilities">) you'll
find a program that will help you plot a diagram like
this (but much nicer, with X graphics) for your individual monitor.
That section also discusses the interesting part; the derivation of
the boundaries resulting from the limits on the horizontal sync
frequency. 
-- >
許された領域の上と下の境界線は単に水平線が垂直同期周波数の限界値を
表しています。ビデオ信号帯域幅はクロック周波数の上限値で、故に領域
の右の垂直線の境界に当たります。

<ref id="cplot" name="モニタ性能をプロットする"> でこのようなダイアグラムを
プロットして独特のモニタの問題解決の助けにします(X graphics ではかなり役に立つでしょう)
その節ではまた興味深い水平同期周波数の限界から派生する領域の境界の
について論じます。

<!--
<sect>Tradeoffs in Configuring your System<label id="trade">
-- >
<sect>システムの構成におけるトレードオフ<label id="trade">
<p>

<!--
Another way to look at the formula we derived above is 
-- >
前に示した公式は、このように変形できます。

<tscreen><verb>
	DCF = RR * HFL * VFL
</verb></tscreen>
<!--
That is, your dot clock is fixed.  You can use those dots per second to buy 
either refresh rate, horizontal resolution, or vertical resolution.  If one
of those increases, one or both of the others must decrease. 

Note, though, that your refresh rate cannot be greater than the maximum
vertical sync frequency of your monitor.  Thus, for any given monitor at a
given dot clock, there is a minimum product of frame lengths below which you
can't force it. 
-- >
つまり、ドットクロックが一定だとすると、一秒間にこれだけのドット数を再描画
速度、水平解像度または垂直解像度に振り分けることができるということです。こ
れらの数字の一つを増やすと他の数字を減らさなければなりません。

しかし、再描画速度はモニタの最大垂直同期周波数を超えることは出来ませんの
で、注意してください。従って与えられたドットクロックで与えられたモニタで
は、自分で強制出来ないフレーム長の積の最小以下になります。

<!--
In choosing your settings, remember: if you set RR too low, you will get
mugged by screen flicker. 

You probably do not want to pull your refresh rate below 60Hz.  This is the
flicker rate of fluorescent lights; if you're sensitive to those, you need
to hang with 72Hz, the VESA ergonomic standard. 
-- >
自分の設定を選ぶ時に、RR が低すぎる場合、画面のちらつきで顔をしかめること
を覚えてください

多分、再描画速度を 60Hz 以下に下げたくは無いでしょう。蛍光燈のちらつく速さ
ですので、ちらつきに敏感な場合は VESA 人間工学標準の 72MHz に保つ必要があ
ります。

<!--
Flicker is very eye-fatiguing, though human eyes are adaptable and peoples'
tolerance for it varies widely.  If you face your monitor at a 90% viewing
angle, are using a dark background and a good contrasting color for
foreground, and stick with low to medium intensity, you *may* be comfortable
at as little as 45Hz. 
-- >
ちらつきは大変目に辛いものですが、しかし人間の目は適応し人々のちらつきに対
する耐性はかなり広範囲です。画面の 90% が見える角度でモニタに向き合って
いる場合に、暗い背景と良いコントラストの色を前景に使い、輝度を低から中に調
整するならば、<em>たぶん</em> 45Hz 位に小さくても快適でしょう。

<!--
The acid test is this: open a xterm with pure white back-ground and black
foreground using <TT>xterm -bg white -fg black</TT> and make it so large as
to cover the entire viewable area.  Now turn your monitor's intensity to 3/4 of
its maximum setting, and turn your face away from the monitor.  Try peeking at
your monitor sideways (bringing the more sensitive peripheral-vision cells into
play).  If you don't sense any flicker or if you feel the flickering is
tolerable, then that refresh rate is fine with you.  Otherwise you better
configure a higher refresh rate, because that semi-invisible flicker is going
to fatigue your eyes like crazy and give you headaches, even if the screen
looks OK to normal vision. 
-- >
厳密なテストのやり方は次の通りです : xterm -bg white -fg black で真っ白な
背景に黒の前景の xterm を開いて、表示可能な領域全てを隠すぐらいの大きさに
して下さい。そしてモニタの明かるさを最大の設定値の 3/4 に設定して、モニ
タから顔をそむけて、モニタを横目で覗いてみて下さい (これは、より敏感な
視野周辺部の細胞を働かせるためです) 。なんにもちらつきを感じない場合若しく
は許せる範囲ならば、あなたにとってその再描画速度は丁度良いのです。もしそう
でなかったら、一見大丈夫なように見えても、明らかには判からないようなちらつ
きによってひどく目が疲労し頭痛を起こしますので、普通に見える様になる迄、よ
り高い再描画速度に調整して下さい。

<!--
For interlaced modes, the amount of flicker depends on more factors
such as the current vertical resolution and the actual screen
contents.  So just experiment.  You won't want to go much below about
85Hz half frame rate, though. 

So let's say you've picked a minimum acceptable refresh rate.  In choosing
your HFL and VFL, you'll have some room for maneuver. 
-- >
インタレースモードでは、ちらつきの量は現在の仮想解像度と実際の画面の
中身に依存します。したがって実験が必要になります。半フレームの周波数を
85Hz 程度よりは低くしたくないでしょう。

このようにして最小の許容できる再描画速度を選ぶことができます。HFL と VFL
を選択するためには、多少の作戦の余地があるでしょう。
 
<!--
<sect>Memory Requirements<label id="sizes">
-- >
<sect>要求メモリ量<label id="sizes">
<p>

<!--
Available frame-buffer RAM may limit the resolution you can achieve on color or
gray-scale displays.  It probably isn't a factor on displays that have only two
colors, white and black with no shades of gray in between. 
-- >
自分が実現しようとしているカラーやグレースケールディスプレイの解像度は使用
可能なフレームバッファメモリの量で制限されます。2 色 (白黒) でグレースケー
ルでない物の場合は、制限を受けることは多分ありません。

<!--
For 256-color displays, a byte of video memory is required for each visible
dot to be shown.  This byte contains the information that determines what mix
of red, green, and blue is generated for its dot.  To get the amount of memory
required, multiply the number of visible dots per line by the number of
visible lines.  For a display with a resolution of 800x600, this would be 800
x 600 = 480,000, which is the number of visible dots on the display.  This is
also, at one byte per dot, the number of bytes of video memory that are
necessary on your adapter card. 
-- >
256 色のディスプレイの場合は、ビデオメモリのバイト数は表示されるドットの数
だけ必要です。このバイト数は赤緑青から成る集合の点を 1 点とした数です。必要
なメモリ量を得るには、線 1 本当たりに表示される点の数に表示される線の数を掛
けて下さい。800x600 の解像度を持つディスプレイの場合は、ディスプレイに表示
する点の数は 800 x 600 = 480,000 になります。また、 1 ドットが 1 バイトに成
るので、アダプタカードに同じバイト数のビデオメモリが必要です。

<!--
Thus, your memory requirement will typically be (HR * VR)/1024 Kbytes of VRAM,
rounded up.  If you have more memory than strictly required, you'll have extra
for virtual-screen panning. 
-- >
従って、メモリ量は、一般に (HR * VR)/1024 をキロバイト単位に切り上げた物が
必要です。例を挙げれば、 (936 * 702)/1024 = 642K バイトとなります。従って
1M バイトのメモリがあれば、余りを仮想スクリーンに割り当ててスクロール出来
ます。
                 
<!--
However, if you only have 512K on board, then you can't use this
resolution.  Even if you have a good monitor, without enough video
RAM, you can't take advantage of your monitor's potential.  On the
other hand, if your SVGA has one meg, but your monitor can display at
most 800x600, then high resolution is beyond your reach anyway (see
<ref id="inter" name="Using Interlaced Modes"> for a possible
remedy).
-- >
ところが、ボードに 512K しか無い場合はこの解像度は使えません。良いモニタ
を持っていたとしても、十分なビデオメモリが無しにはモニタの性能を活かすこ
とは出来ません。また一方で、SVGA カードが 1M バイトのメモリを持っていたと
しても、モニタが最高で 800x600 しか表示できないならば、これ以上の高解像
度はどうやっても無理というものです。

<!--
Don't worry if you have more memory than required; XFree86 will make
use of it by allowing you to scroll your viewable area (see the
Xconfig file documentation on the virtual screen size parameter).
Remember also that a card with 512K bytes of memory really doesn't
have 512,000 bytes installed, it has 512 x 1024 = 524,288 bytes. 
-- >
要求量より多いメモリを持っていても心配しないで下さい。XFree86 は余ったメモ
リで表示領域をスクロールできるようにします (仮想スクリーンの大きさのパラメ
ータについての Xconfig ファイルの文書を参照して下さい) 。また、512K バイト
のメモリを搭載したカードは 512,000 バイトではなく、本当は 512 x 1024 =
524,288 バイトのメモリが搭載されていることを覚えていて下さい。

<!--
If you're running SGCS X (now called X/Inside) using an S3 card, and
are willing to live with 16 colors (4 bits per pixel), you can set
depth 4 in Xconfig and effectively double the resolution your card can
handle.  S3 cards, for example, normally do 1024x768x256.  You can
make them do 1280x1024x16 with depth 4. 
-- >
S3 カードで SGCS X が動作していて、かつ 16 色 ( 1 ピクセル当たり 4 ビット) 
の場合、Xconfig ファイルで 深度 4 と設定すれば、カードは倍の解像度を使えま
す。例えば、S3 カードは通常 1024x768x256  (1024x768 の解像度で 256 色) で
すが、深度 4 にすれば 1280x1024x16  (1280x1024 の解像度で 16 色) が使える
ようになります。<newline>
&lsqb;訳注 : 深度とは色数やグレースケールを表現するビット数です。&rsqb;

<!--
<sect>Computing Frame Sizes<label id="frame">
-- >
<sect>フレームサイズの計算<label id="frame">
<p>

<!--
Warning: this method was developed for multisync monitors.  It will probably
work with fixed-frequency monitors as well, but no guarantees! 

Start by dividing DCF by your highest available HSF to get a horizontal
frame length. 
-- >
警告 : この方法はマルチシンクモニタのために開発しました。多分、この方法
は固定周波数モニタでうまく行くかも知れませんが、保証できません。

最初に最大の使用可能な HSF で DCF を割って、水平走査可能回数を
計算して下さい。

<!--
For example; suppose you have a Sigma Legend SVGA with a 65MHz dot clock, and
your monitor has a 55KHz horizontal scan frequency.  The quantity (DCF / HSF)
is then 1181 (65MHz = 65000KHz; 65000/55 = 1181). 
-- >
例えば、 65MHz のドットクロックの Sigma Legend SVGA カードと、55KHz の水平
走査周波数のモニタを使っていると仮定します。DCF / HSF を計算すると 1181
という量が得られます。

<!--
Now for our first bit of black magic.  You need to round this figure to the
nearest multiple of 8.  This has to do with the VGA hardware controller used by
SVGA and S3 cards; it uses an 8-bit register, left-shifted 3 bits, for what's
really an 11-bit quantity.  Other card types such as ATI 8514/A may not have
this requirement, but we don't know and the correction can't hurt.  So round
the usable horizontal frame length figure down to 1176. 
-- >
さあ、最初の黒魔術の技の片鱗を使いましょう。この式の答えをもっとも近い 8
の倍数に丸めて下さい。これは 8 ビットレジスタを持ち、左に 3 ビットずらして
11 ビットの値を得るような SVGA と S3 の VGA 制御装置において有効です。 ATI
8514/A のような他のカードではこのような要求はないかも知れませんが、我々は
正確な知識を持ち合わせてはいませんし、丸めによって不都合なことが生じること
はありません。従って水平走査可能回数を 1176 に丸めます。

<!--
This figure (DCF / HSF rounded to a multiple of 8) is the minimum HFL you can
use.  You can get longer HFLs (and thus, possibly, more horizontal dots on the
screen) by setting the sync pulse to produce a lower HSF.  But you'll pay with
a slower and more visible flicker rate. 
-- >
この数字 (DCF / HSF を 8 の倍数に丸めたもの) は最小の HFL として用いること
が出来ます。より低い HSF で同期信号を設定すれば、もっと長い HFL  (つまり、
多分より多くの画面の水平方向のドット数) が得られます。しかし、遅くてより多
く見えるちらつきの速度に復讐されるでしょう。

<!--
As a rule of thumb, 80% of the horizontal frame length is available for
horizontal resolution, the visible part of the horizontal scan line (this
allows, roughly, for borders and sweepback time '-'- that is, the time required
for the beam to move from the right screen edge to the left edge of the next
raster line).  In this example, that's 944 ticks. 
-- >
経験的な法則では、水平フレーム長の 80% が水平解像度として使用可能で、水平
走査線の表示される部分 (これは大体、境界と電子ビームが画面の右端から次の走
査線の左端へ戻ってくる時間を差し引いたもの) です。この例では、944 になりま
す。

<!--
Now, to get the normal 4:3 screen aspect ratio, set your vertical resolution
to 3/4ths of the horizontal resolution you just calculated.   For this
example, that's 708 ticks.  To get your actual VFL, multiply that by 1.05
to get 743 ticks. 
-- >
さて、通常の画面のアスペクト比 (横縦比) 4:3 を得るため、今計算した水平解像
度の 3/4 になるように垂直解像度を設定しましょう。この例では、708 になりま
す。実際の VFL を得るには、1.05 を掛けて 743 になります。

<!--
The 4:3 is not technically magic; nothing prevents you from using a
non-Golden-Section ratio if that will get the best use out of your
screen real estate.  It does make figuring frame height and frame
width from the diagonal size convenient, you just multiply the
diagonal by by 0.8 to get width and 0.6 to get height.
-- >
この 4:3 について --- 表示上の幅と高さが 4:3 の比率は大体黄金分割比の値、
(1 + sqrt(5))/2 に近い値です。人間はこの種の矩形を見て好ましいと思うように
できているようです。そのためブラウン管や 800x600, 640x480 そして 1024x768
という標準的な解像度はみなこの黄金分割比の近似値になっています。しかしこれ
は心理学的な要求であって、技術的な要求ではありません。もしその方が画面の
大きさを有効に活用できるのであれば、非黄金分割比を使うことをためらう理由は
何もありません。

<!--
So, HFL=1176 and VFL=743.  Dividing 65MHz by the product of the two gives
us a nice, healthy 74.4Hz refresh rate.  Excellent!  Better than VESA standard!
And you got 944x708 to boot, more than the 800 by 600 you were probably
expecting.  Not bad at all! 
-- >
結局、HFL=1176 と VFL=743 としました。65MHz をこの 2 つの数字の積で割ると、
十分に高くて健康に良い 74.4Hz の再描画速度が得られます。素晴らしい！
VESA 標準より立派でしょう！ おまけに、おそらく予想していた 800x600 よりも
高い 944x708 という解像度が得られたのです。本当に素晴らしい！

<!--
You can even improve the refresh rate further, to almost 76 Hz, by using the
fact that monitors can often sync horizontally at 2khz or so higher than rated,
and by lowering VFL somewhat (that is, taking less than 75% of 944 in the
example above).  But before you try this "overdriving" maneuver, if you do,
make <em>sure</em> that your monitor electron guns can sync up to 76 Hz
vertical.  (the popular NEC 4D, for instance, cannot.  It goes only up to 75 Hz
VSF).  (See <ref id="overd" name="Overdriving Your Monitor"> for more general
discussion of this issue. )
-- >
さらに (大体 76 Hz 迄) 再描画速度を改良することも可能です。これには、定格
よりも 2 KHz くらい高い水平同期周波数でも動くモニタが多いという事実と、
VFL を幾らか下げる (つまり、上の例で言うと 944 の 75% よりも小さくする) こ
とを利用します。しかしこの "オーバードライブ" 作戦を試してみる前に、あなた
のモニタの電子銃が垂直同期を 76 Hz 以上でできることを<em>確認</em>してくださ
い。 (例えば、人気のある NEC 4D ではこれは出来ません。これは 75 Hz 迄の
VSF のみが利用できます。) 

<!--
So far, most of this is simple arithmetic and basic facts about raster
displays.  Hardly any black magic at all! 
-- >
以上が、ラスタ表示についての単純な計算と基本的な事柄のほとんどです。ほと
んど黒魔術でも何でも無いですね。

<!--
<sect>Black Magic and Sync Pulses<label id="magic">
-- >
<sect> 黒魔術と同期信号
<p>

<!--
OK, now you've computed HFL/VFL numbers for your chosen dot clock, found the
refresh rate acceptable, and checked that you have enough VRAM.  Now for the
real black magic '-'- you need to know when and where to place synchronization
pulses. 
-- >
さあ、自分で選んだドットクロック対応に計算した HFL/VFL の数字があり、無難
な再描画速度が見つかり、十分な VRAM  (ビデオメモリ) があることを確認しまし
た。これからが本当の黒魔術です -- いつどこで同期信号を出すかを知る必要があ
ります。

<!--
The sync pulses actually control the horizontal and vertical scan frequencies
of the monitor.  The HSF and VSF you've pulled off the spec sheet are nominal,
approximate maximum sync frequencies.  The sync pulse in the signal from the
adapter card tells the monitor how fast to actually run. 
-- >
同期信号が実際にモニタの水平及び垂直の走査周波数を制御しています。仕様表
から引っぱり出してきた HSF と VSF は定格上の最大同期周波数の推定値です。ア
ダプタカードからの信号の中の同期信号はモニタにどれくらい速く実際に動作す
るか伝えます。

<!--
Recall the two pictures above?  Only part of the time required for
raster-scanning a frame is used for displaying viewable image (ie. your
resolution). 
-- >
上記の 2 つの絵を思い出して下さい。目に見える画像 (あなたの選んだ解像度) 
を表示するために使われるのは、フレームをラスタ走査するために必要な時間の
一部だけです。

<!--
<sect1>Horizontal Sync:
-- >
<sect1>水平同期 :
<p>

<!--
By previous definition, it takes HFL ticks to trace the a horizontal scan line.
Let's call the visible tick count (your horizontal screen resolution) HR.  Then
Obviously, HR < HFL by definition.  For concreteness, let's assume both start
at the same instant as shown below: 
-- >
前の定義によれば、 1 本の水平走査線をたどるのには HFL 分の時間掛かります。
表示される部分のクロック回数 (水平スクリーン解像度) を HR と呼びましょう。
その時は明らかに、定義から HR < HFL となります。具体的に両方が同時に開始し
たと仮定して次に示します :
<!--
  |___ __ __ __ __ __ __ __ __ __ __ __ __
  |_ _ _ _ _ _ _ _ _ _ _ _                |
  |_______________________|_______________|_____ 
  0                       ^               ^     unit: ticks
                          |   ^       ^   |
                          HR  |       |  HFL
                          |   |&lt;-----&gt;|   |
                          |&lt;-&gt;|  HSP  |&lt;-&gt;|
                          HGT1         HGT2
-- >
<code>
  |___ __ __ __ __ __ __ __ __ __ __ __ __
  |_ _ _ _ _ _ _ _ _ _ _ _                |
  |_______________________|_______________|_____
  0                       ^               ^     単位: 水平クロック
                          |   ^       ^   |
                          HR  |       |  HFL
                          |   |&lt;-----&gt;|   |
                          |&lt;-&gt;|  HSP  |&lt;-&gt;|
                          HGT1         HGT2
</code>
                  
<!--
Now, we would like to place a sync pulse of length HSP as shown above, ie,
between the end of clock ticks for display data and the end of clock ticks for
the entire frame.  Why so?  because if we can achieve this, then your screen
image won't shift to the right or to the left.  It will be where it supposed to
be on the screen, covering squarely the monitor's viewable area. 
-- >
ここで、上にあるように表示データのクロック終了とフレーム全体のクロック終了
の間に HSP の同期信号長を配置します。何故そうするのか？ それはこうすると、
画面表示が左右に移動しなくなるからです。表示をスクリーン上で表示されるべき
場所、つまりモニタの表示可能領域内にきっちりとおさめるためです。

<!--
Furthermore, we want about 30 ticks of "guard time" on either side of the sync
pulse.  This is represented by HGT1 and HGT2.  In a typical configuration HGT1
!= HGT2, but if you're building a configuration from scratch, you want to start
your experimentation with them equal (that is, with the sync pulse centered). 
-- >
その上、同期信号の両側に "保護時間" として約 30 クロック必要です。HGT1 と
HGT2 で表わしています。一般的には HGT1 は HGT2 と等しくありませんが、しか
し真っさらの状態から設定を行うならば、2 つを等しくして実験を始めたら良いで
しょう (それは同期信号を中央に置くことになります) 。

<!--
The symptom of a misplaced sync pulse is that the image is displaced on the
screen, with one border excessively wide and the other side of the image
wrapped around the screen edge, producing a white edge line and a band of
"ghost image" on that side.  A way-out-of-place vertical sync pulse can
actually cause the image to roll like a TV with a mis-adjusted vertical hold
(in fact, it's the same phenomenon at work). 
-- >
同期信号の置き違えの症状は、1 つの境界が極端に広くなって画像の他の側が画面
の端から回り込んだり、白い端の線と"お化け画像"の帯になったり、画面の画像表
示のずれとして現われます。垂直同期信号抜けは垂直保持が調節不備になっている
TV の様に実際に縦スクロールします (事実、同じ現象が起こります) 。

<!--
If you're lucky, your monitor's sync pulse widths will be documented on its
specification page.  If not, here's where the real black magic starts... 

You'll have to do a little trial and error for this part.  But most of the
time, we can safely assume that a sync pulse is about 3.5 to 4.0 microsecond
in length. 
-- >
幸運ならば、モニタの同期信号の幅がその仕様書に記載されているでしょう。記
載がない場合には、ここからが本当の黒魔術の始まり、、、

ここでは少し試行錯誤を行う必要があるでしょう。しかしほとんどの場合には、同
期信号を約 3.5 から 4.0 マイクロ秒と仮定すれば安全です。

<!--
For concreteness again, let's take HSP to be 3.8 microseconds (which btw, is not
a bad value to start with when experimenting). 

Now, using the 65Mhz clock timing above, we know HSP is equivalent to 247 clock
ticks (= 65 * 10**6 * 3.8 * 10^-6) [recall M=10^6, micro=10^-6] 
-- >
具体的には、HSP を 3.8 マイクロ秒にしましょう (この値は実験を始めるに当た
っては悪い値ではありません) 。

さて、先ほど 65Mhz をクロックに使いましたから、HSP を 247 クロック分と等し
くすればよいことがわかります。( 247 = 65 * 10**6 * 3.8 * 10^-6)
&lsqb;メガ=10^6, マイクロ=10^-6 である事を思い出して下さい&rsqb;

<!--
Some makers like to quote their horizontal framing parameters as timings rather
than dot widths.  You may see the following terms:
-- >
幾つかの製造会社はドット幅より水平方向のフレームパラメタで見積もっています。
次の用語を御覧下さい。:

<descrip>
<!--
<tag/active time (HAT)/
	Corresponds to HR, but in milliseconds.  HAT * DCF = HR.
<tag/blanking time (HBT)/
	Corresponds to (HFL - HR), but in milliseconds.  HBT * DCF = (HFL -
	HR).
<tag/front porch (HFP)/
	This is just HGT1.
<tag/sync time/
	This is just HSP.
<tag/back porch (HBP)/
	This is just HGT2.
-- >
<tag/active time (HAT)/
稼働時間 (HAT)
	ミリ秒に換算した HR に相当.  HAT * DCF = HR.
<tag/blanking time (HBT)/
空白時間 (HBT)
	ミリ秒に換算した (HFL - HR) に相当.  HBT * DCF = (HFL - HR).
<tag/front porch (HFP)/
フロントポーチ (HFP)
	まさしく HGT1 です.
<tag/sync time/
同期時間
	まさしく HSP です.
<tag/back porch (HBP)/
バックポーチ (HBP)
	まさしく HGT2 です.
</descrip>

<!--
<sect1>Vertical Sync:
<p>
-- >
<sect1>垂直同期 :
<p>

<!--
Going back to the picture above, how do we place the 247 clock ticks as shown
in the picture? 

Using our example, HR is 944 and HFL is 1176.  The difference between the two
is 1176 - 944=232 < 247!  Obviously we have to do some adjustment here.  What
can we do? 
-- >
前の絵に戻って、247 クロック分を絵の中でどのように置いたらいいでしょう？

この例では、HR は 944 で HFL は 1176 です。この 2 つの例の差は
1176-944=232 &lt; 247です! 明らかにこの違いを調整しなければいけません。何が
できるでしょうか？

<!--
The first thing is to raise 1176 to 1184, and lower 944 to 936.  Now the
difference = 1184-936= 248. Hmm, closer. 

Next, instead using 3.8, we use 3.5 for calculating HSP; then, we have
65*3.5=227.  Looks better.  But 248 is not much higher than 227.  It's normally
necessary to have 30 or so clock ticks between HR and the start of SP, and the
same for the end of SP and HFL.  AND they have to be multiple of eight!  Are we
stuck? 
-- >
最初に 1176 は 1184 へ上げて、 944 は 936 へ下げてください。さて、違いは
1184-936= 248 になりました。う〜ん、近づきましたね。

次は HSP を計算するのに 3.8 の代わりに、3.5 を使うようにすると、
65*3.5=227 となります。かなり良くなりました。しかし 248 は 227 よりそれほ
ど大きくありません。HR と SP の開始点の間と SP の終了点と HFL の間に 30 か
それぐらいあける必要があります。そして、それらは 8 の倍数にしなければなり
ません ! 我々はここで行き詰まってしまったのでしょうか ?

<!--
No.  Let's do this, 936 % 8 = 0, (936 + 32) % 8 = 0 too.  But 936 + 32 = 968,
968 + 227 = 1195, 1195 + 32 = 1227.  Hmm.. this looks not too bad.  But it's
not a multiple of 8, so let's round it up to 1232. 

But now we have potential trouble, the sync pulse is no longer placed right in
the middle between h and H any more.  Happily, using our calculator we find
1232 - 32 = 1200 is also a multiple of 8 and (1232 - 32) - 968 = 232
corresponding using a sync pulse of 3.57 micro second long, still
reasonable. 
-- >
いいえ！ こうしてみましょう、936&percnt 8==0 です、また (936+32)&percnt 8==0
です。しかし、936+32=968、968+227=1195、1195+32=1227 となります。ふむふむ、
そんなに悪くはありません。しかし、8 の倍数にはなっていませんので、1232 に
丸めて下さい。

しかし、同期信号を HR と HFL のちょうど真ん中に置くことが出来ないという潜
在的な困難があります。幸いにも、1232-32=1200 も 8 の倍数である事と、
(1232-32)-968=232 は 3.57 マイクロ秒 (232/65) という妥当な長さの同期信号に
対応することが計算でわかります。

<!--
In addition, 936/1232 ~ 0.76 or 76%, still not far from 80%, so it should be
all right. 

Furthermore, using the current horizontal frame length, we basically ask our
monitor to sync at 52.7khz (= 65Mhz/1232) which is within its capability.  No
problems. 
-- >
さらに、 936/1232 は大体 0.76 つまり 76&percnt, ですが、80&percnt からそう
遠くないのでまあ大丈夫でしょう。

その上、現在の水平フレーム長を使うなら、基本的にはモニタがその能力内で
52.7KHz(=65MHz/1232) において同期が取れるかどうか調べましょう。問題は無い
でしょう。
       
<!--
Using rules of thumb we mentioned before, 936*75%=702, This is our new vertical
resolution.  702 * 1.05 = 737, our new vertical frame length. 

Screen refresh rate = 65Mhz/(737*1232)=71.6 Hz.  This is still excellent. 

Figuring the vertical sync pulse layout is similar: 
-- >
経験則から、上記の 936*75&percnt=702 を新しい垂直解像度にしましょう。
702*1.05=737 が新しい垂直フレーム長になります。

画面再描画速度は 65Mhz/(737*1232)=71.6 Hz になります。それでも素晴らしいで
すね。

同様に垂直同期信号の配置を図解します :
<!--
   |___ __ __ __ __ __ __ __ __ __ __ __ __
   |_ _ _ _ _ _ _ _ _ _ _ _                |
   |_______________________|_______________|_____ 
   0                      VR              VFL     unit: ticks
                           ^   ^       ^
                           |   |       |
                           |&lt;-&gt;|&lt;-----&gt;|
                            VGT    VSP
-- >
<code>
   |___ __ __ __ __ __ __ __ __ __ __ __ __
   |_ _ _ _ _ _ _ _ _ _ _ _                |
   |_______________________|_______________|_____
   0                      VR              VFL     単位: 垂直クロック
                           ^   ^       ^
                           |   |       |
                           |&lt;-&gt;|&lt;-----&gt;|
                            VGT    VSP
</code>

<!--
We start the sync pulse just past the end of the vertical display data ticks.
VGT is the vertical guard time required for the sync pulse.  Most monitors are
comfortable with a VGT of 0 (no guard time) and we'll use that in this
example.  A few need two or three ticks of guard time, and it usually doesn't
hurt to add that. 

Returning to the example: since by the definition of frame length, a vertical
tick is the time for tracing a complete HORIZONTAL frame, therefore in our
example, it is 1232/65Mhz=18.95us. 
-- >
垂直表示データの終了時きっかりに同期信号を発信します。VGT は同期信号の垂直
保護時間です。ほとんどのモニタは VGT 無し (保護時間無し) で快適に動作し、
例題でも保護時間無しです。2,3 クロックの保護時間が必要なものもありますが、
保護時間を入れて不都合が生じることは普通ありません。

例題に戻りましょう : フレーム長の定義から、垂直クロックは全<em>水平</em>フレー
ムを辿る時間ですので、例題では 1232/65Mhz=18.95 マイクロ秒になります。

<!--
Experience shows that a vertical sync pulse should be in the range of 50us and
300us.  As an example let's use 150us, which translates into 8 vertical clock
ticks (150us/18.95us~8). 

Some makers like to quote their vertical framing parameters as timings rather
than dot widths.  You may see the following terms:
-- >
実験によれば垂直同期のパルス幅は 50 マイクロ秒から 300 マイクロ秒の範囲に
設定すべきです。例題では 8 垂直クロック分、150 マイクロ秒を使用します
(150 マイクロ秒 / 18.95 マイクロ秒 ~ 8)。

幾つかの製造会社はドット幅より垂直方向のフレームパラメタで見積もっています。
次の用語を御覧下さい。:

<descrip>
<!--
<tag/active time (VAT)/
	Corresponds to VR, but in milliseconds.  VAT * VSF = VR.
<tag/blanking time (VBT)/
	Corresponds to (VFL - VR), but in milliseconds.  VBT * VSF = (VFL - VR).
<tag/front porch (VFP)/
	This is just VGT.
<tag/sync time/
	This is just VSP.
<tag/back porch (VBP)/
	This is like a second guard time after the vertical sync pulse.  It
	is often zero.
-- >
<tag/active time (VAT)/
稼働時間 (VAT)
	ミリ秒に換算した VR に相当.  VAT * VSF = VR.
<tag/blanking time (VBT)/
空白時間
	ミリ秒に換算した (VFL - VR) に相当.  VBT * VSF = (VFL - VR).
<tag/front porch (VFP)/
フロントポーチ (VFP)
	まさしく VGT です.
<tag/sync time/
同期時間
	まさしく VSP です.
<tag/back porch (VBP)/
バックポーチ (VBP)
	垂直同期信号の後の第 2 保護時間に似ています。しばしばゼロです。
</descrip>

<!--
<sect>Putting it All Together<label id="synth">
-- >
<sect>全体のまとめ<label id="synth">
<p>

<!--
The Xconfig file Table of Video Modes contains lines of numbers, with each line
being a complete specification for one mode of X-server operation.  The fields
are grouped into four sections, the name section, the clock frequency section,
the horizontal section, and the vertical section. 

The name section contains one field, the name of the video mode specified by
the rest of the line.  This name is referred to on the "Modes" line of the
Graphics Driver Setup section of the Xconfig file.  The name field may be
omitted if the name of a previous line is the same as the current line. 
-- >
Xconfig ファイルのビデオモード ( Video Modes ) 表は数行の数列で出来ていて、
それぞれの行は X サーバが使用する 1 つのモードの完全な仕様を表わしていま
す。その項目は名称節、ドットクロック節、水平節、垂直節の 4 つの節に分けら
れます。

名称節は 1 項目で、行の残りで指定しているビデオモードの名称です。この名称は、
Xconfig ファイルのグラフィックドライバ設定節の "Modes" 行で参照されます。
現在の行が前の行と同じ名称ならば名称は省略出来ます。

<!--
The dot clock section contains only the dot clock (what we've called DCF) field
of the video mode line.  The number in this field specifies what dot clock was
used to generate the numbers in the following sections. 

The horizontal section consists of four fields which specify how each
horizontal line on the display is to be generated.  The first field of the
section contains the number of dots per line which will be illuminated to form
the picture (what we've called HR).  The second field of the section indicates
at which dot the horizontal sync pulse will begin.  The third field indicates
at which dot the horizontal sync pulse will end.  The fourth field specifies
the total horzontal frame length (HFL). 
-- >
ドットクロック節はビデオモード行の項目に DCF と呼んでいたドットクロックの
みを書きます。次の節で作成する数字をドットクロックとしてこの項目に書きます。

水平節はそれぞれの水平線を画面の上でどのように作成するかを 4 項目で書きま
す。最初の項目は HR と呼んでいた映像を構成する輝く 1 本が何ドットであるかを
書きます。 2 番目の項目はどのドットから水平同期信号が始まるかを示します。
3 番目の項目はどのドットで水平同期信号が終わるかを示します。 4 番目の項目
は全水平フレーム長 (HFL) を指定します。

<!--
The vertical section also contains four fields.  The first field contains the
number of visible lines which will appear on the display (VR).  The second
field indicates the line number at which the vertical sync pulse will begin.
The third field specifies the line number at which the vertical sync pulse will
end.  The fourth field contains the total vertical frame length (VFL). 
-- >
垂直節も 4 項目で書きます。最初の項目は画面上に表示される走査線の数を書き
ます (VR)。 2 番目の項目は垂直同期信号が何番目の線から始まるかを書きます。
3 番目の項目は垂直同期信号が何番目の線で終わるかを書きます。4 番目の項目は
全垂直フレーム長を書きます。

<!--
Example: 
-- >
例 :
<!--
     #Modename    clock  horizontal timing  vertical timing

     "752x564"     40    752 784  944 1088  564 567 569 611
	           44.5  752 792  976 1240  564 567 570 600
-- >
<tscreen><verb>
     #名称節 モードクロック節 水平節(1から4) 垂直節(1から4)
     #Modename    clock  horizontal timing  vertical timing

     "752x564"     40    752 784  944 1088  564 567 569 611
	           44.5  752 792  976 1240  564 567 570 600
</verb></tscreen>
<!--
(Note: stock X11R5 doesn't support fractional dot clocks.) 
-- >
(注意 : 標準的な X11R5 そのままでは 小数のドットクロックは使えません。)

<!--
For Xconfig, all of the numbers just mentioned - the number of illuminated dots
on the line, the number of dots separating the illuminated dots from the
beginning of the sync pulse, the number of dots representing the duration of
the pulse, and the number of dots after the end of the sync pulse - are added
to produce the number of dots per line.  The number of horizontal dots must be
evenly divisible by eight. 

Example horizontal numbers: 800 864 1024 1088 
-- >
Xconfig では、線上で輝いているドットの数、輝いているドットから同期信号の開
始点までのドット数、同期信号の持続時間分のドット数と同期信号の終了点から後
のドット数、これらを足し合わせると 1 本当たりのドット数が計算できます。水平
方向のドット数は一律に 8 で割り切れる数値でなければいけません。

例 :

<!--
This sample line has the number of illuminated dots (800) followed by the
number of the dot when the sync pulse starts (864), followed by the number of
the dot when the sync pulse ends (1024), followed by the number of the last dot
on the horizontal line (1088). 

Note again that all of the horizontal numbers (800, 864, 1024, and 1088) are
divisible by eight!  This is not required of the vertical numbers. 
-- >
     水平方向の数値 : 800 864 1024 1088

  この例は輝いているドット数 (800)、
  続いて同期開始点のドット (864)、
  その次が同期終了点のドット (1024)、
  次は水平線の最後のドット (1088) となります。

全ての水平方向の数字 (800、864、1024 と 1088) は 8 で割り切れる事にもう一
度注意をして下さい。これは垂直方向の数字には当てはまりません。

<!--
The number of lines from the top of the display to the bottom form the frame.
The basic timing signal for a frame is the line.  A number of lines will
contain the picture.  After the last illuminated line has been displayed, a
delay of a number of lines will occur before the vertical sync pulse is
generated.  Then the sync pulse will last for a few lines, and finally the last
lines in the frame, the delay required after the pulse, will be generated.  The
numbers that specify this mode of operation are entered in a manner similar to
the following example. 

Example vertical numbers: 600 603 609 630 
-- >
画面の上から下までの線の数がフレームを構成します。フレームの基本的な時間調
整は線で行ないます。線の多くは画像を表示するために使われます。最後の発光す
る線を表示した後で、数本分遅延が挿入され、その後垂直同期信号が生成されます。
そして同期信号は数本分だけ持続し、フレームの最後に同期信号の後で必要な遅延
が生成されます。この動作モードを規定する数値は、次の例のように入力します。

例 :

  垂直方向の数値 : 600 603 609 630

<!--
This example indicates that there are 600 visible lines on the display, that
the vertical sync pulse starts with the 603rd line and ends with the 609th, and
that there are 630 total lines being used. 

Note that the vertical numbers don't have to be divisible by eight! 
-- >
  この例はディスプレイに 600 本の線が表示され、603 番目の線
  から垂直同期が始まり 609 番目で終わる事、そして全部で 630 本
  の線を使用することを表わしています。

垂直方向の数値は 8 で割り切れる値でなくても構いません。

<!--
Let's return to the example we've been working.  According to the above, all
we need to do from now on is to write our result into Xconfig as follows: 
<tscreen><verb>
<name>   DCF     HR  SH1 SH2   HFL   VR  SV1 SV2 VFL
</verb></tscreen>
-- >
例題に戻りましょう。上記によって、Xconfig へ書き込む必要な全ての値
は次の様です:

<tscreen><verb>
&lt name &gt   DCF     HR  SH1 SH2   HFL   VR  SV1 SV2 VFL
</verb></tscreen>
<!--
where SH1 is the start tick of the horizontal sync pulse and SH2 is its end
tick; similarly, SV1 is the start tick of the vertical sync pulse and SV2 is
its end tick. 
<tscreen><verb>
#name    clock   horizontal timing   vertical timing    flag
936x702  65      936 968 1200 1232   702 702 710 737
</verb></tscreen>
-- >
ここで SH1 は水平同期信号の開始クロックで、SH2 はその終了クロックになり、
同様に SV1 は垂直同期信号の開始クロックで、SV2 はその終了クロックです。

<tscreen><verb>
#名称節 モードクロック節 水平節(1から4) 垂直節(1から4) オプション
#name    clock   horizontal timing   vertical timing    flag
936x702  65      936 968 1200 1232   702 702 710 737
</verb></tscreen>
<!--
No special flag necessary; this is a non-interlaced mode.  Now we are really
done.
-- >
特別なオプションは必要無く、これはノンインタレースモードで動作します。
これで完了しました。

<!--
<sect>Overdriving Your Monitor<label id="overd">
-- >
<sect>モニタの仕様外使用<label id="overd">
<p>

<!--
You should absolutely <EM>not</EM> try exceeding your monitor's scan
rates if it's a fixed-frequency type.  You can smoke your hardware
doing this!  There are potentially subtler problems with overdriving a
multisync monitor which you should be aware of.  
-- >
固定周波数型のモニタの場合、モニタの規定走査周波数を超えては絶対に
<EM>なりません</EM>。これをやってしまうと機器から煙を出してしまうかも知れま
せん!
マルチシンクモニタでも、周波数を上げるとこれよりは些細ながらいろいろな問題が
出る可能性がありますので、心に止めておかなければなりません。

<!--
Having a pixel clock higher than the monitor's maximum bandwidth is
rather harmless, in contrast.  (Note: the theoretical limit of
discernible features is reached when the pixel clock reaches double
the monitor's bandwidth.  This is a straightforward application of
Nyquist's Theorem: consider the pixels as a spatially distributed
series of samples of the drive signals and you'll see why.) 
-- >
モニタの最高周波数帯域より高いピクセルクロックを使っても、比較的無害です。
(注意: ピクセルクロックがモニタの帯域幅の倍になると、認識可能機能の理論的な
限界に達してしまいます。これは 空間軸上に離散した駆動信号の標本系列に関する
 Nyquist の理論の単純な応用で、どうしてだかはおわかりですね。)

<!--
It's exceeding the rated maximum sync frequencies that's problematic.
Some modern monitors might have protection circuitry that shuts the
monitor down at dangerous scan rates, but don't rely on it.  In
particular there are older multisync monitors (like the Multisync II)
which use just one horizontal transformer. These monitors will not
have much protection against overdriving them.  While you necessarily
have high voltage regulation circuitry (which can be absent in fixed
frequency monitors), it will not necessarily cover every conceivable
frequency range, especially in cheaper models. This not only implies
more wear on the circuitry, it can also cause the screen phosphors to
age faster, and cause more than the specified radiation (including X-rays)
to be emitted from the monitor. 
-- >
過度に最大とみなしている同期周波数は疑わしいです。
最近のモニタの中には、危険な走査周波数に対してモニタを消すような保護回路を
装備しているものもありますが、これを過信してはなりません。特に、水平同期用の
トランスを一つしか持っていない(Multisync II のような)古いマルチシンクモニタ
もあります。これらのモニタを過負荷から保護する事はできません。高電圧安定回路
は確実に備わっていますが(固定周波数型のモニタには無い可能性があります)、
特に安いモニタでは、かならずしも考えられるすべての
周波数帯域をカバーしているとは限りません。このため、電子回路が傷むのが速いだ
けでなく、画面の発光体も速く傷み、規定以上の(X 線を含む) 放射線がモニタから
放出されることになります。

<!--
Another importance of the bandwidth is that the monitor's input
impedance is specified only for that range, and using higher
frequencies can cause reflections probably causing minor screen
interferences, and radio disturbance. 
-- >
帯域についてもうひとつ大切なことは、モニタの入力インピーダンスはモニタの
帯域内だけで規定されているので、高い周波数を使うと反射が起こり、軽い
画面上の干渉と電波障害が起こる可能性があります。

<!--
However, the basic problematic magnitude in question here is the slew
rate (the steepness of the video signals) of the video output drivers,
and that is usually independent of the actual pixel frequency, but
(if your board manufacturer cares about such problems) related
to the maximum pixel frequency of the board. 

So be careful out there... 
-- >
しかしながら、ここで問題となっている本質的な問題部分は、ビデオ出力
ドライバ回路のスルーレート (ビデオ信号の立ち上がりの傾斜) で、これは通常
実際のピクセル周波数とは無関係ですが、(ボードの製造者がこのような問題に
注意を払っていれば) ボードの最大ピクセル周波数と関連があります。

これらに注意しつつ作業をしましょう、、、

<!--
<sect>Using Interlaced Modes<label id="inter">
-- >
<sect>インタレースモードを使用する<label id="inter">
<p>

<!--
(This section is largely due to David Kastrup
&lt;dak@pool.informatik.rwth-aachen.de&gt) 

At a fixed dot clock, an interlaced display is going to have
considerably less noticeable flicker than a non-interlaced display, if
the vertical circuitry of your monitor is able to support it stably.
It is because of this that interlaced modes were invented in the first
place. 
-- >
(この節は殆んど David Kastrup
&lt;dak@pool.informatik.rwth-aachen.de&gt によります)

固定のドットクロックでは、モニタの垂直同期回路が安定してサポート
できるなら、ノンインタレース画面よりもインタレース画面
の方が目につくちらつきがかなり少なくなります。
インタレースモードが最初に開発されたのは、このためです。

<!--
Interlaced modes got their bad repute because they are inferior to
their non-interlaced companions at the same vertical scan frequency,
VSF (which is what is usually given in advertisements). But they are
definitely superior at the same horizontal scan rate, and that's where
the decisive limits of your monitor/graphics card usually lie. 
-- >
インタレースモードは、同じ垂直走査周波数 すなわちVSF(通常広告に良く使われて
います)
のノンインタレースモードの同等品より劣るという悪評をかっていました。
しかし、インタレースモードは同じ水平走査周波数では確実に優れていて、
普通はそこでモニタやグラフィックボードの明白な限界が見えてくるものです。

<!--
At a fixed <EM>refresh rate</EM> (or half frame rate, or VSF) the
interlaced display will flicker more: a 90Hz interlaced display will
be inferior to a 90Hz non-interlaced display. It will, however, need
only half the video bandwidth and half the horizontal scan rate. If
you compared it to a non-interlaced mode with the same dot clock and
the same scan rates, it would be vastly superior: 45Hz non-interlaced
is intolerable. With 90Hz interlaced, I have worked for years with my
Multisync 3D (at 1024x768) and am very satisfied. I'd guess you'd need
at least a 70Hz non-interlaced display for similar comfort. 
-- >
固定の<EM>再描画速度</EM> (すなわちフレーム周波数の半分、つまり VSF) で
は、インタレースのディスプレイはちらつきがより多く見えます。たとえば、
90Hz のインタレースディスプレイは 90Hz のノンインタレースディスプレイ
より劣ります。けれども、半分のビデオ信号帯域幅と半分の水平走査速度ですみます。
同じドットクロックと同じ走査速度でノンインタレースディスプレイと比べたら、
インタレースディスプレイのほうがずっとよく見えるでしょう。
45Hz のノンインタレースディスプレイなどは、お話になりません。
私は、90Hz のインタレースで (1024x768)  Multisync 3D
は何年も使っていて、たいへん満足しています。同様な快適さを得るためには、
最低 70Hz のノンインタレースディスプレイが必要だと思います。

<!--
You have to watch a few points, though: use interlaced modes only at 
high resolutions, so that the alternately lighted lines are close
together. You might want to play with sync pulse widths and positions
to get the most stable line positions. If alternating lines are bright
and dark, interlace will <EM>jump</EM> at you. I have one application that   
chooses such a dot pattern for a menu background (XCept, no other
application I know does that, fortunately). I switch to 800x600 for
using XCept because it really hurts my eyes otherwise. 
-- >
注意が必要なこともいくつかあります。インタレースモードは高解像度でだけ使って、
一本おきの輝線がお互いに近くなるようにします。最も安定した線の位置を得るため
に、同期信号の幅と位置をいじる必要があるかもしれません。
一本おきに線が明暗すると、インタレースは <EM>ぎらぎら</EM>して見えます。
私は、メニューの背景にそのようなドットパターンを選んだアプリケーション
を一つ持っています(XCept、幸いなことに他の私の知っているアプリケーション
ではこのようなことをするものはありません)。私は、XCept を
使うときには 800x600 に切り替えます。というのはさもなければ目を痛めて
しまうからです。

<!--
For the same reason, use at least 100dpi fonts, or other fonts where
horizontal beams are at least two lines thick (for high resolutions, 
nothing else will make sense anyhow). 

And of course, never use an interlaced mode when your hardware would
support a non-interlaced one with similar refresh rate. 
-- >
同じ理由で、最低 100dpi フォントを使うこと、またはほかのフォントでも
水平ビームが最低 2 本分の厚みがあるフォントを使いましょう(高解像度には、
他のどんな方法でもだめでしょう)。

そして勿論、同様な再描画速度でノンインタレースモードをサポートして
いる機器の時はインタレースモードを使うことはできません。

<!--
If, however, you find that for some resolution you are pushing either
monitor or graphics card to their upper limits, and getting
unsatisfactory flickery or washed out (bandwidth exceeded) display,
you might want to try tackling the same resolution using an
interlaced mode. Of course this is useless if the VSF
of your monitor is already close to its limits. 
-- >
しかしながら、もしある解像度でモニタかグラフィックカードのどちらか
の上限に達してしまって不快なちらつきや色落ち (帯域幅を超えた時) 表示
が起こったと思ったら、同じ解像度でインタレースモードを試してみるといいかも
しれません。勿論、これはモニタの VSF がすでに上限に近い場合は使えません。

<!--
Design of interlaced modes is easy: do it like a non-interlaced
mode. Just two more considerations are necessary: you need an odd     
total number of vertical lines (the last number in your mode line), and
when you specify the "interlace" flag, the actual vertical frame rate
for your monitor doubles. Your monitor needs to support a 90Hz frame 
rate if the mode you specified looks like a 45Hz mode apart from the
"Interlace" flag. 
-- >
インタレースモデルの設計は簡単です。ノンインタレースモードと同じように
考えましょう。2 つの検討が必要です。"interlace" オプションを指定した時、
垂直線の総数が奇数 (モード行の最後の数値) が必要な場合、モニタ対応の
実際の垂直フレーム周波数が倍になること。45Hz のモードを "Interlace" 
オプションをつけて指定した場合、モニタが 90Hz のフレーム周波数
のサポートする必要があります。

<!--
As an example, here is my modeline for 1024x768 interlaced: my
Multisync 3D will support up to 90Hz vertical and 38kHz horizontal. 

<tscreen><verb>
ModeLine "1024x768" 45 1024 1048 1208 1248 768 768 776 807 Interlace
</verb></tscreen>
-- >
例えば、1024x768 のインタレースモードのモード行があった場合、Multisync
3D は 90Hz の垂直フレーム周波数と 38kHz の 水平フレーム周波数になります。

<tscreen><verb>
ModeLine "1024x768" 45 1024 1048 1208 1248 768 768 776 807 Interlace
</verb></tscreen>

<!--
Both limits are pretty much exhausted with this mode. Specifying the
same mode, just without the "Interlace" flag, still is almost at the
limit of the monitor's horizontal capacity (and strictly speaking, a
bit under the lower limit of vertical scan rate), but produces an
intolerably flickery display. 
-- >
両方の上限はかなりこのモードでは使い尽くされたものです。同じモードを
指定するのに "Interlace" オプションをつけない場合は既にモニタの水平
方向の容量のほとんど上限です(厳密に言えば、垂直走査周波数の下限より
少し下回ります)。しかし、耐えられないほどのちらつきを生じます。

<!--
Basic design rules: if you have designed a mode at less than half of   
your monitor's vertical capacity, make the vertical total of lines odd
and add the "Interlace" flag. The display's quality should vastly    
improve in most cases. 
-- >
基本的な設計ルールは、モニタの垂直容量の半分以下にモードを設計する
場合は垂直方向の線の合計を奇数にして "Interlace" オプションを追加
しましょう。ほとんどの場合、表示の品質は非常に向上するで
しょう。

<!--
If you have a non-interlaced mode otherwise exhausting your monitor's
specs where the vertical scan rate lies about 30% or more under the
maximum of your monitor, hand-designing an interlaced mode (probably
with somewhat higher resolution) could deliver superior results, but I
won't promise it. 
-- >
モニタの 30% から最大以下の垂直走査周波数のモニタの仕様が疲れるものと
異なるノンインタレースモードを使う場合は、インタレースモードを手作りで
作る(多分、多少高い解像度になるでしょう)とすばらしい結果を得る
ことができます。しかし約束はできませんけど。

<!--
<sect>Questions and Answers<label id="answe">
-- >
<sect>質疑応答<label id="answe">
<p>

<!--
   Q. The example you gave is not a standard screen size, can I use it? 

   A. Why not?  There is NO reason whatsoever why you have to use 640x480,
800x600, or even 1024x768.  The XFree86 servers let you configure your hardware
with a lot of freedom.  It usually takes two to three tries to come up the
right one.  The important thing to shoot for is high refresh rate with
reasonable viewing area. not high resolution at the price of eye-tearing
flicker! 
-- >
  Q. ここにある例題は標準的な画面サイズではありませんが、使ってもよいで
  すか？

  A. 勿論です。なにがなんでも 640x480, 800x600 とか 1024x768 を使わなけ
  ればならない理由はありません。XFree86 ドライバはハードウェアを自由に設
  定できるようになっています。一般に正しい設定は 2 、3 分でできるように
  なります。正しい設定を当てるのに重要な物は高い再描画速度と妥当な表示領
  域です。高解像度だけを追求して涙目を誘うちらつきに代償を払うことのない
  ようにしてください。

<!--
   Q. It this the only resolution given the 65Mhz dot clock and 55Khz HSF? 

   A. Absolutely not!  You are encouraged to follow the general procedure and
do some trial-and-error to come up a setting that's really to your liking.
Experimenting with this can be lots of fun.  Most settings may just give you
nasty video hash, but in practice a modern multi-sync monitor is usually not
damaged easily. Be sure though, that your monitor can support the frame
rates of your mode before using it for longer times. 

   Beware fixed-frequency monitors!  This kind of hacking around can damage
them rather quickly. Be sure you use valid refresh rates for <EM>every</EM>
experiment on them.
-- >
  Q. 65Mhz のドットクロックと 55Khz の HSF で得られる解像度はこれだけ
  ですか？

  A. 絶対そんなことはありません！ 一般的な手順に従って作業を行い、本当に
  好みの設定にたどり着くため、少しの試行の繰り返しをお勧めします。 実験
  はとっても楽しいものです。 ほとんどの設定はビデオ表示が乱れてちゃんと
  設定できないかもしれませんが、マルチシンクモニタを (帯域幅よりもはる
  かに高い周波数のクロックを出力させようとしない限りは --- モニタの説
  明書に書かれている最大解像度に近い値を守っている場合は) 痛めることはあ
  りません。固定周波数のモニタには注意してください。周波数調整は固定周
  波数のモニタを痛める<EM>かも</EM>しれません。

<!--
   Q. You just mentioned two standard resolutions. In Xconfig, there are many
standard resolutions available, can you tell me whether there's any point in
tinkering with timings? 

   A. Absolutely!  Take, for example, the "standard" 640x480 listed in the
current Xconfig.  It employs 25Mhz driving frequency, frame lengths are 800
and 525 => refresh rate ~ 59.5Hz. Not too bad.  But 28Mhz is a commonly
available driving frequency from many SVGA boards.  If we use it to drive
640x480, following the procedure we discussed above, you would get frame
lengths like 812 and 505.  Now the refresh rate is raised to 68Hz, a
quite significant improvement over the standard one.   
-- >
  Q. 二つの標準的な解像度を記載してますね。 Xconfig の中では色々標準的な
  解像度がありますが、時間調節の数値を調整する場合のポイントを教えてくだ
  さい。

  A. 勿論教えましょう！ 現在の Xconfig にある "標準的な" 640x480 を例題
  に取り上げます。この場合、動作周波数が 25MHz 、フレーム長が 800 と 525
  の時に約 59.5Hz の画面再描画速度が使えます。 悪く無いでしょ？ しかし
  一般的に多くの SVGA ボードの動作周波数は 28MHz を使えます。28MHz で
  640x480 を使う場合、以前に説明した手順に従えば、フレーム長は 812 と
  505 に設定できます。ここで再描画速度は 68MHz まで引き上げられ、標準
  値よりかなり向上しました。

<!--
    Q. Can you summarize what we have discussed so far? 

    A. In a nutshell: 

<enum>
<item>
for any fixed driving frequency, raising max resolution incurs the penalty
of lowering refresh rate and thus introducing more flicker.
<item>
if high resolution is desirable and your monitor supports it, try to
get a SVGA card that provides a matching dot clock or DCF. The higher,
the better!
</enum>
-- >
  Q. 今までの議論をまとめてもらえますか？

  A. 要約して言えば :

<enum>
<item>
任意の固定の動作周波数では、最高の解像度に高めれば再描画速度を下げ
なければならず、したがってちらつきが増えるでしょう。

<item>
高解像度を希望しモニタがそれをサポートするときは、それに合うドッ
トクロック、つまり DCF を供給する SVGA カードを手に入れて下さい。
ドットクロックは高いに越したことはありません。
</enum>

<!--
<sect>Fixing Problems with the Image.<label id="fixes">
-- >
<sect>画像表示の問題修正<label id="fixes">
<p>

<!--
OK, so you've got your X configuration numbers.  You put them in Xconfig with
a test mode label.  You fire up X, hot-key to the new mode, ... and the image
doesn't look right.  What do you do?  Here's a list of common problems and how
to fix them. 

(Fixing these minor distortions is where <bf>xvidtune</bf>(1) really shines.)

You <em>move</em> the image by changing the sync pulse timing.  You
<em>scale</em> it by changing the frame length (you need to move the
sync pulse to keep it in the same relative position, otherwise scaling will
move the image as well).  Here are some more specific recipes: 
-- >
さあ、 X の構成定義の数値を手に入れました。Xconfig に その数値をテスト
中のコメントをつけて書きました。X を立ちあげ、ホットキーで新しいモード
に切り替えてみました ... しかし画像が変です。こういう場合、どうすれば
いいのでしょう？一般的な問題と解決策をここに挙げます。

(小さな歪みの修正において <bf>xvidtune</bf>(1) が秀でています。)

同期信号の調整を変えて画像を <EM>移動</EM> してみてください。フレーム長を変え
て画像を <EM>拡大縮小</EM> して下さい (相対的な位置をそのままに同期信号を移動
する必要があります。そうしないと拡大縮小と同時に画像の移動も起こってし
まいます) 。もう少し個別の対処方法を次に示します。:

<!--
The horizontal and vertical positions are independent.  That is, moving the
image horizontally doesn't affect placement vertically, or vice-versa.
However, the same is not quite true of scaling.  While changing the horizontal
size does nothing to the vertical size or vice versa, the total change in both
may be limited.  In particular, if your image is too large in both dimensions
you will probably have to go to a higher dot clock to fix it.  Since this
raises the usable resolution, it is seldom a problem! 
-- >
水平と垂直の表示位置は独立しています。これは画像を水平に移動させても垂
直位置には影響がなく、また逆も同じということです。ところが拡大縮小では
必ずしもそうではありません。水平方向の大きさを変えても垂直方向の大きさ
には何も影響を与えず、逆も同じですが、縦横両方の変更量の合計は限定され
ています。特に、縦横に大き過ぎた場合はより高いドットクロックに変更して
修正する必要があるでしょう。使用可能な解像度を引き上げることになるた
め、これはめったに問題とはなりません。

<!--
<sect1>The image is displaced to the left or right
-- >
<sect1>画像が左か右にずれている場合
<p>

<!--
To fix this, move the horizontal sync pulse.  That is, increment or decrement
(by a multiple of 8) the middle two numbers of the horizontal timing section
that define the leading and trailing edge of the horizontal sync pulse. 

If the image is shifted left (right border too large, you want to move
the image to the right) decrement the numbers.  If the image is shifted right
(left border too large, you want it to move left) increment the sync pulse. 
-- >
これを修正するために水平同期信号を移動しましょう。それは水平同期信号の
開始端と終了端を定義している水平調整部分の真ん中の 2 つの数値を
 ( 8 の倍数ずつ) 増減させて行いましょう。

画像が左にずれている (右の縁の部分が大きすぎて、右へ画像を移動したい) 
時は、数値を増やしてください。画像が右にずれている (左の縁の部分が大き
すぎて、左へ画像を移動したい) 時は、同期信号を減らしてください。

<!--
<sect1>The image is displaced up or down
-- >
<sect1>画像が上下に動いている場合
<p>

<!--
To fix this, move the vertical sync pulse.  That is, increment or decrement the
middle two numbers of the vertical timing section that define the leading and
trailing edge of the vertical sync pulse. 

If the image is shifted up (lower border too large, you want to move the image
down) decrement the numbers.  If the image is shifted down (top border too
large, you want it to move up) increment the numbers. 
-- >
これを修正するために垂直同期信号を移動してください。それは垂直同期信号
の開始端と終了端を定義している垂直調整部分の真ん中の 2 つの数値
を増減させて行いましょう。

画像が上にずれている (下の縁の部分が大きすぎて、下に画像を移動したい) 
時は、数値を減らしてください。画像が下にずれている (上の縁の部分が大き
すぎて、上へ画像を移動したい) 時は、数値を増やしてください。

<!--
<sect1>The image is too large both horizontally and vertically
-- >
<sect1>画像が垂直と水平の両方に膨らんでいる場合
<p>

<!--
Switch to a higher card clock speed. If you have multiple modes in your
clock file, possibly a lower-speed one is being activated by mistake.
-- >
より高いカードクロックに切り替えましょう。クロックファイルに複数の
モードがある場合、あるいは低い方の速度のモードに間違って作動させている
かもしれません。

<!--
<sect1>The image is too wide (too narrow) horizontally
-- >
<sect1>画像が水平方向に広すぎる (狭すぎる) 場合
<p>

<!--
To fix this, increase (decrease) the horizontal frame length.  That is, change
the fourth number in the first timing section.  To avoid moving the image, also
move the sync pulse (second and third numbers) half as far, to keep it in the
same relative position. 
-- >
これを修正するためには水平フレーム長を増やし (減らし) てください。それ
は最初の調整部分の 4 番目の数値を変えて行います。画像が移動するのを回
避するため、同期信号 ( 2 番目と 3 番目の数値) もその半分だけ移動し、同
じ相対位置を保存しておいてください。

<!--
<sect1>The image is too deep (too shallow) vertically
-- >
<sect1>画像が垂直方向に膨らんでいる (痩せている) 場合
<p>

<!--
To fix this, increase (decrease) the vertical frame length.  That is, change
the fourth number in the second timing section.  To avoid moving the image,
also move the sync pulse (second and third numbers) half as far, to keep it in
the same relative position. 

Any distortion that can't be handled by combining these techniques is probably
evidence of something more basically wrong, like a calculation mistake or a
faster dot clock than the monitor can handle. 

Finally, remember that increasing either frame length will decrease your
refresh rate, and vice-versa. 
-- >
これを修正するためには垂直フレーム長を減らし (増やし) てください。それ
は 2 番目の調整部分の 4 番目の数値を変えて行います。画像が移動するのを
回避するため、同期信号 ( 2 番目と 3 番目の数値で) もその半分だけ移動
し、同じ相対位置を保存しておいてください。

これらの技術の組合せでも取れない他の歪みは多分もっと基本的な部分が違っ
ている、例えば計算違いとかモニタで使えない高いドットクロックを使って
いるような場合があります。

最後に、フレーム長のどちらかの数値を増やせば再描画速度が低下してしまう
こと、またその逆も言えることを覚えておいて下さい。

<!--
<sect>Plotting Monitor Capabilities<label id="cplot">
-- >
<sect>モニタの特性をプロットする。<label id="cplot">
<p>

<!--
To plot a monitor mode diagram, you'll need the gnuplot package (a
freeware plotting language for UNIX-like operating systems) and the
tool <TT>modeplot</TT>, a shell/gnuplot script to plot the diagram from your
monitor characteristics, entered as command-line options. 
-- >
モニタモードダイアグラムをプロットするには、gnuplot パッケージ (UNIX
のようなオペレーティングシステム用のフリーウェアのプロット言語) と
コマンドラインから入力したモニタの特性から gnuplot で ダイアグラムを
プロットする shell スクリプトである <TT>modeplot</TT> ツールが必要です。

<!--
Here is a copy of modeplot:
-- >
ここからは modeplot のリストです。:

<code>
#!/bin/sh
#
# modeplot -- generate X mode plot of available monitor modes
# modeplot -- 使用可能なモニタのモードから X モードプロットを生成します。 
#
# Do `modeplot -?' to see the control options.
# `modeplot -?' と入力すると制御オプションを見ることができます。
#
# ($Id: VidModes.sgml,v 3.2.2.2 1999/05/25 12:00:33 hohndel Exp $)

# Monitor description. Bandwidth in MHz, horizontal frequencies in kHz
# and vertical frequencies in Hz.
# モニタの説明。帯域幅を MHz で、水平周波数を kHz で、それと垂直周波数を
# Hz で指定しましょう。
TITLE="Viewsonic 21PS"
BANDWIDTH=185
MINHSF=31
MAXHSF=85
MINVSF=50
MAXVSF=160
ASPECT="4/3"
vesa=72.5	# VESA-recommended minimum refresh rate
	    # VESA-推奨の最小再描画速度
while [ "$1" != "" ] 
do
	case $1 in
	-t) TITLE="$2"; shift;; 
	-b) BANDWIDTH="$2"; shift;; 
	-h) MINHSF="$2" MAXHSF="$3"; shift; shift;; 
	-v) MINVSF="$2" MAXVSF="$3"; shift; shift;; 
	-a) ASPECT="$2"; shift;; 
	-g) GNUOPTS="$2"; shift;; 
	-?) cat <<EOF
modeplot control switches:

-t "<description>"	name of monitor            defaults to "Viewsonic 21PS"
-b <nn>           	bandwidth in MHz           defaults to 185
-h <min> <max>   	min & max HSF (kHz)        defaults to 31 85
-v <min> <max>   	min & max VSF (Hz)         defaults to 50 160
-a <aspect ratio>	aspect ratio               defaults to 4/3
-g "<options>"   	pass options to gnuplot
modeplot 制御スイッチ:

-t "<種類>"		モニタ名称		標準値は "Viewsonic 21PS"
-b <nn>			帯域幅を MHz で		標準値は 185
-h <最小> <最大>	最小と最大の HSF を kHz で 標準値は 31 85
-v <最小> <最大>	最小と最大の VSF を Hz で  標準値は 50 160
-a <アスペクト比>	アスペクト比		標準値は 4/3
-g "<オプション>"	gnuplot へ渡すオプション

The -b, -h and -v options are required, -a, -t, -g optional.  You can
use -g to pass a device type to gnuplot so that (for example) modeplot's
output can be redirected to a printer.  See gnuplot(1) for  details.

The modeplot tool was created by Eric S. Raymond <esr@thyrsus.com> based on
analysis and scratch code by Martin Lottermoser <Martin.Lottermoser@mch.sni.de>

-b, -h と -v オプションは必須で、-a, -t, -g はオプションです。
-g でデバイスタイプを gnuplot に渡します。従って例えば modeplot の
出力はプリンタにリダイレクトされます。詳細は  gnuplot(1) のマニュアルを
御覧下さい。

modeplot ツールは Eric S. Raymond <esr@thyrsus.com> が
 Martin Lottermoser <Martin.Lottermoser@mch.sni.de> による
分析と一から書いたコードを元に作成しました。

This is modeplot $Revision: 3.2.2.2 $
EOF
		exit;;
	esac
	shift
done

gnuplot $GNUOPTS <<EOF
set title "$TITLE Mode Plot"

# Magic numbers.  Unfortunately, the plot is quite sensitive to changes in
# these, and they may fail to represent reality on some monitors.  We need
# to fix values to get even an approximation of the mode diagram.  These come
# from looking at lots of values in the ModeDB database.
F1 = 1.30	# multiplier to convert horizontal resolution to frame width
F2 = 1.05	# multiplier to convert vertical resolution to frame height
# 魔法の数値です。残念ながら、プロットはこれらの数値を変更することに対して
# 非常に敏感です。またこれらの数値で幾つかの代表的なモニタで実際にうまく
# 行かない場合があります。我々はモードダイアグラムの概算をむら無く取得できる
# 数値になるように修正していきます。これらの数値は ModeDB データベースの
# 多量の数字から導き出しました。
F1 = 1.30	# 水平解像度をフレーム幅に変換する乗数
F2 = 1.05	# 垂直解像度をフレーム幅に変換する乗数

# Function definitions (multiplication by 1.0 forces real-number arithmetic)
# 関数定義 (1.0 を掛けると実際の数の計算となる)
ac = (1.0*$ASPECT)*F1/F2
refresh(hsync, dcf) = ac * (hsync**2)/(1.0*dcf)
dotclock(hsync, rr) = ac * (hsync**2)/(1.0*rr)
resolution(hv, dcf) = dcf * (10**6)/(hv * F1 * F2)

# Put labels on the axes
# 軸のラベルを定義する
set xlabel 'DCF (MHz)'
set ylabel 'RR (Hz)' 6	# Put it right over the Y axis
                     	# Y 軸の右上におく

# Generate diagram
# ダイアグラムを生成する
set grid
set label "VB" at $BANDWIDTH+1, ($MAXVSF + $MINVSF) / 2 left
set arrow from $BANDWIDTH, $MINVSF to $BANDWIDTH, $MAXVSF nohead
set label "max VSF" at 1, $MAXVSF-1.5
set arrow from 0, $MAXVSF to $BANDWIDTH, $MAXVSF nohead
set label "min VSF" at 1, $MINVSF-1.5
set arrow from 0, $MINVSF to $BANDWIDTH, $MINVSF nohead
set label "min HSF" at dotclock($MINHSF, $MAXVSF+17), $MAXVSF + 17 right
set label "max HSF" at dotclock($MAXHSF, $MAXVSF+17), $MAXVSF + 17 right
set label "VESA $vesa" at 1, $vesa-1.5
set arrow from 0, $vesa to $BANDWIDTH, $vesa nohead # style -1
plot [dcf=0:1.1*$BANDWIDTH] [$MINVSF-10:$MAXVSF+20] \
  refresh($MINHSF, dcf) notitle with lines 1, \
  refresh($MAXHSF, dcf) notitle with lines 1, \
  resolution(640*480,   dcf) title "640x480  " with points 2, \
  resolution(800*600,   dcf) title "800x600  " with points 3, \
  resolution(1024*768,  dcf) title "1024x768 " with points 4, \
  resolution(1280*1024, dcf) title "1280x1024" with points 5, \
  resolution(1600*1280, dcf) title "1600x1200" with points 6

pause 9999
EOF
</code>

<!--
Once you know you have <TT>modeplot</TT> and the gnuplot package in
place, you'll need the following monitor characteristics: 
-- >
<TT>modeplot</TT> を持っていることと gnuplot パッケージがある場所を
確認したら、次に述べるモニタの特性値が必要です。:

<!--
<item> video bandwidth (VB)
<item> range of horizontal sync frequency (HSF)
<item> range of vertical sync frequency (VSF)
-- >
<itemize>
<item> ビデオ帯域幅 (VB)
<item> 水平同期周波数の範囲 (HSF)
<item> 垂直同期周波数の範囲 (VSF)
</itemize>

<!--
The plot program needs to make some simplifying assumptions which are
not necessarily correct.  This is the reason why the resulting diagram is
only a rough description. These assumptions are: 
-- >
プロットプログラムは必ずしも正確でない幾つかの仮説を容易にします。その
理由は得られたダイアグラムがざっくりした記述であるからです。
これらの仮定は:

<!--
<item> All resolutions have a single fixed aspect ratio AR = HR/VR.
Standard resolutions have AR = 4/3 or AR = 5/4.  The <TT>modeplot</TT>
programs assumes 4/3 by default, but you can override this. 
<item> For the modes considered, horizontal and vertical frame lengths are
fixed multiples of horizontal and vertical resolutions, respectively:
-- >
<enum>
<item> すべての解答は一つの固定されたアスペクト比 AR = HR/VR を使っています。
標準的な解答は have AR = 4/3 又は AR = 5/4。<TT>modeplot</TT> 
プログラムは標準で 4/3 を仮定していますが、上書き可能です。
<item> モードを考慮すると、水平と垂直のフレーム長は水平と垂直の解像度の
倍数に調整されていますので、それぞれ次のようになります:

<tscreen><verb>
	HFL = F1 * HR
	VFL = F2 * VR
</verb></tscreen>
</enum>

<!--
As a rough guide, take F1 = 1.30 and F2 = 1.05 (see <ref id=frame>
"Computing Frame Sizes").
-- >
ざっくりとした規準として、F1 = 1.30 と F2 = 1.05 として下さい。
(<ref id="frame" name="フレームサイズの計算">を参照してください。)
<!--
坂田注 : 原文中の参照の破損を訂正しています。
-- >
<!--
Now take a particular sync frequency, HSF.  Given the assumptions just
presented, every value for the clock rate DCF already determines the
refresh rate RR, i.e. for every value of HSF there is a function RR(DCF).
This can be derived as follows. 
-- >
さて特にこの同期周波数である HSF を取り上げてみます。現在の所の仮定は
ドットクロック DCF のためのすべての数値は既に決定された再描画速度 RR、
例えば HSF は関数 RR(DCF) で与えられます。これば次の割り算で得られます。 

<!--
The refresh rate is equal to the clock rate divided by the product of the
frame sizes: 
-- >
再描画速度はフレームサイズの積でドットクロックを割ったものです。:

<tscreen><verb>
	RR = DCF / (HFL * VFL)		(*)
</verb></tscreen>

<!--
On the other hand, the horizontal frame length is equal to the clock rate
divided by the horizontal sync frequency: 
-- >
他には、水平フレーム長はドットクロックを水平同期周波数で割ったものです。:

<tscreen><verb>
	HFL = DCF / HSF			(**)
</verb></tscreen>

<!--
VFL can be reduced to HFL be means of the two assumptions above: 
-- >
VFL は HFL を 2 つの改定値で切り詰めたものです。:

<tscreen><verb>
	VFL = F2 * VR
	    = F2 * (HR / AR)
	    = (F2/F1) * HFL / AR	(***)
</verb></tscreen>

<!--
Inserting (**) and (***) into (*) we obtain: 
-- >
(**) と (***) を (*) に代入すると:

<tscreen><verb>
	RR = DCF / ((F2/F1) * HFL**2 / AR)
	   = (F1/F2) * AR * DCF * (HSF/DCF)**2
	   = (F1/F2) * AR * HSF**2 / DCF
</verb></tscreen>

<!--
For fixed HSF, F1, F2 and AR, this is a hyperbola in our diagram.  Drawing
two such curves for minimum and maximum horizontal sync frequencies we
have obtained the two remaining boundaries of the permitted region. 
-- >
HSF, F1, F2 と AR を固定すると、ダイアグラムは双曲線になります。この曲線
の中の最小と最大の水平同期周波数で許容領域の残りの境界線が得られます。

<!--
The straight lines crossing the capability region represent particular
resolutions. This is based on (*) and the second assumption: 
-- >
特性領域と直線の交線が特定の解像度を表します。これは (*) 式を元にして
2 番目の仮定になります。:

<tscreen><verb>
	RR = DCF / (HFL * VFL) = DCF / (F1 * HR * F2 * VR)
</verb></tscreen>

<!--
By drawing such lines for all resolutions one is interested in, one
can immediately read off the possible relations between resolution,
clock rate and refresh rate of which the monitor is capable. Note that
these lines do not depend on monitor properties, but they do depend on
the second assumption. 
-- >
すべての解像度でこのような線を描く事によって興味深いのは、解像度、
クロック周波数とモニタの再描画速度の関係に密接な関係があるという事
です。これらの線はモニタの特性には依存していませんが、2 つ目の仮定には
依存しています。

<!--
The <TT>modeplot</TT> tool provides you with an easy way to do this.  Do
<TT>modeplot -?</TT> to see its control options. A typical invocation 
looks like this: 
-- >
<TT>modeplot</TT> ツールはこの作業を簡単にします。<TT>modeplot -?</TT> 
と入力して制御オプションを見てください。典型的な実行形式は次のようです。:

<tscreen><verb>
	modeplot -t "Swan SW617" -b 85 -v 50 90 -h 31 58
</verb></tscreen>

<!--
The -b option specifies video bandwidth; -v and -h set horizontal and
vertical sync frequency ranges. 
-- >
-b オプションはビデオの帯域幅を指定します。-v と -h は水平と垂直同期
周波数の範囲を指定します。

<!--
When reading the output of <TT>modeplot</TT>, always bear in mind that
it gives only an approximate description. For example, it disregards
limitations on HFL resulting from a minimum required sync pulse width,
and it can only be accurate as far as the assumptions are.  It is
therefore no substitute for a detailed calculation (involving some
black magic) as presented in <ref id="synth" name="Putting it All
Together">. However, it should give you a better feeling for what
is possible and which tradeoffs are involved. 
-- >
<TT>modeplot</TT> の出力を読むときは、近似表現のみであることを常に
覚えておいて下さい。例えば、最小同期信号幅から得られた HFL の上限を
無視して、仮定と殆んどものとします。従って
<ref id="synth" name="全体のまとめ">
に示すように、(幾つかの黒魔術を伴って) 詳細な計算式に代入する事は
ありません。しかしながら、可能であり、トレードオフがある
ことが分かればすっきりするでしょう。

<!--
<sect>Credits<label id="credi">
-- >
<sect>協力者、提供者について<label id="credi">
<p>

<!--
The original ancestor of this document was by Chin Fang
&lt;fangchin@leland.stanford.edu&gt;.   
-- >
この文書の最初の原型は Chin Fang &lt;fangchin@leland.stanford.edu&gt; が書き
ました。

<!--
Eric S. Raymond &lt;esr@snark.thyrsus.com&gt; reworked, reorganized, and
massively rewrote Chin Fang's original in an attempt to understand it.  In
the process, he merged in most of a different how-to by Bob Crosson
&lt;crosson@cam.nist.gov&gt;. 
-- >
Eric S. Raymond &lt;esr@snark.thyrsus.com&gt; が書き直し、再編制して、
Chin Fang の元文書を分かりやすくなるように大規模に書き換えました。
この過程で、Bob Crosson &lt;crosson@cam.nist.gov&gt; による色々な how-to
文書を統合しました。 

<!--
The material on interlaced modes is largely by David Kastrup
&lt;dak@pool.informatik.rwth-aachen.de&gt; 
-- >
インタレースモードに関する資料は主として David Kastrup
&lt;dak@pool.informatik.rwth-aachen.de&gt; によります。

<!--
Martin Lottermoser &lt;Martin.Lottermoser@mch.sni.de&gt; contributed
the idea of using gnuplot to make mode diagrams and did the
mathematical analysis behind <TT>modeplot</TT>.  The distributed
<TT>modeplot</TT> was redesigned and generalized by ESR from
Martin's original gnuplot code for one case.
-- >
Martin Lottermoser &lt;Martin.Lottermoser@mch.sni.de&gt; は gnuplot
を用いてモードダイアグラムを作画する事の着想に寄与し、<TT>modeplot</TT>
の背後にある数学的な解析を行いました。
ESR が配布する <TT>modeplot</TT> は Martin の元の gnuplot の一件の
場合のスクリプトから再設計と一般化を行いました。 <newline>
&lsqb;訳注 : ESR は Eric S. Raymond です。&rsqb;
<verb>
$XFree86: xc/programs/Xserver/hw/xfree86/doc/Japanese/sgml/VidModes.sgml,v 3.2.2.3 1999/11/26 15:23:52 hohndel Exp $
02/20 23:10:30 dawes Exp $

$XConsortium: VidModes.sgml /main/7 1996/02/21 17:46:17 kaleb $
</verb>

<sect>日本語訳について<p>
この日本語訳は
岡本一幸さん &lt;ikko-@pacific.rim.or.jp&gt; と
Hiro Sugawara さん&lt;hiro@arkusa.com&gt; 
の 3.3.2 版の翻訳をベースに
X Japanese Documentation Project が更新を行ったものです。
(更新: 坂田智之 <url url="mailto:sakata@hoehoe.sci.ibaraki.ac.jp"
name="&lt;sakata@hoehoe.sci.ibaraki.ac.jp&gt;">)。

</article>

<!--
The following sets edit modes for GNU EMACS
Local Variables:
fill-prefix:"\t"
fill-column:75
End:
-- >
